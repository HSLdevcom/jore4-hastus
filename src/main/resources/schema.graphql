schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "refresh the cache entry"
    refresh: Boolean! = false,
    "measured in seconds"
    ttl: Int! = 60
  ) on QUERY

"Marks the field, argument, input field or enum value as deprecated"
directive @deprecated(
    "The reason for the deprecation"
    reason: String = "No longer supported"
  ) on FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM_VALUE | INPUT_FIELD_DEFINITION

"Directs the executor to include this field or fragment only when the `if` argument is true"
directive @include(
    "Included when true."
    if: Boolean!
  ) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Directs the executor to skip this field or fragment when the `if` argument is true."
directive @skip(
    "Skipped when true."
    if: Boolean!
  ) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Exposes a URL that specifies the behaviour of this scalar."
directive @specifiedBy(
    "The URL that specifies the behaviour of this scalar."
    url: String!
  ) on SCALAR

type CombineTimetablesOutput {
  combinedIntoVehicleScheduleFrameIds: [uuid]!
}

type ReplaceTimetablesOutput {
  replacedVehicleScheduleFrameIds: [uuid]!
}

type ToCombineTargetVehicleScheduleFrameIdOutput {
  toCombineTargetVehicleScheduleFrameId: uuid!
}

type ToReplaceVehicleScheduleFrameIdsOutput {
  toReplaceVehicleScheduleFrameIds: [uuid]!
}

"Legacy, avoid using. Main use nowadays is to enable support for eg. data exports that still need this. Originally this was used to represent the primary region for routes/lines."
type hsl_route_legacy_hsl_municipality_code {
  hsl_municipality: String!
  jore3_code: smallint!
  "An array relationship"
  lines(
    "distinct select on columns"
    distinct_on: [route_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_line_order_by!],
    "filter the rows returned"
    where: route_line_bool_exp
  ): [route_line!]!
  "An aggregate relationship"
  lines_aggregate(
    "distinct select on columns"
    distinct_on: [route_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_line_order_by!],
    "filter the rows returned"
    where: route_line_bool_exp
  ): route_line_aggregate!
  "An array relationship"
  routes(
    "distinct select on columns"
    distinct_on: [route_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_route_order_by!],
    "filter the rows returned"
    where: route_route_bool_exp
  ): [route_route!]!
  "An aggregate relationship"
  routes_aggregate(
    "distinct select on columns"
    distinct_on: [route_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_route_order_by!],
    "filter the rows returned"
    where: route_route_bool_exp
  ): route_route_aggregate!
}

"aggregated selection of \"hsl_route.legacy_hsl_municipality_code\""
type hsl_route_legacy_hsl_municipality_code_aggregate {
  aggregate: hsl_route_legacy_hsl_municipality_code_aggregate_fields
  nodes: [hsl_route_legacy_hsl_municipality_code!]!
}

"aggregate fields of \"hsl_route.legacy_hsl_municipality_code\""
type hsl_route_legacy_hsl_municipality_code_aggregate_fields {
  avg: hsl_route_legacy_hsl_municipality_code_avg_fields
  count(columns: [hsl_route_legacy_hsl_municipality_code_select_column!], distinct: Boolean): Int!
  max: hsl_route_legacy_hsl_municipality_code_max_fields
  min: hsl_route_legacy_hsl_municipality_code_min_fields
  stddev: hsl_route_legacy_hsl_municipality_code_stddev_fields
  stddev_pop: hsl_route_legacy_hsl_municipality_code_stddev_pop_fields
  stddev_samp: hsl_route_legacy_hsl_municipality_code_stddev_samp_fields
  sum: hsl_route_legacy_hsl_municipality_code_sum_fields
  var_pop: hsl_route_legacy_hsl_municipality_code_var_pop_fields
  var_samp: hsl_route_legacy_hsl_municipality_code_var_samp_fields
  variance: hsl_route_legacy_hsl_municipality_code_variance_fields
}

"aggregate avg on columns"
type hsl_route_legacy_hsl_municipality_code_avg_fields {
  jore3_code: Float
}

"aggregate max on columns"
type hsl_route_legacy_hsl_municipality_code_max_fields {
  hsl_municipality: String
  jore3_code: smallint
}

"aggregate min on columns"
type hsl_route_legacy_hsl_municipality_code_min_fields {
  hsl_municipality: String
  jore3_code: smallint
}

"response of any mutation on the table \"hsl_route.legacy_hsl_municipality_code\""
type hsl_route_legacy_hsl_municipality_code_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [hsl_route_legacy_hsl_municipality_code!]!
}

"aggregate stddev on columns"
type hsl_route_legacy_hsl_municipality_code_stddev_fields {
  jore3_code: Float
}

"aggregate stddev_pop on columns"
type hsl_route_legacy_hsl_municipality_code_stddev_pop_fields {
  jore3_code: Float
}

"aggregate stddev_samp on columns"
type hsl_route_legacy_hsl_municipality_code_stddev_samp_fields {
  jore3_code: Float
}

"aggregate sum on columns"
type hsl_route_legacy_hsl_municipality_code_sum_fields {
  jore3_code: smallint
}

"aggregate var_pop on columns"
type hsl_route_legacy_hsl_municipality_code_var_pop_fields {
  jore3_code: Float
}

"aggregate var_samp on columns"
type hsl_route_legacy_hsl_municipality_code_var_samp_fields {
  jore3_code: Float
}

"aggregate variance on columns"
type hsl_route_legacy_hsl_municipality_code_variance_fields {
  jore3_code: Float
}

"Transport target, can be used e.g. for cost sharing."
type hsl_route_transport_target {
  "An array relationship"
  lines(
    "distinct select on columns"
    distinct_on: [route_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_line_order_by!],
    "filter the rows returned"
    where: route_line_bool_exp
  ): [route_line!]!
  "An aggregate relationship"
  lines_aggregate(
    "distinct select on columns"
    distinct_on: [route_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_line_order_by!],
    "filter the rows returned"
    where: route_line_bool_exp
  ): route_line_aggregate!
  transport_target: String!
}

"aggregated selection of \"hsl_route.transport_target\""
type hsl_route_transport_target_aggregate {
  aggregate: hsl_route_transport_target_aggregate_fields
  nodes: [hsl_route_transport_target!]!
}

"aggregate fields of \"hsl_route.transport_target\""
type hsl_route_transport_target_aggregate_fields {
  count(columns: [hsl_route_transport_target_select_column!], distinct: Boolean): Int!
  max: hsl_route_transport_target_max_fields
  min: hsl_route_transport_target_min_fields
}

"aggregate max on columns"
type hsl_route_transport_target_max_fields {
  transport_target: String
}

"aggregate min on columns"
type hsl_route_transport_target_min_fields {
  transport_target: String
}

"response of any mutation on the table \"hsl_route.transport_target\""
type hsl_route_transport_target_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [hsl_route_transport_target!]!
}

"The direction in which an e.g. infrastructure link can be traversed"
type infrastructure_network_direction {
  "An array relationship"
  infrastructure_links(
    "distinct select on columns"
    distinct_on: [infrastructure_network_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_infrastructure_link_bool_exp
  ): [infrastructure_network_infrastructure_link!]!
  "An aggregate relationship"
  infrastructure_links_aggregate(
    "distinct select on columns"
    distinct_on: [infrastructure_network_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_infrastructure_link_bool_exp
  ): infrastructure_network_infrastructure_link_aggregate!
  value: String!
}

"aggregated selection of \"infrastructure_network.direction\""
type infrastructure_network_direction_aggregate {
  aggregate: infrastructure_network_direction_aggregate_fields
  nodes: [infrastructure_network_direction!]!
}

"aggregate fields of \"infrastructure_network.direction\""
type infrastructure_network_direction_aggregate_fields {
  count(columns: [infrastructure_network_direction_select_column!], distinct: Boolean): Int!
  max: infrastructure_network_direction_max_fields
  min: infrastructure_network_direction_min_fields
}

"aggregate max on columns"
type infrastructure_network_direction_max_fields {
  value: String
}

"aggregate min on columns"
type infrastructure_network_direction_min_fields {
  value: String
}

"response of any mutation on the table \"infrastructure_network.direction\""
type infrastructure_network_direction_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [infrastructure_network_direction!]!
}

"An external source from which infrastructure network parts are imported"
type infrastructure_network_external_source {
  "An array relationship"
  infrastructure_links(
    "distinct select on columns"
    distinct_on: [infrastructure_network_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_infrastructure_link_bool_exp
  ): [infrastructure_network_infrastructure_link!]!
  "An aggregate relationship"
  infrastructure_links_aggregate(
    "distinct select on columns"
    distinct_on: [infrastructure_network_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_infrastructure_link_bool_exp
  ): infrastructure_network_infrastructure_link_aggregate!
  value: String!
}

"aggregated selection of \"infrastructure_network.external_source\""
type infrastructure_network_external_source_aggregate {
  aggregate: infrastructure_network_external_source_aggregate_fields
  nodes: [infrastructure_network_external_source!]!
}

"aggregate fields of \"infrastructure_network.external_source\""
type infrastructure_network_external_source_aggregate_fields {
  count(columns: [infrastructure_network_external_source_select_column!], distinct: Boolean): Int!
  max: infrastructure_network_external_source_max_fields
  min: infrastructure_network_external_source_min_fields
}

"aggregate max on columns"
type infrastructure_network_external_source_max_fields {
  value: String
}

"aggregate min on columns"
type infrastructure_network_external_source_min_fields {
  value: String
}

"response of any mutation on the table \"infrastructure_network.external_source\""
type infrastructure_network_external_source_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [infrastructure_network_external_source!]!
}

"The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453"
type infrastructure_network_infrastructure_link {
  "The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string."
  direction: infrastructure_network_direction_enum!
  "An object relationship"
  directionByDirection: infrastructure_network_direction!
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: float8
  external_link_id: String!
  external_link_source: infrastructure_network_external_source_enum!
  "An object relationship"
  external_source: infrastructure_network_external_source!
  "An array relationship"
  infrastructure_link_along_routes(
    "distinct select on columns"
    distinct_on: [route_infrastructure_link_along_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_infrastructure_link_along_route_order_by!],
    "filter the rows returned"
    where: route_infrastructure_link_along_route_bool_exp
  ): [route_infrastructure_link_along_route!]!
  "An aggregate relationship"
  infrastructure_link_along_routes_aggregate(
    "distinct select on columns"
    distinct_on: [route_infrastructure_link_along_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_infrastructure_link_along_route_order_by!],
    "filter the rows returned"
    where: route_infrastructure_link_along_route_bool_exp
  ): route_infrastructure_link_along_route_aggregate!
  "The ID of the infrastructure link."
  infrastructure_link_id: uuid!
  "An array relationship"
  scheduled_stop_points_located_on_infrastructure_link(
    "distinct select on columns"
    distinct_on: [service_pattern_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): [service_pattern_scheduled_stop_point!]!
  "An aggregate relationship"
  scheduled_stop_points_located_on_infrastructure_link_aggregate(
    "distinct select on columns"
    distinct_on: [service_pattern_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): service_pattern_scheduled_stop_point_aggregate!
  "A PostGIS LinestringZ geography in EPSG:4326 describing the infrastructure link."
  shape: geography!
  "An array relationship"
  vehicle_submode_on_infrastructure_link(
    "distinct select on columns"
    distinct_on: [infrastructure_network_vehicle_submode_on_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_vehicle_submode_on_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  ): [infrastructure_network_vehicle_submode_on_infrastructure_link!]!
  "An aggregate relationship"
  vehicle_submode_on_infrastructure_link_aggregate(
    "distinct select on columns"
    distinct_on: [infrastructure_network_vehicle_submode_on_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_vehicle_submode_on_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  ): infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate!
  "An array relationship"
  vehicle_submode_on_infrastructure_links(
    "distinct select on columns"
    distinct_on: [infrastructure_network_vehicle_submode_on_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_vehicle_submode_on_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  ): [infrastructure_network_vehicle_submode_on_infrastructure_link!]!
  "An aggregate relationship"
  vehicle_submode_on_infrastructure_links_aggregate(
    "distinct select on columns"
    distinct_on: [infrastructure_network_vehicle_submode_on_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_vehicle_submode_on_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  ): infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate!
}

"aggregated selection of \"infrastructure_network.infrastructure_link\""
type infrastructure_network_infrastructure_link_aggregate {
  aggregate: infrastructure_network_infrastructure_link_aggregate_fields
  nodes: [infrastructure_network_infrastructure_link!]!
}

"aggregate fields of \"infrastructure_network.infrastructure_link\""
type infrastructure_network_infrastructure_link_aggregate_fields {
  avg: infrastructure_network_infrastructure_link_avg_fields
  count(columns: [infrastructure_network_infrastructure_link_select_column!], distinct: Boolean): Int!
  max: infrastructure_network_infrastructure_link_max_fields
  min: infrastructure_network_infrastructure_link_min_fields
  stddev: infrastructure_network_infrastructure_link_stddev_fields
  stddev_pop: infrastructure_network_infrastructure_link_stddev_pop_fields
  stddev_samp: infrastructure_network_infrastructure_link_stddev_samp_fields
  sum: infrastructure_network_infrastructure_link_sum_fields
  var_pop: infrastructure_network_infrastructure_link_var_pop_fields
  var_samp: infrastructure_network_infrastructure_link_var_samp_fields
  variance: infrastructure_network_infrastructure_link_variance_fields
}

"aggregate avg on columns"
type infrastructure_network_infrastructure_link_avg_fields {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: Float
}

"aggregate max on columns"
type infrastructure_network_infrastructure_link_max_fields {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: float8
  external_link_id: String
  "The ID of the infrastructure link."
  infrastructure_link_id: uuid
}

"aggregate min on columns"
type infrastructure_network_infrastructure_link_min_fields {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: float8
  external_link_id: String
  "The ID of the infrastructure link."
  infrastructure_link_id: uuid
}

"response of any mutation on the table \"infrastructure_network.infrastructure_link\""
type infrastructure_network_infrastructure_link_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [infrastructure_network_infrastructure_link!]!
}

"aggregate stddev on columns"
type infrastructure_network_infrastructure_link_stddev_fields {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: Float
}

"aggregate stddev_pop on columns"
type infrastructure_network_infrastructure_link_stddev_pop_fields {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: Float
}

"aggregate stddev_samp on columns"
type infrastructure_network_infrastructure_link_stddev_samp_fields {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: Float
}

"aggregate sum on columns"
type infrastructure_network_infrastructure_link_sum_fields {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: float8
}

"aggregate var_pop on columns"
type infrastructure_network_infrastructure_link_var_pop_fields {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: Float
}

"aggregate var_samp on columns"
type infrastructure_network_infrastructure_link_var_samp_fields {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: Float
}

"aggregate variance on columns"
type infrastructure_network_infrastructure_link_variance_fields {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: Float
}

"Which infrastructure links are safely traversed by which vehicle submodes?"
type infrastructure_network_vehicle_submode_on_infrastructure_link {
  "An object relationship"
  infrastructure_link: infrastructure_network_infrastructure_link!
  "The infrastructure link that can be safely traversed by the vehicle submode."
  infrastructure_link_id: uuid!
  "An object relationship"
  vehicleSubmodeByVehicleSubmode: reusable_components_vehicle_submode!
  "The vehicle submode that can safely traverse the infrastructure link."
  vehicle_submode: reusable_components_vehicle_submode_enum!
}

"aggregated selection of \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
type infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate {
  aggregate: infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate_fields
  nodes: [infrastructure_network_vehicle_submode_on_infrastructure_link!]!
}

"aggregate fields of \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
type infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate_fields {
  count(columns: [infrastructure_network_vehicle_submode_on_infrastructure_link_select_column!], distinct: Boolean): Int!
  max: infrastructure_network_vehicle_submode_on_infrastructure_link_max_fields
  min: infrastructure_network_vehicle_submode_on_infrastructure_link_min_fields
}

"aggregate max on columns"
type infrastructure_network_vehicle_submode_on_infrastructure_link_max_fields {
  "The infrastructure link that can be safely traversed by the vehicle submode."
  infrastructure_link_id: uuid
}

"aggregate min on columns"
type infrastructure_network_vehicle_submode_on_infrastructure_link_min_fields {
  "The infrastructure link that can be safely traversed by the vehicle submode."
  infrastructure_link_id: uuid
}

"response of any mutation on the table \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
type infrastructure_network_vehicle_submode_on_infrastructure_link_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [infrastructure_network_vehicle_submode_on_infrastructure_link!]!
}

"The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813"
type journey_pattern_journey_pattern {
  "The ID of the journey pattern."
  journey_pattern_id: uuid!
  journey_pattern_refs(
    "distinct select on columns"
    distinct_on: [timetables_journey_pattern_journey_pattern_ref_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_journey_pattern_journey_pattern_ref_order_by!],
    "filter the rows returned"
    where: timetables_journey_pattern_journey_pattern_ref_bool_exp
  ): [timetables_journey_pattern_journey_pattern_ref!]!
  journey_pattern_refs_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_journey_pattern_journey_pattern_ref_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_journey_pattern_journey_pattern_ref_order_by!],
    "filter the rows returned"
    where: timetables_journey_pattern_journey_pattern_ref_bool_exp
  ): timetables_journey_pattern_journey_pattern_ref_aggregate!
  "An object relationship"
  journey_pattern_route: route_route
  journey_pattern_vehicle_services(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_journey_patterns_in_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_journey_patterns_in_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp
  ): [timetables_vehicle_service_journey_patterns_in_vehicle_service!]!
  journey_pattern_vehicle_services_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_journey_patterns_in_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_journey_patterns_in_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp
  ): timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate!
  "The ID of the route the journey pattern is on."
  on_route_id: uuid!
  "An array relationship"
  scheduled_stop_point_in_journey_patterns(
    "distinct select on columns"
    distinct_on: [journey_pattern_scheduled_stop_point_in_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_scheduled_stop_point_in_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  ): [journey_pattern_scheduled_stop_point_in_journey_pattern!]!
  "An aggregate relationship"
  scheduled_stop_point_in_journey_patterns_aggregate(
    "distinct select on columns"
    distinct_on: [journey_pattern_scheduled_stop_point_in_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_scheduled_stop_point_in_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  ): journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate!
}

"aggregated selection of \"journey_pattern.journey_pattern\""
type journey_pattern_journey_pattern_aggregate {
  aggregate: journey_pattern_journey_pattern_aggregate_fields
  nodes: [journey_pattern_journey_pattern!]!
}

"aggregate fields of \"journey_pattern.journey_pattern\""
type journey_pattern_journey_pattern_aggregate_fields {
  count(columns: [journey_pattern_journey_pattern_select_column!], distinct: Boolean): Int!
  max: journey_pattern_journey_pattern_max_fields
  min: journey_pattern_journey_pattern_min_fields
}

"aggregate max on columns"
type journey_pattern_journey_pattern_max_fields {
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  "The ID of the route the journey pattern is on."
  on_route_id: uuid
}

"aggregate min on columns"
type journey_pattern_journey_pattern_min_fields {
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  "The ID of the route the journey pattern is on."
  on_route_id: uuid
}

"response of any mutation on the table \"journey_pattern.journey_pattern\""
type journey_pattern_journey_pattern_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [journey_pattern_journey_pattern!]!
}

"The scheduled stop points that form the journey pattern, in order: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 . For HSL, all timing points are stops, hence journey pattern instead of service pattern."
type journey_pattern_scheduled_stop_point_in_journey_pattern {
  "Is adding loading time to this scheduled stop point in the journey pattern allowed?"
  is_loading_time_allowed: Boolean!
  "Is this stop point passing time regulated so that it cannot be passed before scheduled time?"
  is_regulated_timing_point: Boolean!
  "Is this scheduled stop point used as a timing point in the journey pattern?"
  is_used_as_timing_point: Boolean!
  "Is this scheduled stop point a via point?"
  is_via_point: Boolean!
  "An object relationship"
  journey_pattern: journey_pattern_journey_pattern!
  "The ID of the journey pattern."
  journey_pattern_id: uuid!
  scheduled_stop_point_label: String!
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Int!
  "An array relationship"
  scheduled_stop_points(
    "distinct select on columns"
    distinct_on: [service_pattern_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): [service_pattern_scheduled_stop_point!]!
  "An aggregate relationship"
  scheduled_stop_points_aggregate(
    "distinct select on columns"
    distinct_on: [service_pattern_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): service_pattern_scheduled_stop_point_aggregate!
  via_point_name_i18n(
    "JSON select path"
    path: String
  ): jsonb
  via_point_short_name_i18n(
    "JSON select path"
    path: String
  ): jsonb
}

"aggregated selection of \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
type journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate {
  aggregate: journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_fields
  nodes: [journey_pattern_scheduled_stop_point_in_journey_pattern!]!
}

"aggregate fields of \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
type journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_fields {
  avg: journey_pattern_scheduled_stop_point_in_journey_pattern_avg_fields
  count(columns: [journey_pattern_scheduled_stop_point_in_journey_pattern_select_column!], distinct: Boolean): Int!
  max: journey_pattern_scheduled_stop_point_in_journey_pattern_max_fields
  min: journey_pattern_scheduled_stop_point_in_journey_pattern_min_fields
  stddev: journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_fields
  stddev_pop: journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_pop_fields
  stddev_samp: journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_samp_fields
  sum: journey_pattern_scheduled_stop_point_in_journey_pattern_sum_fields
  var_pop: journey_pattern_scheduled_stop_point_in_journey_pattern_var_pop_fields
  var_samp: journey_pattern_scheduled_stop_point_in_journey_pattern_var_samp_fields
  variance: journey_pattern_scheduled_stop_point_in_journey_pattern_variance_fields
}

"aggregate avg on columns"
type journey_pattern_scheduled_stop_point_in_journey_pattern_avg_fields {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Float
}

"aggregate max on columns"
type journey_pattern_scheduled_stop_point_in_journey_pattern_max_fields {
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  scheduled_stop_point_label: String
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Int
}

"aggregate min on columns"
type journey_pattern_scheduled_stop_point_in_journey_pattern_min_fields {
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  scheduled_stop_point_label: String
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Int
}

"response of any mutation on the table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
type journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [journey_pattern_scheduled_stop_point_in_journey_pattern!]!
}

"aggregate stddev on columns"
type journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_fields {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Float
}

"aggregate stddev_pop on columns"
type journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_pop_fields {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Float
}

"aggregate stddev_samp on columns"
type journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_samp_fields {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Float
}

"aggregate sum on columns"
type journey_pattern_scheduled_stop_point_in_journey_pattern_sum_fields {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Int
}

"aggregate var_pop on columns"
type journey_pattern_scheduled_stop_point_in_journey_pattern_var_pop_fields {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Float
}

"aggregate var_samp on columns"
type journey_pattern_scheduled_stop_point_in_journey_pattern_var_samp_fields {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Float
}

"aggregate variance on columns"
type journey_pattern_scheduled_stop_point_in_journey_pattern_variance_fields {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Float
}

"mutation root"
type mutation_root {
  combineTimetables(arg1: CombineTimetablesInput!): CombineTimetablesOutput
  "delete data from the table: \"hsl_route.legacy_hsl_municipality_code\""
  delete_hsl_route_legacy_hsl_municipality_code(
    "filter the rows which have to be deleted"
    where: hsl_route_legacy_hsl_municipality_code_bool_exp!
  ): hsl_route_legacy_hsl_municipality_code_mutation_response
  "delete single row from the table: \"hsl_route.legacy_hsl_municipality_code\""
  delete_hsl_route_legacy_hsl_municipality_code_by_pk(hsl_municipality: String!): hsl_route_legacy_hsl_municipality_code
  "delete data from the table: \"hsl_route.transport_target\""
  delete_hsl_route_transport_target(
    "filter the rows which have to be deleted"
    where: hsl_route_transport_target_bool_exp!
  ): hsl_route_transport_target_mutation_response
  "delete single row from the table: \"hsl_route.transport_target\""
  delete_hsl_route_transport_target_by_pk(transport_target: String!): hsl_route_transport_target
  "delete data from the table: \"infrastructure_network.direction\""
  delete_infrastructure_network_direction(
    "filter the rows which have to be deleted"
    where: infrastructure_network_direction_bool_exp!
  ): infrastructure_network_direction_mutation_response
  "delete single row from the table: \"infrastructure_network.direction\""
  delete_infrastructure_network_direction_by_pk(value: String!): infrastructure_network_direction
  "delete data from the table: \"infrastructure_network.external_source\""
  delete_infrastructure_network_external_source(
    "filter the rows which have to be deleted"
    where: infrastructure_network_external_source_bool_exp!
  ): infrastructure_network_external_source_mutation_response
  "delete single row from the table: \"infrastructure_network.external_source\""
  delete_infrastructure_network_external_source_by_pk(value: String!): infrastructure_network_external_source
  "delete data from the table: \"infrastructure_network.infrastructure_link\""
  delete_infrastructure_network_infrastructure_link(
    "filter the rows which have to be deleted"
    where: infrastructure_network_infrastructure_link_bool_exp!
  ): infrastructure_network_infrastructure_link_mutation_response
  "delete single row from the table: \"infrastructure_network.infrastructure_link\""
  delete_infrastructure_network_infrastructure_link_by_pk(
    "The ID of the infrastructure link."
    infrastructure_link_id: uuid!
  ): infrastructure_network_infrastructure_link
  "delete data from the table: \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
  delete_infrastructure_network_vehicle_submode_on_infrastructure_link(
    "filter the rows which have to be deleted"
    where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp!
  ): infrastructure_network_vehicle_submode_on_infrastructure_link_mutation_response
  "delete single row from the table: \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
  delete_infrastructure_network_vehicle_submode_on_infrastructure_link_by_pk(
    "The infrastructure link that can be safely traversed by the vehicle submode."
    infrastructure_link_id: uuid!,
    "The vehicle submode that can safely traverse the infrastructure link."
    vehicle_submode: reusable_components_vehicle_submode_enum!
  ): infrastructure_network_vehicle_submode_on_infrastructure_link
  "delete data from the table: \"journey_pattern.journey_pattern\""
  delete_journey_pattern_journey_pattern(
    "filter the rows which have to be deleted"
    where: journey_pattern_journey_pattern_bool_exp!
  ): journey_pattern_journey_pattern_mutation_response
  "delete single row from the table: \"journey_pattern.journey_pattern\""
  delete_journey_pattern_journey_pattern_by_pk(
    "The ID of the journey pattern."
    journey_pattern_id: uuid!
  ): journey_pattern_journey_pattern
  "delete data from the table: \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
  delete_journey_pattern_scheduled_stop_point_in_journey_pattern(
    "filter the rows which have to be deleted"
    where: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp!
  ): journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response
  "delete single row from the table: \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
  delete_journey_pattern_scheduled_stop_point_in_journey_pattern_by_pk(
    "The ID of the journey pattern."
    journey_pattern_id: uuid!,
    "The order of the scheduled stop point within the journey pattern."
    scheduled_stop_point_sequence: Int!
  ): journey_pattern_scheduled_stop_point_in_journey_pattern
  "delete data from the table: \"reusable_components.vehicle_mode\""
  delete_reusable_components_vehicle_mode(
    "filter the rows which have to be deleted"
    where: reusable_components_vehicle_mode_bool_exp!
  ): reusable_components_vehicle_mode_mutation_response
  "delete single row from the table: \"reusable_components.vehicle_mode\""
  delete_reusable_components_vehicle_mode_by_pk(
    "The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
    vehicle_mode: String!
  ): reusable_components_vehicle_mode
  "delete data from the table: \"reusable_components.vehicle_submode\""
  delete_reusable_components_vehicle_submode(
    "filter the rows which have to be deleted"
    where: reusable_components_vehicle_submode_bool_exp!
  ): reusable_components_vehicle_submode_mutation_response
  "delete single row from the table: \"reusable_components.vehicle_submode\""
  delete_reusable_components_vehicle_submode_by_pk(
    "The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse"
    vehicle_submode: String!
  ): reusable_components_vehicle_submode
  "delete data from the table: \"route.direction\""
  delete_route_direction(
    "filter the rows which have to be deleted"
    where: route_direction_bool_exp!
  ): route_direction_mutation_response
  "delete single row from the table: \"route.direction\""
  delete_route_direction_by_pk(
    "The name of the route direction."
    direction: String!
  ): route_direction
  "delete data from the table: \"route.infrastructure_link_along_route\""
  delete_route_infrastructure_link_along_route(
    "filter the rows which have to be deleted"
    where: route_infrastructure_link_along_route_bool_exp!
  ): route_infrastructure_link_along_route_mutation_response
  "delete single row from the table: \"route.infrastructure_link_along_route\""
  delete_route_infrastructure_link_along_route_by_pk(
    "The order of the infrastructure link within the journey pattern."
    infrastructure_link_sequence: Int!,
    "The ID of the route."
    route_id: uuid!
  ): route_infrastructure_link_along_route
  "delete data from the table: \"route.line\""
  delete_route_line(
    "filter the rows which have to be deleted"
    where: route_line_bool_exp!
  ): route_line_mutation_response
  "delete single row from the table: \"route.line\""
  delete_route_line_by_pk(
    "The ID of the line."
    line_id: uuid!
  ): route_line
  "delete data from the table: \"route.route\""
  delete_route_route(
    "filter the rows which have to be deleted"
    where: route_route_bool_exp!
  ): route_route_mutation_response
  "delete single row from the table: \"route.route\""
  delete_route_route_by_pk(
    "The ID of the route."
    route_id: uuid!
  ): route_route
  "delete data from the table: \"route.type_of_line\""
  delete_route_type_of_line(
    "filter the rows which have to be deleted"
    where: route_type_of_line_bool_exp!
  ): route_type_of_line_mutation_response
  "delete single row from the table: \"route.type_of_line\""
  delete_route_type_of_line_by_pk(
    "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
    type_of_line: String!
  ): route_type_of_line
  "delete data from the table: \"service_pattern.distance_between_stops_calculation\""
  delete_service_pattern_distance_between_stops_calculation(
    "filter the rows which have to be deleted"
    where: service_pattern_distance_between_stops_calculation_bool_exp!
  ): service_pattern_distance_between_stops_calculation_mutation_response
  "delete single row from the table: \"service_pattern.distance_between_stops_calculation\""
  delete_service_pattern_distance_between_stops_calculation_by_pk(
    "The ID of the journey pattern."
    journey_pattern_id: uuid!,
    "The observation date for the state of the route related to the journey pattern."
    observation_date: date!,
    "The priority of the route related to the journey pattern."
    route_priority: Int!,
    "The sequence number of the stop interval within the journey pattern."
    stop_interval_sequence: Int!
  ): service_pattern_distance_between_stops_calculation
  "delete data from the table: \"service_pattern.scheduled_stop_point\""
  delete_service_pattern_scheduled_stop_point(
    "filter the rows which have to be deleted"
    where: service_pattern_scheduled_stop_point_bool_exp!
  ): service_pattern_scheduled_stop_point_mutation_response
  "delete single row from the table: \"service_pattern.scheduled_stop_point\""
  delete_service_pattern_scheduled_stop_point_by_pk(
    "The ID of the scheduled stop point."
    scheduled_stop_point_id: uuid!
  ): service_pattern_scheduled_stop_point
  "delete data from the table: \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
  delete_service_pattern_vehicle_mode_on_scheduled_stop_point(
    "filter the rows which have to be deleted"
    where: service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp!
  ): service_pattern_vehicle_mode_on_scheduled_stop_point_mutation_response
  "delete single row from the table: \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
  delete_service_pattern_vehicle_mode_on_scheduled_stop_point_by_pk(
    "The scheduled stop point that is serviced by the vehicle mode."
    scheduled_stop_point_id: uuid!,
    "The vehicle mode servicing the scheduled stop point."
    vehicle_mode: reusable_components_vehicle_mode_enum!
  ): service_pattern_vehicle_mode_on_scheduled_stop_point
  "delete data from the table: \"timing_pattern.timing_place\""
  delete_timing_pattern_timing_place(
    "filter the rows which have to be deleted"
    where: timing_pattern_timing_place_bool_exp!
  ): timing_pattern_timing_place_mutation_response
  "delete single row from the table: \"timing_pattern.timing_place\""
  delete_timing_pattern_timing_place_by_pk(timing_place_id: uuid!): timing_pattern_timing_place
  "insert data into the table: \"hsl_route.legacy_hsl_municipality_code\""
  insert_hsl_route_legacy_hsl_municipality_code(
    "the rows to be inserted"
    objects: [hsl_route_legacy_hsl_municipality_code_insert_input!]!,
    "upsert condition"
    on_conflict: hsl_route_legacy_hsl_municipality_code_on_conflict
  ): hsl_route_legacy_hsl_municipality_code_mutation_response
  "insert a single row into the table: \"hsl_route.legacy_hsl_municipality_code\""
  insert_hsl_route_legacy_hsl_municipality_code_one(
    "the row to be inserted"
    object: hsl_route_legacy_hsl_municipality_code_insert_input!,
    "upsert condition"
    on_conflict: hsl_route_legacy_hsl_municipality_code_on_conflict
  ): hsl_route_legacy_hsl_municipality_code
  "insert data into the table: \"hsl_route.transport_target\""
  insert_hsl_route_transport_target(
    "the rows to be inserted"
    objects: [hsl_route_transport_target_insert_input!]!,
    "upsert condition"
    on_conflict: hsl_route_transport_target_on_conflict
  ): hsl_route_transport_target_mutation_response
  "insert a single row into the table: \"hsl_route.transport_target\""
  insert_hsl_route_transport_target_one(
    "the row to be inserted"
    object: hsl_route_transport_target_insert_input!,
    "upsert condition"
    on_conflict: hsl_route_transport_target_on_conflict
  ): hsl_route_transport_target
  "insert data into the table: \"infrastructure_network.direction\""
  insert_infrastructure_network_direction(
    "the rows to be inserted"
    objects: [infrastructure_network_direction_insert_input!]!,
    "upsert condition"
    on_conflict: infrastructure_network_direction_on_conflict
  ): infrastructure_network_direction_mutation_response
  "insert a single row into the table: \"infrastructure_network.direction\""
  insert_infrastructure_network_direction_one(
    "the row to be inserted"
    object: infrastructure_network_direction_insert_input!,
    "upsert condition"
    on_conflict: infrastructure_network_direction_on_conflict
  ): infrastructure_network_direction
  "insert data into the table: \"infrastructure_network.external_source\""
  insert_infrastructure_network_external_source(
    "the rows to be inserted"
    objects: [infrastructure_network_external_source_insert_input!]!,
    "upsert condition"
    on_conflict: infrastructure_network_external_source_on_conflict
  ): infrastructure_network_external_source_mutation_response
  "insert a single row into the table: \"infrastructure_network.external_source\""
  insert_infrastructure_network_external_source_one(
    "the row to be inserted"
    object: infrastructure_network_external_source_insert_input!,
    "upsert condition"
    on_conflict: infrastructure_network_external_source_on_conflict
  ): infrastructure_network_external_source
  "insert data into the table: \"infrastructure_network.infrastructure_link\""
  insert_infrastructure_network_infrastructure_link(
    "the rows to be inserted"
    objects: [infrastructure_network_infrastructure_link_insert_input!]!,
    "upsert condition"
    on_conflict: infrastructure_network_infrastructure_link_on_conflict
  ): infrastructure_network_infrastructure_link_mutation_response
  "insert a single row into the table: \"infrastructure_network.infrastructure_link\""
  insert_infrastructure_network_infrastructure_link_one(
    "the row to be inserted"
    object: infrastructure_network_infrastructure_link_insert_input!,
    "upsert condition"
    on_conflict: infrastructure_network_infrastructure_link_on_conflict
  ): infrastructure_network_infrastructure_link
  "insert data into the table: \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
  insert_infrastructure_network_vehicle_submode_on_infrastructure_link(
    "the rows to be inserted"
    objects: [infrastructure_network_vehicle_submode_on_infrastructure_link_insert_input!]!,
    "upsert condition"
    on_conflict: infrastructure_network_vehicle_submode_on_infrastructure_link_on_conflict
  ): infrastructure_network_vehicle_submode_on_infrastructure_link_mutation_response
  "insert a single row into the table: \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
  insert_infrastructure_network_vehicle_submode_on_infrastructure_link_one(
    "the row to be inserted"
    object: infrastructure_network_vehicle_submode_on_infrastructure_link_insert_input!,
    "upsert condition"
    on_conflict: infrastructure_network_vehicle_submode_on_infrastructure_link_on_conflict
  ): infrastructure_network_vehicle_submode_on_infrastructure_link
  "insert data into the table: \"journey_pattern.journey_pattern\""
  insert_journey_pattern_journey_pattern(
    "the rows to be inserted"
    objects: [journey_pattern_journey_pattern_insert_input!]!,
    "upsert condition"
    on_conflict: journey_pattern_journey_pattern_on_conflict
  ): journey_pattern_journey_pattern_mutation_response
  "insert a single row into the table: \"journey_pattern.journey_pattern\""
  insert_journey_pattern_journey_pattern_one(
    "the row to be inserted"
    object: journey_pattern_journey_pattern_insert_input!,
    "upsert condition"
    on_conflict: journey_pattern_journey_pattern_on_conflict
  ): journey_pattern_journey_pattern
  "insert data into the table: \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
  insert_journey_pattern_scheduled_stop_point_in_journey_pattern(
    "the rows to be inserted"
    objects: [journey_pattern_scheduled_stop_point_in_journey_pattern_insert_input!]!,
    "upsert condition"
    on_conflict: journey_pattern_scheduled_stop_point_in_journey_pattern_on_conflict
  ): journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response
  "insert a single row into the table: \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
  insert_journey_pattern_scheduled_stop_point_in_journey_pattern_one(
    "the row to be inserted"
    object: journey_pattern_scheduled_stop_point_in_journey_pattern_insert_input!,
    "upsert condition"
    on_conflict: journey_pattern_scheduled_stop_point_in_journey_pattern_on_conflict
  ): journey_pattern_scheduled_stop_point_in_journey_pattern
  "insert data into the table: \"reusable_components.vehicle_mode\""
  insert_reusable_components_vehicle_mode(
    "the rows to be inserted"
    objects: [reusable_components_vehicle_mode_insert_input!]!,
    "upsert condition"
    on_conflict: reusable_components_vehicle_mode_on_conflict
  ): reusable_components_vehicle_mode_mutation_response
  "insert a single row into the table: \"reusable_components.vehicle_mode\""
  insert_reusable_components_vehicle_mode_one(
    "the row to be inserted"
    object: reusable_components_vehicle_mode_insert_input!,
    "upsert condition"
    on_conflict: reusable_components_vehicle_mode_on_conflict
  ): reusable_components_vehicle_mode
  "insert data into the table: \"reusable_components.vehicle_submode\""
  insert_reusable_components_vehicle_submode(
    "the rows to be inserted"
    objects: [reusable_components_vehicle_submode_insert_input!]!,
    "upsert condition"
    on_conflict: reusable_components_vehicle_submode_on_conflict
  ): reusable_components_vehicle_submode_mutation_response
  "insert a single row into the table: \"reusable_components.vehicle_submode\""
  insert_reusable_components_vehicle_submode_one(
    "the row to be inserted"
    object: reusable_components_vehicle_submode_insert_input!,
    "upsert condition"
    on_conflict: reusable_components_vehicle_submode_on_conflict
  ): reusable_components_vehicle_submode
  "insert data into the table: \"route.direction\""
  insert_route_direction(
    "the rows to be inserted"
    objects: [route_direction_insert_input!]!,
    "upsert condition"
    on_conflict: route_direction_on_conflict
  ): route_direction_mutation_response
  "insert a single row into the table: \"route.direction\""
  insert_route_direction_one(
    "the row to be inserted"
    object: route_direction_insert_input!,
    "upsert condition"
    on_conflict: route_direction_on_conflict
  ): route_direction
  "insert data into the table: \"route.infrastructure_link_along_route\""
  insert_route_infrastructure_link_along_route(
    "the rows to be inserted"
    objects: [route_infrastructure_link_along_route_insert_input!]!,
    "upsert condition"
    on_conflict: route_infrastructure_link_along_route_on_conflict
  ): route_infrastructure_link_along_route_mutation_response
  "insert a single row into the table: \"route.infrastructure_link_along_route\""
  insert_route_infrastructure_link_along_route_one(
    "the row to be inserted"
    object: route_infrastructure_link_along_route_insert_input!,
    "upsert condition"
    on_conflict: route_infrastructure_link_along_route_on_conflict
  ): route_infrastructure_link_along_route
  "insert data into the table: \"route.line\""
  insert_route_line(
    "the rows to be inserted"
    objects: [route_line_insert_input!]!,
    "upsert condition"
    on_conflict: route_line_on_conflict
  ): route_line_mutation_response
  "insert a single row into the table: \"route.line\""
  insert_route_line_one(
    "the row to be inserted"
    object: route_line_insert_input!,
    "upsert condition"
    on_conflict: route_line_on_conflict
  ): route_line
  "insert data into the table: \"route.route\""
  insert_route_route(
    "the rows to be inserted"
    objects: [route_route_insert_input!]!,
    "upsert condition"
    on_conflict: route_route_on_conflict
  ): route_route_mutation_response
  "insert a single row into the table: \"route.route\""
  insert_route_route_one(
    "the row to be inserted"
    object: route_route_insert_input!,
    "upsert condition"
    on_conflict: route_route_on_conflict
  ): route_route
  "insert data into the table: \"route.type_of_line\""
  insert_route_type_of_line(
    "the rows to be inserted"
    objects: [route_type_of_line_insert_input!]!,
    "upsert condition"
    on_conflict: route_type_of_line_on_conflict
  ): route_type_of_line_mutation_response
  "insert a single row into the table: \"route.type_of_line\""
  insert_route_type_of_line_one(
    "the row to be inserted"
    object: route_type_of_line_insert_input!,
    "upsert condition"
    on_conflict: route_type_of_line_on_conflict
  ): route_type_of_line
  "insert data into the table: \"service_pattern.distance_between_stops_calculation\""
  insert_service_pattern_distance_between_stops_calculation(
    "the rows to be inserted"
    objects: [service_pattern_distance_between_stops_calculation_insert_input!]!,
    "upsert condition"
    on_conflict: service_pattern_distance_between_stops_calculation_on_conflict
  ): service_pattern_distance_between_stops_calculation_mutation_response
  "insert a single row into the table: \"service_pattern.distance_between_stops_calculation\""
  insert_service_pattern_distance_between_stops_calculation_one(
    "the row to be inserted"
    object: service_pattern_distance_between_stops_calculation_insert_input!,
    "upsert condition"
    on_conflict: service_pattern_distance_between_stops_calculation_on_conflict
  ): service_pattern_distance_between_stops_calculation
  "insert data into the table: \"service_pattern.scheduled_stop_point\""
  insert_service_pattern_scheduled_stop_point(
    "the rows to be inserted"
    objects: [service_pattern_scheduled_stop_point_insert_input!]!,
    "upsert condition"
    on_conflict: service_pattern_scheduled_stop_point_on_conflict
  ): service_pattern_scheduled_stop_point_mutation_response
  "insert a single row into the table: \"service_pattern.scheduled_stop_point\""
  insert_service_pattern_scheduled_stop_point_one(
    "the row to be inserted"
    object: service_pattern_scheduled_stop_point_insert_input!,
    "upsert condition"
    on_conflict: service_pattern_scheduled_stop_point_on_conflict
  ): service_pattern_scheduled_stop_point
  "insert data into the table: \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
  insert_service_pattern_vehicle_mode_on_scheduled_stop_point(
    "the rows to be inserted"
    objects: [service_pattern_vehicle_mode_on_scheduled_stop_point_insert_input!]!,
    "upsert condition"
    on_conflict: service_pattern_vehicle_mode_on_scheduled_stop_point_on_conflict
  ): service_pattern_vehicle_mode_on_scheduled_stop_point_mutation_response
  "insert a single row into the table: \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
  insert_service_pattern_vehicle_mode_on_scheduled_stop_point_one(
    "the row to be inserted"
    object: service_pattern_vehicle_mode_on_scheduled_stop_point_insert_input!,
    "upsert condition"
    on_conflict: service_pattern_vehicle_mode_on_scheduled_stop_point_on_conflict
  ): service_pattern_vehicle_mode_on_scheduled_stop_point
  "insert data into the table: \"timing_pattern.timing_place\""
  insert_timing_pattern_timing_place(
    "the rows to be inserted"
    objects: [timing_pattern_timing_place_insert_input!]!,
    "upsert condition"
    on_conflict: timing_pattern_timing_place_on_conflict
  ): timing_pattern_timing_place_mutation_response
  "insert a single row into the table: \"timing_pattern.timing_place\""
  insert_timing_pattern_timing_place_one(
    "the row to be inserted"
    object: timing_pattern_timing_place_insert_input!,
    "upsert condition"
    on_conflict: timing_pattern_timing_place_on_conflict
  ): timing_pattern_timing_place
  replaceTimetables(arg1: ReplaceTimetablesInput!): ReplaceTimetablesOutput
  timetables: timetables_timetables_mutation_frontend
  "update data of the table: \"hsl_route.legacy_hsl_municipality_code\""
  update_hsl_route_legacy_hsl_municipality_code(
    "increments the numeric columns with given value of the filtered values"
    _inc: hsl_route_legacy_hsl_municipality_code_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: hsl_route_legacy_hsl_municipality_code_set_input,
    "filter the rows which have to be updated"
    where: hsl_route_legacy_hsl_municipality_code_bool_exp!
  ): hsl_route_legacy_hsl_municipality_code_mutation_response
  "update single row of the table: \"hsl_route.legacy_hsl_municipality_code\""
  update_hsl_route_legacy_hsl_municipality_code_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: hsl_route_legacy_hsl_municipality_code_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: hsl_route_legacy_hsl_municipality_code_set_input,
    pk_columns: hsl_route_legacy_hsl_municipality_code_pk_columns_input!
  ): hsl_route_legacy_hsl_municipality_code
  "update multiples rows of table: \"hsl_route.legacy_hsl_municipality_code\""
  update_hsl_route_legacy_hsl_municipality_code_many(
    "updates to execute, in order"
    updates: [hsl_route_legacy_hsl_municipality_code_updates!]!
  ): [hsl_route_legacy_hsl_municipality_code_mutation_response]
  "update data of the table: \"hsl_route.transport_target\""
  update_hsl_route_transport_target(
    "sets the columns of the filtered rows to the given values"
    _set: hsl_route_transport_target_set_input,
    "filter the rows which have to be updated"
    where: hsl_route_transport_target_bool_exp!
  ): hsl_route_transport_target_mutation_response
  "update single row of the table: \"hsl_route.transport_target\""
  update_hsl_route_transport_target_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: hsl_route_transport_target_set_input,
    pk_columns: hsl_route_transport_target_pk_columns_input!
  ): hsl_route_transport_target
  "update multiples rows of table: \"hsl_route.transport_target\""
  update_hsl_route_transport_target_many(
    "updates to execute, in order"
    updates: [hsl_route_transport_target_updates!]!
  ): [hsl_route_transport_target_mutation_response]
  "update data of the table: \"infrastructure_network.direction\""
  update_infrastructure_network_direction(
    "sets the columns of the filtered rows to the given values"
    _set: infrastructure_network_direction_set_input,
    "filter the rows which have to be updated"
    where: infrastructure_network_direction_bool_exp!
  ): infrastructure_network_direction_mutation_response
  "update single row of the table: \"infrastructure_network.direction\""
  update_infrastructure_network_direction_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: infrastructure_network_direction_set_input,
    pk_columns: infrastructure_network_direction_pk_columns_input!
  ): infrastructure_network_direction
  "update multiples rows of table: \"infrastructure_network.direction\""
  update_infrastructure_network_direction_many(
    "updates to execute, in order"
    updates: [infrastructure_network_direction_updates!]!
  ): [infrastructure_network_direction_mutation_response]
  "update data of the table: \"infrastructure_network.external_source\""
  update_infrastructure_network_external_source(
    "sets the columns of the filtered rows to the given values"
    _set: infrastructure_network_external_source_set_input,
    "filter the rows which have to be updated"
    where: infrastructure_network_external_source_bool_exp!
  ): infrastructure_network_external_source_mutation_response
  "update single row of the table: \"infrastructure_network.external_source\""
  update_infrastructure_network_external_source_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: infrastructure_network_external_source_set_input,
    pk_columns: infrastructure_network_external_source_pk_columns_input!
  ): infrastructure_network_external_source
  "update multiples rows of table: \"infrastructure_network.external_source\""
  update_infrastructure_network_external_source_many(
    "updates to execute, in order"
    updates: [infrastructure_network_external_source_updates!]!
  ): [infrastructure_network_external_source_mutation_response]
  "update data of the table: \"infrastructure_network.infrastructure_link\""
  update_infrastructure_network_infrastructure_link(
    "increments the numeric columns with given value of the filtered values"
    _inc: infrastructure_network_infrastructure_link_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: infrastructure_network_infrastructure_link_set_input,
    "filter the rows which have to be updated"
    where: infrastructure_network_infrastructure_link_bool_exp!
  ): infrastructure_network_infrastructure_link_mutation_response
  "update single row of the table: \"infrastructure_network.infrastructure_link\""
  update_infrastructure_network_infrastructure_link_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: infrastructure_network_infrastructure_link_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: infrastructure_network_infrastructure_link_set_input,
    pk_columns: infrastructure_network_infrastructure_link_pk_columns_input!
  ): infrastructure_network_infrastructure_link
  "update multiples rows of table: \"infrastructure_network.infrastructure_link\""
  update_infrastructure_network_infrastructure_link_many(
    "updates to execute, in order"
    updates: [infrastructure_network_infrastructure_link_updates!]!
  ): [infrastructure_network_infrastructure_link_mutation_response]
  "update data of the table: \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
  update_infrastructure_network_vehicle_submode_on_infrastructure_link(
    "sets the columns of the filtered rows to the given values"
    _set: infrastructure_network_vehicle_submode_on_infrastructure_link_set_input,
    "filter the rows which have to be updated"
    where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp!
  ): infrastructure_network_vehicle_submode_on_infrastructure_link_mutation_response
  "update single row of the table: \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
  update_infrastructure_network_vehicle_submode_on_infrastructure_link_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: infrastructure_network_vehicle_submode_on_infrastructure_link_set_input,
    pk_columns: infrastructure_network_vehicle_submode_on_infrastructure_link_pk_columns_input!
  ): infrastructure_network_vehicle_submode_on_infrastructure_link
  "update multiples rows of table: \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
  update_infrastructure_network_vehicle_submode_on_infrastructure_link_many(
    "updates to execute, in order"
    updates: [infrastructure_network_vehicle_submode_on_infrastructure_link_updates!]!
  ): [infrastructure_network_vehicle_submode_on_infrastructure_link_mutation_response]
  "update data of the table: \"journey_pattern.journey_pattern\""
  update_journey_pattern_journey_pattern(
    "sets the columns of the filtered rows to the given values"
    _set: journey_pattern_journey_pattern_set_input,
    "filter the rows which have to be updated"
    where: journey_pattern_journey_pattern_bool_exp!
  ): journey_pattern_journey_pattern_mutation_response
  "update single row of the table: \"journey_pattern.journey_pattern\""
  update_journey_pattern_journey_pattern_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: journey_pattern_journey_pattern_set_input,
    pk_columns: journey_pattern_journey_pattern_pk_columns_input!
  ): journey_pattern_journey_pattern
  "update multiples rows of table: \"journey_pattern.journey_pattern\""
  update_journey_pattern_journey_pattern_many(
    "updates to execute, in order"
    updates: [journey_pattern_journey_pattern_updates!]!
  ): [journey_pattern_journey_pattern_mutation_response]
  "update data of the table: \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
  update_journey_pattern_scheduled_stop_point_in_journey_pattern(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: journey_pattern_scheduled_stop_point_in_journey_pattern_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: journey_pattern_scheduled_stop_point_in_journey_pattern_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: journey_pattern_scheduled_stop_point_in_journey_pattern_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: journey_pattern_scheduled_stop_point_in_journey_pattern_delete_key_input,
    "increments the numeric columns with given value of the filtered values"
    _inc: journey_pattern_scheduled_stop_point_in_journey_pattern_inc_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: journey_pattern_scheduled_stop_point_in_journey_pattern_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: journey_pattern_scheduled_stop_point_in_journey_pattern_set_input,
    "filter the rows which have to be updated"
    where: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp!
  ): journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response
  "update single row of the table: \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
  update_journey_pattern_scheduled_stop_point_in_journey_pattern_by_pk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: journey_pattern_scheduled_stop_point_in_journey_pattern_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: journey_pattern_scheduled_stop_point_in_journey_pattern_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: journey_pattern_scheduled_stop_point_in_journey_pattern_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: journey_pattern_scheduled_stop_point_in_journey_pattern_delete_key_input,
    "increments the numeric columns with given value of the filtered values"
    _inc: journey_pattern_scheduled_stop_point_in_journey_pattern_inc_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: journey_pattern_scheduled_stop_point_in_journey_pattern_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: journey_pattern_scheduled_stop_point_in_journey_pattern_set_input,
    pk_columns: journey_pattern_scheduled_stop_point_in_journey_pattern_pk_columns_input!
  ): journey_pattern_scheduled_stop_point_in_journey_pattern
  "update multiples rows of table: \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
  update_journey_pattern_scheduled_stop_point_in_journey_pattern_many(
    "updates to execute, in order"
    updates: [journey_pattern_scheduled_stop_point_in_journey_pattern_updates!]!
  ): [journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response]
  "update data of the table: \"reusable_components.vehicle_mode\""
  update_reusable_components_vehicle_mode(
    "sets the columns of the filtered rows to the given values"
    _set: reusable_components_vehicle_mode_set_input,
    "filter the rows which have to be updated"
    where: reusable_components_vehicle_mode_bool_exp!
  ): reusable_components_vehicle_mode_mutation_response
  "update single row of the table: \"reusable_components.vehicle_mode\""
  update_reusable_components_vehicle_mode_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: reusable_components_vehicle_mode_set_input,
    pk_columns: reusable_components_vehicle_mode_pk_columns_input!
  ): reusable_components_vehicle_mode
  "update multiples rows of table: \"reusable_components.vehicle_mode\""
  update_reusable_components_vehicle_mode_many(
    "updates to execute, in order"
    updates: [reusable_components_vehicle_mode_updates!]!
  ): [reusable_components_vehicle_mode_mutation_response]
  "update data of the table: \"reusable_components.vehicle_submode\""
  update_reusable_components_vehicle_submode(
    "sets the columns of the filtered rows to the given values"
    _set: reusable_components_vehicle_submode_set_input,
    "filter the rows which have to be updated"
    where: reusable_components_vehicle_submode_bool_exp!
  ): reusable_components_vehicle_submode_mutation_response
  "update single row of the table: \"reusable_components.vehicle_submode\""
  update_reusable_components_vehicle_submode_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: reusable_components_vehicle_submode_set_input,
    pk_columns: reusable_components_vehicle_submode_pk_columns_input!
  ): reusable_components_vehicle_submode
  "update multiples rows of table: \"reusable_components.vehicle_submode\""
  update_reusable_components_vehicle_submode_many(
    "updates to execute, in order"
    updates: [reusable_components_vehicle_submode_updates!]!
  ): [reusable_components_vehicle_submode_mutation_response]
  "update data of the table: \"route.direction\""
  update_route_direction(
    "sets the columns of the filtered rows to the given values"
    _set: route_direction_set_input,
    "filter the rows which have to be updated"
    where: route_direction_bool_exp!
  ): route_direction_mutation_response
  "update single row of the table: \"route.direction\""
  update_route_direction_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: route_direction_set_input,
    pk_columns: route_direction_pk_columns_input!
  ): route_direction
  "update multiples rows of table: \"route.direction\""
  update_route_direction_many(
    "updates to execute, in order"
    updates: [route_direction_updates!]!
  ): [route_direction_mutation_response]
  "update data of the table: \"route.infrastructure_link_along_route\""
  update_route_infrastructure_link_along_route(
    "increments the numeric columns with given value of the filtered values"
    _inc: route_infrastructure_link_along_route_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: route_infrastructure_link_along_route_set_input,
    "filter the rows which have to be updated"
    where: route_infrastructure_link_along_route_bool_exp!
  ): route_infrastructure_link_along_route_mutation_response
  "update single row of the table: \"route.infrastructure_link_along_route\""
  update_route_infrastructure_link_along_route_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: route_infrastructure_link_along_route_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: route_infrastructure_link_along_route_set_input,
    pk_columns: route_infrastructure_link_along_route_pk_columns_input!
  ): route_infrastructure_link_along_route
  "update multiples rows of table: \"route.infrastructure_link_along_route\""
  update_route_infrastructure_link_along_route_many(
    "updates to execute, in order"
    updates: [route_infrastructure_link_along_route_updates!]!
  ): [route_infrastructure_link_along_route_mutation_response]
  "update data of the table: \"route.line\""
  update_route_line(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: route_line_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: route_line_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: route_line_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: route_line_delete_key_input,
    "increments the numeric columns with given value of the filtered values"
    _inc: route_line_inc_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: route_line_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: route_line_set_input,
    "filter the rows which have to be updated"
    where: route_line_bool_exp!
  ): route_line_mutation_response
  "update single row of the table: \"route.line\""
  update_route_line_by_pk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: route_line_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: route_line_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: route_line_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: route_line_delete_key_input,
    "increments the numeric columns with given value of the filtered values"
    _inc: route_line_inc_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: route_line_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: route_line_set_input,
    pk_columns: route_line_pk_columns_input!
  ): route_line
  "update multiples rows of table: \"route.line\""
  update_route_line_many(
    "updates to execute, in order"
    updates: [route_line_updates!]!
  ): [route_line_mutation_response]
  "update data of the table: \"route.route\""
  update_route_route(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: route_route_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: route_route_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: route_route_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: route_route_delete_key_input,
    "increments the numeric columns with given value of the filtered values"
    _inc: route_route_inc_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: route_route_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: route_route_set_input,
    "filter the rows which have to be updated"
    where: route_route_bool_exp!
  ): route_route_mutation_response
  "update single row of the table: \"route.route\""
  update_route_route_by_pk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: route_route_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: route_route_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: route_route_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: route_route_delete_key_input,
    "increments the numeric columns with given value of the filtered values"
    _inc: route_route_inc_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: route_route_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: route_route_set_input,
    pk_columns: route_route_pk_columns_input!
  ): route_route
  "update multiples rows of table: \"route.route\""
  update_route_route_many(
    "updates to execute, in order"
    updates: [route_route_updates!]!
  ): [route_route_mutation_response]
  "update data of the table: \"route.type_of_line\""
  update_route_type_of_line(
    "sets the columns of the filtered rows to the given values"
    _set: route_type_of_line_set_input,
    "filter the rows which have to be updated"
    where: route_type_of_line_bool_exp!
  ): route_type_of_line_mutation_response
  "update single row of the table: \"route.type_of_line\""
  update_route_type_of_line_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: route_type_of_line_set_input,
    pk_columns: route_type_of_line_pk_columns_input!
  ): route_type_of_line
  "update multiples rows of table: \"route.type_of_line\""
  update_route_type_of_line_many(
    "updates to execute, in order"
    updates: [route_type_of_line_updates!]!
  ): [route_type_of_line_mutation_response]
  "update data of the table: \"service_pattern.distance_between_stops_calculation\""
  update_service_pattern_distance_between_stops_calculation(
    "increments the numeric columns with given value of the filtered values"
    _inc: service_pattern_distance_between_stops_calculation_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: service_pattern_distance_between_stops_calculation_set_input,
    "filter the rows which have to be updated"
    where: service_pattern_distance_between_stops_calculation_bool_exp!
  ): service_pattern_distance_between_stops_calculation_mutation_response
  "update single row of the table: \"service_pattern.distance_between_stops_calculation\""
  update_service_pattern_distance_between_stops_calculation_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: service_pattern_distance_between_stops_calculation_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: service_pattern_distance_between_stops_calculation_set_input,
    pk_columns: service_pattern_distance_between_stops_calculation_pk_columns_input!
  ): service_pattern_distance_between_stops_calculation
  "update multiples rows of table: \"service_pattern.distance_between_stops_calculation\""
  update_service_pattern_distance_between_stops_calculation_many(
    "updates to execute, in order"
    updates: [service_pattern_distance_between_stops_calculation_updates!]!
  ): [service_pattern_distance_between_stops_calculation_mutation_response]
  "update data of the table: \"service_pattern.scheduled_stop_point\""
  update_service_pattern_scheduled_stop_point(
    "increments the numeric columns with given value of the filtered values"
    _inc: service_pattern_scheduled_stop_point_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: service_pattern_scheduled_stop_point_set_input,
    "filter the rows which have to be updated"
    where: service_pattern_scheduled_stop_point_bool_exp!
  ): service_pattern_scheduled_stop_point_mutation_response
  "update single row of the table: \"service_pattern.scheduled_stop_point\""
  update_service_pattern_scheduled_stop_point_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: service_pattern_scheduled_stop_point_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: service_pattern_scheduled_stop_point_set_input,
    pk_columns: service_pattern_scheduled_stop_point_pk_columns_input!
  ): service_pattern_scheduled_stop_point
  "update multiples rows of table: \"service_pattern.scheduled_stop_point\""
  update_service_pattern_scheduled_stop_point_many(
    "updates to execute, in order"
    updates: [service_pattern_scheduled_stop_point_updates!]!
  ): [service_pattern_scheduled_stop_point_mutation_response]
  "update data of the table: \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
  update_service_pattern_vehicle_mode_on_scheduled_stop_point(
    "sets the columns of the filtered rows to the given values"
    _set: service_pattern_vehicle_mode_on_scheduled_stop_point_set_input,
    "filter the rows which have to be updated"
    where: service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp!
  ): service_pattern_vehicle_mode_on_scheduled_stop_point_mutation_response
  "update single row of the table: \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
  update_service_pattern_vehicle_mode_on_scheduled_stop_point_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: service_pattern_vehicle_mode_on_scheduled_stop_point_set_input,
    pk_columns: service_pattern_vehicle_mode_on_scheduled_stop_point_pk_columns_input!
  ): service_pattern_vehicle_mode_on_scheduled_stop_point
  "update multiples rows of table: \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
  update_service_pattern_vehicle_mode_on_scheduled_stop_point_many(
    "updates to execute, in order"
    updates: [service_pattern_vehicle_mode_on_scheduled_stop_point_updates!]!
  ): [service_pattern_vehicle_mode_on_scheduled_stop_point_mutation_response]
  "update data of the table: \"timing_pattern.timing_place\""
  update_timing_pattern_timing_place(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: timing_pattern_timing_place_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: timing_pattern_timing_place_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: timing_pattern_timing_place_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: timing_pattern_timing_place_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: timing_pattern_timing_place_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: timing_pattern_timing_place_set_input,
    "filter the rows which have to be updated"
    where: timing_pattern_timing_place_bool_exp!
  ): timing_pattern_timing_place_mutation_response
  "update single row of the table: \"timing_pattern.timing_place\""
  update_timing_pattern_timing_place_by_pk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: timing_pattern_timing_place_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: timing_pattern_timing_place_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: timing_pattern_timing_place_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: timing_pattern_timing_place_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: timing_pattern_timing_place_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: timing_pattern_timing_place_set_input,
    pk_columns: timing_pattern_timing_place_pk_columns_input!
  ): timing_pattern_timing_place
  "update multiples rows of table: \"timing_pattern.timing_place\""
  update_timing_pattern_timing_place_many(
    "updates to execute, in order"
    updates: [timing_pattern_timing_place_updates!]!
  ): [timing_pattern_timing_place_mutation_response]
}

type query_root {
  "fetch data from the table: \"hsl_route.legacy_hsl_municipality_code\""
  hsl_route_legacy_hsl_municipality_code(
    "distinct select on columns"
    distinct_on: [hsl_route_legacy_hsl_municipality_code_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [hsl_route_legacy_hsl_municipality_code_order_by!],
    "filter the rows returned"
    where: hsl_route_legacy_hsl_municipality_code_bool_exp
  ): [hsl_route_legacy_hsl_municipality_code!]!
  "fetch aggregated fields from the table: \"hsl_route.legacy_hsl_municipality_code\""
  hsl_route_legacy_hsl_municipality_code_aggregate(
    "distinct select on columns"
    distinct_on: [hsl_route_legacy_hsl_municipality_code_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [hsl_route_legacy_hsl_municipality_code_order_by!],
    "filter the rows returned"
    where: hsl_route_legacy_hsl_municipality_code_bool_exp
  ): hsl_route_legacy_hsl_municipality_code_aggregate!
  "fetch data from the table: \"hsl_route.legacy_hsl_municipality_code\" using primary key columns"
  hsl_route_legacy_hsl_municipality_code_by_pk(hsl_municipality: String!): hsl_route_legacy_hsl_municipality_code
  "fetch data from the table: \"hsl_route.transport_target\""
  hsl_route_transport_target(
    "distinct select on columns"
    distinct_on: [hsl_route_transport_target_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [hsl_route_transport_target_order_by!],
    "filter the rows returned"
    where: hsl_route_transport_target_bool_exp
  ): [hsl_route_transport_target!]!
  "fetch aggregated fields from the table: \"hsl_route.transport_target\""
  hsl_route_transport_target_aggregate(
    "distinct select on columns"
    distinct_on: [hsl_route_transport_target_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [hsl_route_transport_target_order_by!],
    "filter the rows returned"
    where: hsl_route_transport_target_bool_exp
  ): hsl_route_transport_target_aggregate!
  "fetch data from the table: \"hsl_route.transport_target\" using primary key columns"
  hsl_route_transport_target_by_pk(transport_target: String!): hsl_route_transport_target
  "fetch data from the table: \"infrastructure_network.direction\""
  infrastructure_network_direction(
    "distinct select on columns"
    distinct_on: [infrastructure_network_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_direction_order_by!],
    "filter the rows returned"
    where: infrastructure_network_direction_bool_exp
  ): [infrastructure_network_direction!]!
  "fetch aggregated fields from the table: \"infrastructure_network.direction\""
  infrastructure_network_direction_aggregate(
    "distinct select on columns"
    distinct_on: [infrastructure_network_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_direction_order_by!],
    "filter the rows returned"
    where: infrastructure_network_direction_bool_exp
  ): infrastructure_network_direction_aggregate!
  "fetch data from the table: \"infrastructure_network.direction\" using primary key columns"
  infrastructure_network_direction_by_pk(value: String!): infrastructure_network_direction
  "fetch data from the table: \"infrastructure_network.external_source\""
  infrastructure_network_external_source(
    "distinct select on columns"
    distinct_on: [infrastructure_network_external_source_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_external_source_order_by!],
    "filter the rows returned"
    where: infrastructure_network_external_source_bool_exp
  ): [infrastructure_network_external_source!]!
  "fetch aggregated fields from the table: \"infrastructure_network.external_source\""
  infrastructure_network_external_source_aggregate(
    "distinct select on columns"
    distinct_on: [infrastructure_network_external_source_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_external_source_order_by!],
    "filter the rows returned"
    where: infrastructure_network_external_source_bool_exp
  ): infrastructure_network_external_source_aggregate!
  "fetch data from the table: \"infrastructure_network.external_source\" using primary key columns"
  infrastructure_network_external_source_by_pk(value: String!): infrastructure_network_external_source
  "execute function \"infrastructure_network.find_point_direction_on_link\" which returns \"infrastructure_network.direction\""
  infrastructure_network_find_point_direction_on_link(
    "input parameters for function \"infrastructure_network_find_point_direction_on_link\""
    args: infrastructure_network_find_point_direction_on_link_args!,
    "distinct select on columns"
    distinct_on: [infrastructure_network_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_direction_order_by!],
    "filter the rows returned"
    where: infrastructure_network_direction_bool_exp
  ): [infrastructure_network_direction!]!
  "execute function \"infrastructure_network.find_point_direction_on_link\" and query aggregates on result of table type \"infrastructure_network.direction\""
  infrastructure_network_find_point_direction_on_link_aggregate(
    "input parameters for function \"infrastructure_network_find_point_direction_on_link_aggregate\""
    args: infrastructure_network_find_point_direction_on_link_args!,
    "distinct select on columns"
    distinct_on: [infrastructure_network_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_direction_order_by!],
    "filter the rows returned"
    where: infrastructure_network_direction_bool_exp
  ): infrastructure_network_direction_aggregate!
  "fetch data from the table: \"infrastructure_network.infrastructure_link\""
  infrastructure_network_infrastructure_link(
    "distinct select on columns"
    distinct_on: [infrastructure_network_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_infrastructure_link_bool_exp
  ): [infrastructure_network_infrastructure_link!]!
  "fetch aggregated fields from the table: \"infrastructure_network.infrastructure_link\""
  infrastructure_network_infrastructure_link_aggregate(
    "distinct select on columns"
    distinct_on: [infrastructure_network_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_infrastructure_link_bool_exp
  ): infrastructure_network_infrastructure_link_aggregate!
  "fetch data from the table: \"infrastructure_network.infrastructure_link\" using primary key columns"
  infrastructure_network_infrastructure_link_by_pk(
    "The ID of the infrastructure link."
    infrastructure_link_id: uuid!
  ): infrastructure_network_infrastructure_link
  "execute function \"infrastructure_network.resolve_point_to_closest_link\" which returns \"infrastructure_network.infrastructure_link\""
  infrastructure_network_resolve_point_to_closest_link(
    "input parameters for function \"infrastructure_network_resolve_point_to_closest_link\""
    args: infrastructure_network_resolve_point_to_closest_link_args!,
    "distinct select on columns"
    distinct_on: [infrastructure_network_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_infrastructure_link_bool_exp
  ): [infrastructure_network_infrastructure_link!]!
  "execute function \"infrastructure_network.resolve_point_to_closest_link\" and query aggregates on result of table type \"infrastructure_network.infrastructure_link\""
  infrastructure_network_resolve_point_to_closest_link_aggregate(
    "input parameters for function \"infrastructure_network_resolve_point_to_closest_link_aggregate\""
    args: infrastructure_network_resolve_point_to_closest_link_args!,
    "distinct select on columns"
    distinct_on: [infrastructure_network_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_infrastructure_link_bool_exp
  ): infrastructure_network_infrastructure_link_aggregate!
  "fetch data from the table: \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
  infrastructure_network_vehicle_submode_on_infrastructure_link(
    "distinct select on columns"
    distinct_on: [infrastructure_network_vehicle_submode_on_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_vehicle_submode_on_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  ): [infrastructure_network_vehicle_submode_on_infrastructure_link!]!
  "fetch aggregated fields from the table: \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
  infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate(
    "distinct select on columns"
    distinct_on: [infrastructure_network_vehicle_submode_on_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_vehicle_submode_on_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  ): infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate!
  "fetch data from the table: \"infrastructure_network.vehicle_submode_on_infrastructure_link\" using primary key columns"
  infrastructure_network_vehicle_submode_on_infrastructure_link_by_pk(
    "The infrastructure link that can be safely traversed by the vehicle submode."
    infrastructure_link_id: uuid!,
    "The vehicle submode that can safely traverse the infrastructure link."
    vehicle_submode: reusable_components_vehicle_submode_enum!
  ): infrastructure_network_vehicle_submode_on_infrastructure_link
  "execute function \"journey_pattern.check_infra_link_stop_refs_with_new_scheduled_stop_point\" which returns \"journey_pattern.journey_pattern\""
  journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point(
    "input parameters for function \"journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point\""
    args: journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point_args!,
    "distinct select on columns"
    distinct_on: [journey_pattern_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_journey_pattern_bool_exp
  ): [journey_pattern_journey_pattern!]!
  "execute function \"journey_pattern.check_infra_link_stop_refs_with_new_scheduled_stop_point\" and query aggregates on result of table type \"journey_pattern.journey_pattern\""
  journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point_aggregate(
    "input parameters for function \"journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point_aggregate\""
    args: journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point_args!,
    "distinct select on columns"
    distinct_on: [journey_pattern_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_journey_pattern_bool_exp
  ): journey_pattern_journey_pattern_aggregate!
  "fetch data from the table: \"journey_pattern.journey_pattern\""
  journey_pattern_journey_pattern(
    "distinct select on columns"
    distinct_on: [journey_pattern_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_journey_pattern_bool_exp
  ): [journey_pattern_journey_pattern!]!
  "fetch aggregated fields from the table: \"journey_pattern.journey_pattern\""
  journey_pattern_journey_pattern_aggregate(
    "distinct select on columns"
    distinct_on: [journey_pattern_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_journey_pattern_bool_exp
  ): journey_pattern_journey_pattern_aggregate!
  "fetch data from the table: \"journey_pattern.journey_pattern\" using primary key columns"
  journey_pattern_journey_pattern_by_pk(
    "The ID of the journey pattern."
    journey_pattern_id: uuid!
  ): journey_pattern_journey_pattern
  "fetch data from the table: \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
  journey_pattern_scheduled_stop_point_in_journey_pattern(
    "distinct select on columns"
    distinct_on: [journey_pattern_scheduled_stop_point_in_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_scheduled_stop_point_in_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  ): [journey_pattern_scheduled_stop_point_in_journey_pattern!]!
  "fetch aggregated fields from the table: \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
  journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate(
    "distinct select on columns"
    distinct_on: [journey_pattern_scheduled_stop_point_in_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_scheduled_stop_point_in_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  ): journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate!
  "fetch data from the table: \"journey_pattern.scheduled_stop_point_in_journey_pattern\" using primary key columns"
  journey_pattern_scheduled_stop_point_in_journey_pattern_by_pk(
    "The ID of the journey pattern."
    journey_pattern_id: uuid!,
    "The order of the scheduled stop point within the journey pattern."
    scheduled_stop_point_sequence: Int!
  ): journey_pattern_scheduled_stop_point_in_journey_pattern
  "fetch data from the table: \"reusable_components.vehicle_mode\""
  reusable_components_vehicle_mode(
    "distinct select on columns"
    distinct_on: [reusable_components_vehicle_mode_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [reusable_components_vehicle_mode_order_by!],
    "filter the rows returned"
    where: reusable_components_vehicle_mode_bool_exp
  ): [reusable_components_vehicle_mode!]!
  "fetch aggregated fields from the table: \"reusable_components.vehicle_mode\""
  reusable_components_vehicle_mode_aggregate(
    "distinct select on columns"
    distinct_on: [reusable_components_vehicle_mode_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [reusable_components_vehicle_mode_order_by!],
    "filter the rows returned"
    where: reusable_components_vehicle_mode_bool_exp
  ): reusable_components_vehicle_mode_aggregate!
  "fetch data from the table: \"reusable_components.vehicle_mode\" using primary key columns"
  reusable_components_vehicle_mode_by_pk(
    "The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
    vehicle_mode: String!
  ): reusable_components_vehicle_mode
  "fetch data from the table: \"reusable_components.vehicle_submode\""
  reusable_components_vehicle_submode(
    "distinct select on columns"
    distinct_on: [reusable_components_vehicle_submode_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [reusable_components_vehicle_submode_order_by!],
    "filter the rows returned"
    where: reusable_components_vehicle_submode_bool_exp
  ): [reusable_components_vehicle_submode!]!
  "fetch aggregated fields from the table: \"reusable_components.vehicle_submode\""
  reusable_components_vehicle_submode_aggregate(
    "distinct select on columns"
    distinct_on: [reusable_components_vehicle_submode_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [reusable_components_vehicle_submode_order_by!],
    "filter the rows returned"
    where: reusable_components_vehicle_submode_bool_exp
  ): reusable_components_vehicle_submode_aggregate!
  "fetch data from the table: \"reusable_components.vehicle_submode\" using primary key columns"
  reusable_components_vehicle_submode_by_pk(
    "The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse"
    vehicle_submode: String!
  ): reusable_components_vehicle_submode
  "fetch data from the table: \"route.direction\""
  route_direction(
    "distinct select on columns"
    distinct_on: [route_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_direction_order_by!],
    "filter the rows returned"
    where: route_direction_bool_exp
  ): [route_direction!]!
  "fetch aggregated fields from the table: \"route.direction\""
  route_direction_aggregate(
    "distinct select on columns"
    distinct_on: [route_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_direction_order_by!],
    "filter the rows returned"
    where: route_direction_bool_exp
  ): route_direction_aggregate!
  "fetch data from the table: \"route.direction\" using primary key columns"
  route_direction_by_pk(
    "The name of the route direction."
    direction: String!
  ): route_direction
  "fetch data from the table: \"route.infrastructure_link_along_route\""
  route_infrastructure_link_along_route(
    "distinct select on columns"
    distinct_on: [route_infrastructure_link_along_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_infrastructure_link_along_route_order_by!],
    "filter the rows returned"
    where: route_infrastructure_link_along_route_bool_exp
  ): [route_infrastructure_link_along_route!]!
  "fetch aggregated fields from the table: \"route.infrastructure_link_along_route\""
  route_infrastructure_link_along_route_aggregate(
    "distinct select on columns"
    distinct_on: [route_infrastructure_link_along_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_infrastructure_link_along_route_order_by!],
    "filter the rows returned"
    where: route_infrastructure_link_along_route_bool_exp
  ): route_infrastructure_link_along_route_aggregate!
  "fetch data from the table: \"route.infrastructure_link_along_route\" using primary key columns"
  route_infrastructure_link_along_route_by_pk(
    "The order of the infrastructure link within the journey pattern."
    infrastructure_link_sequence: Int!,
    "The ID of the route."
    route_id: uuid!
  ): route_infrastructure_link_along_route
  "fetch data from the table: \"route.line\""
  route_line(
    "distinct select on columns"
    distinct_on: [route_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_line_order_by!],
    "filter the rows returned"
    where: route_line_bool_exp
  ): [route_line!]!
  "fetch aggregated fields from the table: \"route.line\""
  route_line_aggregate(
    "distinct select on columns"
    distinct_on: [route_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_line_order_by!],
    "filter the rows returned"
    where: route_line_bool_exp
  ): route_line_aggregate!
  "fetch data from the table: \"route.line\" using primary key columns"
  route_line_by_pk(
    "The ID of the line."
    line_id: uuid!
  ): route_line
  "fetch data from the table: \"route.route\""
  route_route(
    "distinct select on columns"
    distinct_on: [route_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_route_order_by!],
    "filter the rows returned"
    where: route_route_bool_exp
  ): [route_route!]!
  "fetch aggregated fields from the table: \"route.route\""
  route_route_aggregate(
    "distinct select on columns"
    distinct_on: [route_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_route_order_by!],
    "filter the rows returned"
    where: route_route_bool_exp
  ): route_route_aggregate!
  "fetch data from the table: \"route.route\" using primary key columns"
  route_route_by_pk(
    "The ID of the route."
    route_id: uuid!
  ): route_route
  "fetch data from the table: \"route.type_of_line\""
  route_type_of_line(
    "distinct select on columns"
    distinct_on: [route_type_of_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_type_of_line_order_by!],
    "filter the rows returned"
    where: route_type_of_line_bool_exp
  ): [route_type_of_line!]!
  "fetch aggregated fields from the table: \"route.type_of_line\""
  route_type_of_line_aggregate(
    "distinct select on columns"
    distinct_on: [route_type_of_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_type_of_line_order_by!],
    "filter the rows returned"
    where: route_type_of_line_bool_exp
  ): route_type_of_line_aggregate!
  "fetch data from the table: \"route.type_of_line\" using primary key columns"
  route_type_of_line_by_pk(
    "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
    type_of_line: String!
  ): route_type_of_line
  "fetch data from the table: \"service_pattern.distance_between_stops_calculation\""
  service_pattern_distance_between_stops_calculation(
    "distinct select on columns"
    distinct_on: [service_pattern_distance_between_stops_calculation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_distance_between_stops_calculation_order_by!],
    "filter the rows returned"
    where: service_pattern_distance_between_stops_calculation_bool_exp
  ): [service_pattern_distance_between_stops_calculation!]!
  "fetch aggregated fields from the table: \"service_pattern.distance_between_stops_calculation\""
  service_pattern_distance_between_stops_calculation_aggregate(
    "distinct select on columns"
    distinct_on: [service_pattern_distance_between_stops_calculation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_distance_between_stops_calculation_order_by!],
    "filter the rows returned"
    where: service_pattern_distance_between_stops_calculation_bool_exp
  ): service_pattern_distance_between_stops_calculation_aggregate!
  "fetch data from the table: \"service_pattern.distance_between_stops_calculation\" using primary key columns"
  service_pattern_distance_between_stops_calculation_by_pk(
    "The ID of the journey pattern."
    journey_pattern_id: uuid!,
    "The observation date for the state of the route related to the journey pattern."
    observation_date: date!,
    "The priority of the route related to the journey pattern."
    route_priority: Int!,
    "The sequence number of the stop interval within the journey pattern."
    stop_interval_sequence: Int!
  ): service_pattern_distance_between_stops_calculation
  "execute function \"service_pattern.get_distances_between_stop_points_by_routes\" which returns \"service_pattern.distance_between_stops_calculation\""
  service_pattern_get_distances_between_stop_points_by_routes(
    "input parameters for function \"service_pattern_get_distances_between_stop_points_by_routes\""
    args: service_pattern_get_distances_between_stop_points_by_routes_args!,
    "distinct select on columns"
    distinct_on: [service_pattern_distance_between_stops_calculation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_distance_between_stops_calculation_order_by!],
    "filter the rows returned"
    where: service_pattern_distance_between_stops_calculation_bool_exp
  ): [service_pattern_distance_between_stops_calculation!]!
  "execute function \"service_pattern.get_distances_between_stop_points_by_routes\" and query aggregates on result of table type \"service_pattern.distance_between_stops_calculation\""
  service_pattern_get_distances_between_stop_points_by_routes_aggregate(
    "input parameters for function \"service_pattern_get_distances_between_stop_points_by_routes_aggregate\""
    args: service_pattern_get_distances_between_stop_points_by_routes_args!,
    "distinct select on columns"
    distinct_on: [service_pattern_distance_between_stops_calculation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_distance_between_stops_calculation_order_by!],
    "filter the rows returned"
    where: service_pattern_distance_between_stops_calculation_bool_exp
  ): service_pattern_distance_between_stops_calculation_aggregate!
  "execute function \"service_pattern.get_distances_between_stop_points_in_journey_patterns\" which returns \"service_pattern.distance_between_stops_calculation\""
  service_pattern_get_distances_between_stop_points_in_journey_patterns(
    "input parameters for function \"service_pattern_get_distances_between_stop_points_in_journey_patterns\""
    args: service_pattern_get_distances_between_stop_points_in_journey_patterns_args!,
    "distinct select on columns"
    distinct_on: [service_pattern_distance_between_stops_calculation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_distance_between_stops_calculation_order_by!],
    "filter the rows returned"
    where: service_pattern_distance_between_stops_calculation_bool_exp
  ): [service_pattern_distance_between_stops_calculation!]!
  "execute function \"service_pattern.get_distances_between_stop_points_in_journey_patterns\" and query aggregates on result of table type \"service_pattern.distance_between_stops_calculation\""
  service_pattern_get_distances_between_stop_points_in_journey_patterns_aggregate(
    "input parameters for function \"service_pattern_get_distances_between_stop_points_in_journey_patterns_aggregate\""
    args: service_pattern_get_distances_between_stop_points_in_journey_patterns_args!,
    "distinct select on columns"
    distinct_on: [service_pattern_distance_between_stops_calculation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_distance_between_stops_calculation_order_by!],
    "filter the rows returned"
    where: service_pattern_distance_between_stops_calculation_bool_exp
  ): service_pattern_distance_between_stops_calculation_aggregate!
  "fetch data from the table: \"service_pattern.scheduled_stop_point\""
  service_pattern_scheduled_stop_point(
    "distinct select on columns"
    distinct_on: [service_pattern_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): [service_pattern_scheduled_stop_point!]!
  "fetch aggregated fields from the table: \"service_pattern.scheduled_stop_point\""
  service_pattern_scheduled_stop_point_aggregate(
    "distinct select on columns"
    distinct_on: [service_pattern_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): service_pattern_scheduled_stop_point_aggregate!
  "fetch data from the table: \"service_pattern.scheduled_stop_point\" using primary key columns"
  service_pattern_scheduled_stop_point_by_pk(
    "The ID of the scheduled stop point."
    scheduled_stop_point_id: uuid!
  ): service_pattern_scheduled_stop_point
  "fetch data from the table: \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
  service_pattern_vehicle_mode_on_scheduled_stop_point(
    "distinct select on columns"
    distinct_on: [service_pattern_vehicle_mode_on_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_vehicle_mode_on_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp
  ): [service_pattern_vehicle_mode_on_scheduled_stop_point!]!
  "fetch aggregated fields from the table: \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
  service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate(
    "distinct select on columns"
    distinct_on: [service_pattern_vehicle_mode_on_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_vehicle_mode_on_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp
  ): service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate!
  "fetch data from the table: \"service_pattern.vehicle_mode_on_scheduled_stop_point\" using primary key columns"
  service_pattern_vehicle_mode_on_scheduled_stop_point_by_pk(
    "The scheduled stop point that is serviced by the vehicle mode."
    scheduled_stop_point_id: uuid!,
    "The vehicle mode servicing the scheduled stop point."
    vehicle_mode: reusable_components_vehicle_mode_enum!
  ): service_pattern_vehicle_mode_on_scheduled_stop_point
  timetables: timetables_timetables_query
  "fetch data from the table: \"timing_pattern.timing_place\""
  timing_pattern_timing_place(
    "distinct select on columns"
    distinct_on: [timing_pattern_timing_place_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timing_pattern_timing_place_order_by!],
    "filter the rows returned"
    where: timing_pattern_timing_place_bool_exp
  ): [timing_pattern_timing_place!]!
  "fetch aggregated fields from the table: \"timing_pattern.timing_place\""
  timing_pattern_timing_place_aggregate(
    "distinct select on columns"
    distinct_on: [timing_pattern_timing_place_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timing_pattern_timing_place_order_by!],
    "filter the rows returned"
    where: timing_pattern_timing_place_bool_exp
  ): timing_pattern_timing_place_aggregate!
  "fetch data from the table: \"timing_pattern.timing_place\" using primary key columns"
  timing_pattern_timing_place_by_pk(timing_place_id: uuid!): timing_pattern_timing_place
  toCombineTargetVehicleScheduleFrameId(arg1: ToCombineTargetVehicleScheduleFrameIdInput!): ToCombineTargetVehicleScheduleFrameIdOutput
  toReplaceVehicleScheduleFrameIds(arg1: ToReplaceVehicleScheduleFrameIdsInput!): ToReplaceVehicleScheduleFrameIdsOutput
}

"The vehicle modes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
type reusable_components_vehicle_mode {
  "The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
  vehicle_mode: String!
  "An array relationship"
  vehicle_submodes(
    "distinct select on columns"
    distinct_on: [reusable_components_vehicle_submode_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [reusable_components_vehicle_submode_order_by!],
    "filter the rows returned"
    where: reusable_components_vehicle_submode_bool_exp
  ): [reusable_components_vehicle_submode!]!
  "An aggregate relationship"
  vehicle_submodes_aggregate(
    "distinct select on columns"
    distinct_on: [reusable_components_vehicle_submode_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [reusable_components_vehicle_submode_order_by!],
    "filter the rows returned"
    where: reusable_components_vehicle_submode_bool_exp
  ): reusable_components_vehicle_submode_aggregate!
}

"aggregated selection of \"reusable_components.vehicle_mode\""
type reusable_components_vehicle_mode_aggregate {
  aggregate: reusable_components_vehicle_mode_aggregate_fields
  nodes: [reusable_components_vehicle_mode!]!
}

"aggregate fields of \"reusable_components.vehicle_mode\""
type reusable_components_vehicle_mode_aggregate_fields {
  count(columns: [reusable_components_vehicle_mode_select_column!], distinct: Boolean): Int!
  max: reusable_components_vehicle_mode_max_fields
  min: reusable_components_vehicle_mode_min_fields
}

"aggregate max on columns"
type reusable_components_vehicle_mode_max_fields {
  "The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
  vehicle_mode: String
}

"aggregate min on columns"
type reusable_components_vehicle_mode_min_fields {
  "The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
  vehicle_mode: String
}

"response of any mutation on the table \"reusable_components.vehicle_mode\""
type reusable_components_vehicle_mode_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [reusable_components_vehicle_mode!]!
}

"The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse"
type reusable_components_vehicle_submode {
  "The vehicle mode the vehicle submode belongs to: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
  belonging_to_vehicle_mode: reusable_components_vehicle_mode_enum!
  "An object relationship"
  vehicle_mode: reusable_components_vehicle_mode!
  "The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse"
  vehicle_submode: String!
  "An array relationship"
  vehicle_submode_on_infrastructure_links(
    "distinct select on columns"
    distinct_on: [infrastructure_network_vehicle_submode_on_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_vehicle_submode_on_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  ): [infrastructure_network_vehicle_submode_on_infrastructure_link!]!
  "An aggregate relationship"
  vehicle_submode_on_infrastructure_links_aggregate(
    "distinct select on columns"
    distinct_on: [infrastructure_network_vehicle_submode_on_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_vehicle_submode_on_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  ): infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate!
}

"aggregated selection of \"reusable_components.vehicle_submode\""
type reusable_components_vehicle_submode_aggregate {
  aggregate: reusable_components_vehicle_submode_aggregate_fields
  nodes: [reusable_components_vehicle_submode!]!
}

"aggregate fields of \"reusable_components.vehicle_submode\""
type reusable_components_vehicle_submode_aggregate_fields {
  count(columns: [reusable_components_vehicle_submode_select_column!], distinct: Boolean): Int!
  max: reusable_components_vehicle_submode_max_fields
  min: reusable_components_vehicle_submode_min_fields
}

"aggregate max on columns"
type reusable_components_vehicle_submode_max_fields {
  "The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse"
  vehicle_submode: String
}

"aggregate min on columns"
type reusable_components_vehicle_submode_min_fields {
  "The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse"
  vehicle_submode: String
}

"response of any mutation on the table \"reusable_components.vehicle_submode\""
type reusable_components_vehicle_submode_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [reusable_components_vehicle_submode!]!
}

"The route directions from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:480"
type route_direction {
  "The name of the route direction."
  direction: String!
  "An object relationship"
  directionByTheOppositeOfDirection: route_direction
  "An array relationship"
  directions(
    "distinct select on columns"
    distinct_on: [route_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_direction_order_by!],
    "filter the rows returned"
    where: route_direction_bool_exp
  ): [route_direction!]!
  "An aggregate relationship"
  directions_aggregate(
    "distinct select on columns"
    distinct_on: [route_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_direction_order_by!],
    "filter the rows returned"
    where: route_direction_bool_exp
  ): route_direction_aggregate!
  "The opposite direction."
  the_opposite_of_direction: route_direction_enum
}

"aggregated selection of \"route.direction\""
type route_direction_aggregate {
  aggregate: route_direction_aggregate_fields
  nodes: [route_direction!]!
}

"aggregate fields of \"route.direction\""
type route_direction_aggregate_fields {
  count(columns: [route_direction_select_column!], distinct: Boolean): Int!
  max: route_direction_max_fields
  min: route_direction_min_fields
}

"aggregate max on columns"
type route_direction_max_fields {
  "The name of the route direction."
  direction: String
}

"aggregate min on columns"
type route_direction_min_fields {
  "The name of the route direction."
  direction: String
}

"response of any mutation on the table \"route.direction\""
type route_direction_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [route_direction!]!
}

"The infrastructure links along which the routes are defined."
type route_infrastructure_link_along_route {
  "An object relationship"
  infrastructure_link: infrastructure_network_infrastructure_link!
  "The ID of the infrastructure link."
  infrastructure_link_id: uuid!
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Int!
  "Is the infrastructure link traversed in the direction of its linestring?"
  is_traversal_forwards: Boolean!
  "The ID of the route."
  route_id: uuid!
}

"aggregated selection of \"route.infrastructure_link_along_route\""
type route_infrastructure_link_along_route_aggregate {
  aggregate: route_infrastructure_link_along_route_aggregate_fields
  nodes: [route_infrastructure_link_along_route!]!
}

"aggregate fields of \"route.infrastructure_link_along_route\""
type route_infrastructure_link_along_route_aggregate_fields {
  avg: route_infrastructure_link_along_route_avg_fields
  count(columns: [route_infrastructure_link_along_route_select_column!], distinct: Boolean): Int!
  max: route_infrastructure_link_along_route_max_fields
  min: route_infrastructure_link_along_route_min_fields
  stddev: route_infrastructure_link_along_route_stddev_fields
  stddev_pop: route_infrastructure_link_along_route_stddev_pop_fields
  stddev_samp: route_infrastructure_link_along_route_stddev_samp_fields
  sum: route_infrastructure_link_along_route_sum_fields
  var_pop: route_infrastructure_link_along_route_var_pop_fields
  var_samp: route_infrastructure_link_along_route_var_samp_fields
  variance: route_infrastructure_link_along_route_variance_fields
}

"aggregate avg on columns"
type route_infrastructure_link_along_route_avg_fields {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Float
}

"aggregate max on columns"
type route_infrastructure_link_along_route_max_fields {
  "The ID of the infrastructure link."
  infrastructure_link_id: uuid
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Int
  "The ID of the route."
  route_id: uuid
}

"aggregate min on columns"
type route_infrastructure_link_along_route_min_fields {
  "The ID of the infrastructure link."
  infrastructure_link_id: uuid
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Int
  "The ID of the route."
  route_id: uuid
}

"response of any mutation on the table \"route.infrastructure_link_along_route\""
type route_infrastructure_link_along_route_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [route_infrastructure_link_along_route!]!
}

"aggregate stddev on columns"
type route_infrastructure_link_along_route_stddev_fields {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Float
}

"aggregate stddev_pop on columns"
type route_infrastructure_link_along_route_stddev_pop_fields {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Float
}

"aggregate stddev_samp on columns"
type route_infrastructure_link_along_route_stddev_samp_fields {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Float
}

"aggregate sum on columns"
type route_infrastructure_link_along_route_sum_fields {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Int
}

"aggregate var_pop on columns"
type route_infrastructure_link_along_route_var_pop_fields {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Float
}

"aggregate var_samp on columns"
type route_infrastructure_link_along_route_var_samp_fields {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Float
}

"aggregate variance on columns"
type route_infrastructure_link_along_route_variance_fields {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Float
}

"The line from Transmodel: http://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:487"
type route_line {
  "The label of the line definition. The label is unique for a certain priority and validity period."
  label: String!
  "An object relationship"
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode: hsl_route_legacy_hsl_municipality_code
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: String
  "The ID of the line."
  line_id: uuid!
  "An array relationship"
  line_routes(
    "distinct select on columns"
    distinct_on: [route_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_route_order_by!],
    "filter the rows returned"
    where: route_route_bool_exp
  ): [route_route!]!
  "An aggregate relationship"
  line_routes_aggregate(
    "distinct select on columns"
    distinct_on: [route_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_route_order_by!],
    "filter the rows returned"
    where: route_route_bool_exp
  ): route_route_aggregate!
  "The name of the line. Placeholder for multilingual strings."
  name_i18n(
    "JSON select path"
    path: String
  ): jsonb!
  "The mode of the vehicles used as primary on the line."
  primary_vehicle_mode: reusable_components_vehicle_mode_enum!
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Int!
  "The shorted name of the line. Placeholder for multilingual strings."
  short_name_i18n(
    "JSON select path"
    path: String
  ): jsonb!
  "An object relationship"
  transportTargetByTransportTarget: hsl_route_transport_target!
  transport_target: hsl_route_transport_target_enum!
  "An object relationship"
  typeOfLineByTypeOfLine: route_type_of_line!
  "The type of the line."
  type_of_line: route_type_of_line_enum!
  "The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid."
  validity_end: date
  "The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid."
  validity_start: date
  "An object relationship"
  vehicle_mode: reusable_components_vehicle_mode!
}

"aggregated selection of \"route.line\""
type route_line_aggregate {
  aggregate: route_line_aggregate_fields
  nodes: [route_line!]!
}

"aggregate fields of \"route.line\""
type route_line_aggregate_fields {
  avg: route_line_avg_fields
  count(columns: [route_line_select_column!], distinct: Boolean): Int!
  max: route_line_max_fields
  min: route_line_min_fields
  stddev: route_line_stddev_fields
  stddev_pop: route_line_stddev_pop_fields
  stddev_samp: route_line_stddev_samp_fields
  sum: route_line_sum_fields
  var_pop: route_line_var_pop_fields
  var_samp: route_line_var_samp_fields
  variance: route_line_variance_fields
}

"aggregate avg on columns"
type route_line_avg_fields {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Float
}

"aggregate max on columns"
type route_line_max_fields {
  "The label of the line definition. The label is unique for a certain priority and validity period."
  label: String
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: String
  "The ID of the line."
  line_id: uuid
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid."
  validity_end: date
  "The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid."
  validity_start: date
}

"aggregate min on columns"
type route_line_min_fields {
  "The label of the line definition. The label is unique for a certain priority and validity period."
  label: String
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: String
  "The ID of the line."
  line_id: uuid
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid."
  validity_end: date
  "The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid."
  validity_start: date
}

"response of any mutation on the table \"route.line\""
type route_line_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [route_line!]!
}

"aggregate stddev on columns"
type route_line_stddev_fields {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Float
}

"aggregate stddev_pop on columns"
type route_line_stddev_pop_fields {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Float
}

"aggregate stddev_samp on columns"
type route_line_stddev_samp_fields {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Float
}

"aggregate sum on columns"
type route_line_sum_fields {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Int
}

"aggregate var_pop on columns"
type route_line_var_pop_fields {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Float
}

"aggregate var_samp on columns"
type route_line_var_samp_fields {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Float
}

"aggregate variance on columns"
type route_line_variance_fields {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Float
}

"The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483"
type route_route {
  "The description of the route in the form of starting location - destination. Placeholder for multilingual strings."
  description_i18n(
    "JSON select path"
    path: String
  ): jsonb
  destination_name_i18n(
    "JSON select path"
    path: String
  ): jsonb
  destination_short_name_i18n(
    "JSON select path"
    path: String
  ): jsonb
  "The direction of the route definition."
  direction: route_direction_enum!
  "An array relationship"
  infrastructure_links_along_route(
    "distinct select on columns"
    distinct_on: [route_infrastructure_link_along_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_infrastructure_link_along_route_order_by!],
    "filter the rows returned"
    where: route_infrastructure_link_along_route_bool_exp
  ): [route_infrastructure_link_along_route!]!
  "An aggregate relationship"
  infrastructure_links_along_route_aggregate(
    "distinct select on columns"
    distinct_on: [route_infrastructure_link_along_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_infrastructure_link_along_route_order_by!],
    "filter the rows returned"
    where: route_infrastructure_link_along_route_bool_exp
  ): route_infrastructure_link_along_route_aggregate!
  "The label of the route definition."
  label: String!
  "An object relationship"
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode: hsl_route_legacy_hsl_municipality_code
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: String
  name_i18n(
    "JSON select path"
    path: String
  ): jsonb!
  "The line to which this route belongs."
  on_line_id: uuid!
  origin_name_i18n(
    "JSON select path"
    path: String
  ): jsonb
  origin_short_name_i18n(
    "JSON select path"
    path: String
  ): jsonb
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Int!
  "The ID of the route."
  route_id: uuid!
  "An array relationship"
  route_journey_patterns(
    "distinct select on columns"
    distinct_on: [journey_pattern_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_journey_pattern_bool_exp
  ): [journey_pattern_journey_pattern!]!
  "An aggregate relationship"
  route_journey_patterns_aggregate(
    "distinct select on columns"
    distinct_on: [journey_pattern_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_journey_pattern_bool_exp
  ): journey_pattern_journey_pattern_aggregate!
  "An object relationship"
  route_line: route_line
  "A computed field, executes function \"route.route_shape\""
  route_shape: geography
  "Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period"
  unique_label: String
  "The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period."
  validity_end: date
  "The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period."
  validity_start: date
  "The variant for route definition."
  variant: smallint
}

"aggregated selection of \"route.route\""
type route_route_aggregate {
  aggregate: route_route_aggregate_fields
  nodes: [route_route!]!
}

"aggregate fields of \"route.route\""
type route_route_aggregate_fields {
  avg: route_route_avg_fields
  count(columns: [route_route_select_column!], distinct: Boolean): Int!
  max: route_route_max_fields
  min: route_route_min_fields
  stddev: route_route_stddev_fields
  stddev_pop: route_route_stddev_pop_fields
  stddev_samp: route_route_stddev_samp_fields
  sum: route_route_sum_fields
  var_pop: route_route_var_pop_fields
  var_samp: route_route_var_samp_fields
  variance: route_route_variance_fields
}

"aggregate avg on columns"
type route_route_avg_fields {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Float
  "The variant for route definition."
  variant: Float
}

"aggregate max on columns"
type route_route_max_fields {
  "The label of the route definition."
  label: String
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: String
  "The line to which this route belongs."
  on_line_id: uuid
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "The ID of the route."
  route_id: uuid
  "Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period"
  unique_label: String
  "The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period."
  validity_end: date
  "The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period."
  validity_start: date
  "The variant for route definition."
  variant: smallint
}

"aggregate min on columns"
type route_route_min_fields {
  "The label of the route definition."
  label: String
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: String
  "The line to which this route belongs."
  on_line_id: uuid
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "The ID of the route."
  route_id: uuid
  "Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period"
  unique_label: String
  "The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period."
  validity_end: date
  "The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period."
  validity_start: date
  "The variant for route definition."
  variant: smallint
}

"response of any mutation on the table \"route.route\""
type route_route_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [route_route!]!
}

"aggregate stddev on columns"
type route_route_stddev_fields {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Float
  "The variant for route definition."
  variant: Float
}

"aggregate stddev_pop on columns"
type route_route_stddev_pop_fields {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Float
  "The variant for route definition."
  variant: Float
}

"aggregate stddev_samp on columns"
type route_route_stddev_samp_fields {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Float
  "The variant for route definition."
  variant: Float
}

"aggregate sum on columns"
type route_route_sum_fields {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "The variant for route definition."
  variant: smallint
}

"aggregate var_pop on columns"
type route_route_var_pop_fields {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Float
  "The variant for route definition."
  variant: Float
}

"aggregate var_samp on columns"
type route_route_var_samp_fields {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Float
  "The variant for route definition."
  variant: Float
}

"aggregate variance on columns"
type route_route_variance_fields {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Float
  "The variant for route definition."
  variant: Float
}

"Type of line. https://www.transmodel-cen.eu/model/EARoot/EA2/EA1/EA3/EA491.htm"
type route_type_of_line {
  belonging_to_vehicle_mode: reusable_components_vehicle_mode_enum!
  "An array relationship"
  lines(
    "distinct select on columns"
    distinct_on: [route_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_line_order_by!],
    "filter the rows returned"
    where: route_line_bool_exp
  ): [route_line!]!
  "An aggregate relationship"
  lines_aggregate(
    "distinct select on columns"
    distinct_on: [route_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_line_order_by!],
    "filter the rows returned"
    where: route_line_bool_exp
  ): route_line_aggregate!
  "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String!
  "An object relationship"
  vehicle_mode: reusable_components_vehicle_mode!
}

"aggregated selection of \"route.type_of_line\""
type route_type_of_line_aggregate {
  aggregate: route_type_of_line_aggregate_fields
  nodes: [route_type_of_line!]!
}

"aggregate fields of \"route.type_of_line\""
type route_type_of_line_aggregate_fields {
  count(columns: [route_type_of_line_select_column!], distinct: Boolean): Int!
  max: route_type_of_line_max_fields
  min: route_type_of_line_min_fields
}

"aggregate max on columns"
type route_type_of_line_max_fields {
  "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
}

"aggregate min on columns"
type route_type_of_line_min_fields {
  "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
}

"response of any mutation on the table \"route.type_of_line\""
type route_type_of_line_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [route_type_of_line!]!
}

"A dummy table that models the results of calculating the lengths of stop intervals from the given journey patterns. The table exists due to the limitations of Hasura and there is no intention to insert anything to it."
type service_pattern_distance_between_stops_calculation {
  "The length of the stop interval in metres."
  distance_in_metres: float8!
  "The label of the end stop of the stop interval."
  end_stop_label: String!
  "The ID of the journey pattern."
  journey_pattern_id: uuid!
  "The observation date for the state of the route related to the journey pattern."
  observation_date: date!
  "The ID of the route related to the journey pattern."
  route_id: uuid!
  "The priority of the route related to the journey pattern."
  route_priority: Int!
  "The label of the start stop of the stop interval."
  start_stop_label: String!
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Int!
}

"aggregated selection of \"service_pattern.distance_between_stops_calculation\""
type service_pattern_distance_between_stops_calculation_aggregate {
  aggregate: service_pattern_distance_between_stops_calculation_aggregate_fields
  nodes: [service_pattern_distance_between_stops_calculation!]!
}

"aggregate fields of \"service_pattern.distance_between_stops_calculation\""
type service_pattern_distance_between_stops_calculation_aggregate_fields {
  avg: service_pattern_distance_between_stops_calculation_avg_fields
  count(columns: [service_pattern_distance_between_stops_calculation_select_column!], distinct: Boolean): Int!
  max: service_pattern_distance_between_stops_calculation_max_fields
  min: service_pattern_distance_between_stops_calculation_min_fields
  stddev: service_pattern_distance_between_stops_calculation_stddev_fields
  stddev_pop: service_pattern_distance_between_stops_calculation_stddev_pop_fields
  stddev_samp: service_pattern_distance_between_stops_calculation_stddev_samp_fields
  sum: service_pattern_distance_between_stops_calculation_sum_fields
  var_pop: service_pattern_distance_between_stops_calculation_var_pop_fields
  var_samp: service_pattern_distance_between_stops_calculation_var_samp_fields
  variance: service_pattern_distance_between_stops_calculation_variance_fields
}

"aggregate avg on columns"
type service_pattern_distance_between_stops_calculation_avg_fields {
  "The length of the stop interval in metres."
  distance_in_metres: Float
  "The priority of the route related to the journey pattern."
  route_priority: Float
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Float
}

"aggregate max on columns"
type service_pattern_distance_between_stops_calculation_max_fields {
  "The length of the stop interval in metres."
  distance_in_metres: float8
  "The label of the end stop of the stop interval."
  end_stop_label: String
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  "The observation date for the state of the route related to the journey pattern."
  observation_date: date
  "The ID of the route related to the journey pattern."
  route_id: uuid
  "The priority of the route related to the journey pattern."
  route_priority: Int
  "The label of the start stop of the stop interval."
  start_stop_label: String
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Int
}

"aggregate min on columns"
type service_pattern_distance_between_stops_calculation_min_fields {
  "The length of the stop interval in metres."
  distance_in_metres: float8
  "The label of the end stop of the stop interval."
  end_stop_label: String
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  "The observation date for the state of the route related to the journey pattern."
  observation_date: date
  "The ID of the route related to the journey pattern."
  route_id: uuid
  "The priority of the route related to the journey pattern."
  route_priority: Int
  "The label of the start stop of the stop interval."
  start_stop_label: String
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Int
}

"response of any mutation on the table \"service_pattern.distance_between_stops_calculation\""
type service_pattern_distance_between_stops_calculation_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [service_pattern_distance_between_stops_calculation!]!
}

"aggregate stddev on columns"
type service_pattern_distance_between_stops_calculation_stddev_fields {
  "The length of the stop interval in metres."
  distance_in_metres: Float
  "The priority of the route related to the journey pattern."
  route_priority: Float
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Float
}

"aggregate stddev_pop on columns"
type service_pattern_distance_between_stops_calculation_stddev_pop_fields {
  "The length of the stop interval in metres."
  distance_in_metres: Float
  "The priority of the route related to the journey pattern."
  route_priority: Float
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Float
}

"aggregate stddev_samp on columns"
type service_pattern_distance_between_stops_calculation_stddev_samp_fields {
  "The length of the stop interval in metres."
  distance_in_metres: Float
  "The priority of the route related to the journey pattern."
  route_priority: Float
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Float
}

"aggregate sum on columns"
type service_pattern_distance_between_stops_calculation_sum_fields {
  "The length of the stop interval in metres."
  distance_in_metres: float8
  "The priority of the route related to the journey pattern."
  route_priority: Int
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Int
}

"aggregate var_pop on columns"
type service_pattern_distance_between_stops_calculation_var_pop_fields {
  "The length of the stop interval in metres."
  distance_in_metres: Float
  "The priority of the route related to the journey pattern."
  route_priority: Float
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Float
}

"aggregate var_samp on columns"
type service_pattern_distance_between_stops_calculation_var_samp_fields {
  "The length of the stop interval in metres."
  distance_in_metres: Float
  "The priority of the route related to the journey pattern."
  route_priority: Float
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Float
}

"aggregate variance on columns"
type service_pattern_distance_between_stops_calculation_variance_fields {
  "The length of the stop interval in metres."
  distance_in_metres: Float
  "The priority of the route related to the journey pattern."
  route_priority: Float
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Float
}

"The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning."
type service_pattern_scheduled_stop_point {
  "The point on the infrastructure link closest to measured_location. A PostGIS PointZ geography in EPSG:4326."
  closest_point_on_infrastructure_link: geography
  "The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string."
  direction: infrastructure_network_direction_enum!
  "The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code."
  label: String!
  "An object relationship"
  located_on_infrastructure_link: infrastructure_network_infrastructure_link!
  "The infrastructure link on which the stop is located."
  located_on_infrastructure_link_id: uuid!
  "The measured location describes the physical location of the stop. For some stops this describes the location of the pole-mounted flag. A PostGIS PointZ geography in EPSG:4326."
  measured_location: geography!
  "An array relationship"
  other_label_instances(
    "distinct select on columns"
    distinct_on: [service_pattern_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): [service_pattern_scheduled_stop_point!]!
  "An aggregate relationship"
  other_label_instances_aggregate(
    "distinct select on columns"
    distinct_on: [service_pattern_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): service_pattern_scheduled_stop_point_aggregate!
  priority: Int!
  "The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]."
  relative_distance_from_infrastructure_link_start: float8
  "The ID of the scheduled stop point."
  scheduled_stop_point_id: uuid!
  "An array relationship"
  scheduled_stop_point_in_journey_patterns(
    "distinct select on columns"
    distinct_on: [journey_pattern_scheduled_stop_point_in_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_scheduled_stop_point_in_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  ): [journey_pattern_scheduled_stop_point_in_journey_pattern!]!
  "An aggregate relationship"
  scheduled_stop_point_in_journey_patterns_aggregate(
    "distinct select on columns"
    distinct_on: [journey_pattern_scheduled_stop_point_in_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_scheduled_stop_point_in_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  ): journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate!
  "An object relationship"
  timing_place: timing_pattern_timing_place
  "Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing."
  timing_place_id: uuid
  "end of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_end: date
  "start of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_start: date
  "An array relationship"
  vehicle_mode_on_scheduled_stop_point(
    "distinct select on columns"
    distinct_on: [service_pattern_vehicle_mode_on_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_vehicle_mode_on_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp
  ): [service_pattern_vehicle_mode_on_scheduled_stop_point!]!
  "An aggregate relationship"
  vehicle_mode_on_scheduled_stop_point_aggregate(
    "distinct select on columns"
    distinct_on: [service_pattern_vehicle_mode_on_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_vehicle_mode_on_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp
  ): service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate!
}

"aggregated selection of \"service_pattern.scheduled_stop_point\""
type service_pattern_scheduled_stop_point_aggregate {
  aggregate: service_pattern_scheduled_stop_point_aggregate_fields
  nodes: [service_pattern_scheduled_stop_point!]!
}

"aggregate fields of \"service_pattern.scheduled_stop_point\""
type service_pattern_scheduled_stop_point_aggregate_fields {
  avg: service_pattern_scheduled_stop_point_avg_fields
  count(columns: [service_pattern_scheduled_stop_point_select_column!], distinct: Boolean): Int!
  max: service_pattern_scheduled_stop_point_max_fields
  min: service_pattern_scheduled_stop_point_min_fields
  stddev: service_pattern_scheduled_stop_point_stddev_fields
  stddev_pop: service_pattern_scheduled_stop_point_stddev_pop_fields
  stddev_samp: service_pattern_scheduled_stop_point_stddev_samp_fields
  sum: service_pattern_scheduled_stop_point_sum_fields
  var_pop: service_pattern_scheduled_stop_point_var_pop_fields
  var_samp: service_pattern_scheduled_stop_point_var_samp_fields
  variance: service_pattern_scheduled_stop_point_variance_fields
}

"aggregate avg on columns"
type service_pattern_scheduled_stop_point_avg_fields {
  priority: Float
  "The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]."
  relative_distance_from_infrastructure_link_start: float8
}

"aggregate max on columns"
type service_pattern_scheduled_stop_point_max_fields {
  "The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code."
  label: String
  "The infrastructure link on which the stop is located."
  located_on_infrastructure_link_id: uuid
  priority: Int
  "The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]."
  relative_distance_from_infrastructure_link_start: float8
  "The ID of the scheduled stop point."
  scheduled_stop_point_id: uuid
  "Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing."
  timing_place_id: uuid
  "end of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_end: date
  "start of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_start: date
}

"aggregate min on columns"
type service_pattern_scheduled_stop_point_min_fields {
  "The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code."
  label: String
  "The infrastructure link on which the stop is located."
  located_on_infrastructure_link_id: uuid
  priority: Int
  "The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]."
  relative_distance_from_infrastructure_link_start: float8
  "The ID of the scheduled stop point."
  scheduled_stop_point_id: uuid
  "Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing."
  timing_place_id: uuid
  "end of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_end: date
  "start of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_start: date
}

"response of any mutation on the table \"service_pattern.scheduled_stop_point\""
type service_pattern_scheduled_stop_point_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [service_pattern_scheduled_stop_point!]!
}

"aggregate stddev on columns"
type service_pattern_scheduled_stop_point_stddev_fields {
  priority: Float
  "The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]."
  relative_distance_from_infrastructure_link_start: float8
}

"aggregate stddev_pop on columns"
type service_pattern_scheduled_stop_point_stddev_pop_fields {
  priority: Float
  "The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]."
  relative_distance_from_infrastructure_link_start: float8
}

"aggregate stddev_samp on columns"
type service_pattern_scheduled_stop_point_stddev_samp_fields {
  priority: Float
  "The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]."
  relative_distance_from_infrastructure_link_start: float8
}

"aggregate sum on columns"
type service_pattern_scheduled_stop_point_sum_fields {
  priority: Int
  "The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]."
  relative_distance_from_infrastructure_link_start: float8
}

"aggregate var_pop on columns"
type service_pattern_scheduled_stop_point_var_pop_fields {
  priority: Float
  "The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]."
  relative_distance_from_infrastructure_link_start: float8
}

"aggregate var_samp on columns"
type service_pattern_scheduled_stop_point_var_samp_fields {
  priority: Float
  "The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]."
  relative_distance_from_infrastructure_link_start: float8
}

"aggregate variance on columns"
type service_pattern_scheduled_stop_point_variance_fields {
  priority: Float
  "The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]."
  relative_distance_from_infrastructure_link_start: float8
}

"Which scheduled stop points are serviced by which vehicle modes?"
type service_pattern_vehicle_mode_on_scheduled_stop_point {
  "The scheduled stop point that is serviced by the vehicle mode."
  scheduled_stop_point_id: uuid!
  "The vehicle mode servicing the scheduled stop point."
  vehicle_mode: reusable_components_vehicle_mode_enum!
}

"aggregated selection of \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
type service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate {
  aggregate: service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate_fields
  nodes: [service_pattern_vehicle_mode_on_scheduled_stop_point!]!
}

"aggregate fields of \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
type service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate_fields {
  count(columns: [service_pattern_vehicle_mode_on_scheduled_stop_point_select_column!], distinct: Boolean): Int!
  max: service_pattern_vehicle_mode_on_scheduled_stop_point_max_fields
  min: service_pattern_vehicle_mode_on_scheduled_stop_point_min_fields
}

"aggregate max on columns"
type service_pattern_vehicle_mode_on_scheduled_stop_point_max_fields {
  "The scheduled stop point that is serviced by the vehicle mode."
  scheduled_stop_point_id: uuid
}

"aggregate min on columns"
type service_pattern_vehicle_mode_on_scheduled_stop_point_min_fields {
  "The scheduled stop point that is serviced by the vehicle mode."
  scheduled_stop_point_id: uuid
}

"response of any mutation on the table \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
type service_pattern_vehicle_mode_on_scheduled_stop_point_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [service_pattern_vehicle_mode_on_scheduled_stop_point!]!
}

type subscription_root {
  "fetch data from the table: \"hsl_route.legacy_hsl_municipality_code\""
  hsl_route_legacy_hsl_municipality_code(
    "distinct select on columns"
    distinct_on: [hsl_route_legacy_hsl_municipality_code_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [hsl_route_legacy_hsl_municipality_code_order_by!],
    "filter the rows returned"
    where: hsl_route_legacy_hsl_municipality_code_bool_exp
  ): [hsl_route_legacy_hsl_municipality_code!]!
  "fetch aggregated fields from the table: \"hsl_route.legacy_hsl_municipality_code\""
  hsl_route_legacy_hsl_municipality_code_aggregate(
    "distinct select on columns"
    distinct_on: [hsl_route_legacy_hsl_municipality_code_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [hsl_route_legacy_hsl_municipality_code_order_by!],
    "filter the rows returned"
    where: hsl_route_legacy_hsl_municipality_code_bool_exp
  ): hsl_route_legacy_hsl_municipality_code_aggregate!
  "fetch data from the table: \"hsl_route.legacy_hsl_municipality_code\" using primary key columns"
  hsl_route_legacy_hsl_municipality_code_by_pk(hsl_municipality: String!): hsl_route_legacy_hsl_municipality_code
  "fetch data from the table in a streaming manner: \"hsl_route.legacy_hsl_municipality_code\""
  hsl_route_legacy_hsl_municipality_code_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [hsl_route_legacy_hsl_municipality_code_stream_cursor_input]!,
    "filter the rows returned"
    where: hsl_route_legacy_hsl_municipality_code_bool_exp
  ): [hsl_route_legacy_hsl_municipality_code!]!
  "fetch data from the table: \"hsl_route.transport_target\""
  hsl_route_transport_target(
    "distinct select on columns"
    distinct_on: [hsl_route_transport_target_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [hsl_route_transport_target_order_by!],
    "filter the rows returned"
    where: hsl_route_transport_target_bool_exp
  ): [hsl_route_transport_target!]!
  "fetch aggregated fields from the table: \"hsl_route.transport_target\""
  hsl_route_transport_target_aggregate(
    "distinct select on columns"
    distinct_on: [hsl_route_transport_target_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [hsl_route_transport_target_order_by!],
    "filter the rows returned"
    where: hsl_route_transport_target_bool_exp
  ): hsl_route_transport_target_aggregate!
  "fetch data from the table: \"hsl_route.transport_target\" using primary key columns"
  hsl_route_transport_target_by_pk(transport_target: String!): hsl_route_transport_target
  "fetch data from the table in a streaming manner: \"hsl_route.transport_target\""
  hsl_route_transport_target_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [hsl_route_transport_target_stream_cursor_input]!,
    "filter the rows returned"
    where: hsl_route_transport_target_bool_exp
  ): [hsl_route_transport_target!]!
  "fetch data from the table: \"infrastructure_network.direction\""
  infrastructure_network_direction(
    "distinct select on columns"
    distinct_on: [infrastructure_network_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_direction_order_by!],
    "filter the rows returned"
    where: infrastructure_network_direction_bool_exp
  ): [infrastructure_network_direction!]!
  "fetch aggregated fields from the table: \"infrastructure_network.direction\""
  infrastructure_network_direction_aggregate(
    "distinct select on columns"
    distinct_on: [infrastructure_network_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_direction_order_by!],
    "filter the rows returned"
    where: infrastructure_network_direction_bool_exp
  ): infrastructure_network_direction_aggregate!
  "fetch data from the table: \"infrastructure_network.direction\" using primary key columns"
  infrastructure_network_direction_by_pk(value: String!): infrastructure_network_direction
  "fetch data from the table in a streaming manner: \"infrastructure_network.direction\""
  infrastructure_network_direction_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [infrastructure_network_direction_stream_cursor_input]!,
    "filter the rows returned"
    where: infrastructure_network_direction_bool_exp
  ): [infrastructure_network_direction!]!
  "fetch data from the table: \"infrastructure_network.external_source\""
  infrastructure_network_external_source(
    "distinct select on columns"
    distinct_on: [infrastructure_network_external_source_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_external_source_order_by!],
    "filter the rows returned"
    where: infrastructure_network_external_source_bool_exp
  ): [infrastructure_network_external_source!]!
  "fetch aggregated fields from the table: \"infrastructure_network.external_source\""
  infrastructure_network_external_source_aggregate(
    "distinct select on columns"
    distinct_on: [infrastructure_network_external_source_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_external_source_order_by!],
    "filter the rows returned"
    where: infrastructure_network_external_source_bool_exp
  ): infrastructure_network_external_source_aggregate!
  "fetch data from the table: \"infrastructure_network.external_source\" using primary key columns"
  infrastructure_network_external_source_by_pk(value: String!): infrastructure_network_external_source
  "fetch data from the table in a streaming manner: \"infrastructure_network.external_source\""
  infrastructure_network_external_source_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [infrastructure_network_external_source_stream_cursor_input]!,
    "filter the rows returned"
    where: infrastructure_network_external_source_bool_exp
  ): [infrastructure_network_external_source!]!
  "execute function \"infrastructure_network.find_point_direction_on_link\" which returns \"infrastructure_network.direction\""
  infrastructure_network_find_point_direction_on_link(
    "input parameters for function \"infrastructure_network_find_point_direction_on_link\""
    args: infrastructure_network_find_point_direction_on_link_args!,
    "distinct select on columns"
    distinct_on: [infrastructure_network_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_direction_order_by!],
    "filter the rows returned"
    where: infrastructure_network_direction_bool_exp
  ): [infrastructure_network_direction!]!
  "execute function \"infrastructure_network.find_point_direction_on_link\" and query aggregates on result of table type \"infrastructure_network.direction\""
  infrastructure_network_find_point_direction_on_link_aggregate(
    "input parameters for function \"infrastructure_network_find_point_direction_on_link_aggregate\""
    args: infrastructure_network_find_point_direction_on_link_args!,
    "distinct select on columns"
    distinct_on: [infrastructure_network_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_direction_order_by!],
    "filter the rows returned"
    where: infrastructure_network_direction_bool_exp
  ): infrastructure_network_direction_aggregate!
  "fetch data from the table: \"infrastructure_network.infrastructure_link\""
  infrastructure_network_infrastructure_link(
    "distinct select on columns"
    distinct_on: [infrastructure_network_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_infrastructure_link_bool_exp
  ): [infrastructure_network_infrastructure_link!]!
  "fetch aggregated fields from the table: \"infrastructure_network.infrastructure_link\""
  infrastructure_network_infrastructure_link_aggregate(
    "distinct select on columns"
    distinct_on: [infrastructure_network_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_infrastructure_link_bool_exp
  ): infrastructure_network_infrastructure_link_aggregate!
  "fetch data from the table: \"infrastructure_network.infrastructure_link\" using primary key columns"
  infrastructure_network_infrastructure_link_by_pk(
    "The ID of the infrastructure link."
    infrastructure_link_id: uuid!
  ): infrastructure_network_infrastructure_link
  "fetch data from the table in a streaming manner: \"infrastructure_network.infrastructure_link\""
  infrastructure_network_infrastructure_link_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [infrastructure_network_infrastructure_link_stream_cursor_input]!,
    "filter the rows returned"
    where: infrastructure_network_infrastructure_link_bool_exp
  ): [infrastructure_network_infrastructure_link!]!
  "execute function \"infrastructure_network.resolve_point_to_closest_link\" which returns \"infrastructure_network.infrastructure_link\""
  infrastructure_network_resolve_point_to_closest_link(
    "input parameters for function \"infrastructure_network_resolve_point_to_closest_link\""
    args: infrastructure_network_resolve_point_to_closest_link_args!,
    "distinct select on columns"
    distinct_on: [infrastructure_network_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_infrastructure_link_bool_exp
  ): [infrastructure_network_infrastructure_link!]!
  "execute function \"infrastructure_network.resolve_point_to_closest_link\" and query aggregates on result of table type \"infrastructure_network.infrastructure_link\""
  infrastructure_network_resolve_point_to_closest_link_aggregate(
    "input parameters for function \"infrastructure_network_resolve_point_to_closest_link_aggregate\""
    args: infrastructure_network_resolve_point_to_closest_link_args!,
    "distinct select on columns"
    distinct_on: [infrastructure_network_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_infrastructure_link_bool_exp
  ): infrastructure_network_infrastructure_link_aggregate!
  "fetch data from the table: \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
  infrastructure_network_vehicle_submode_on_infrastructure_link(
    "distinct select on columns"
    distinct_on: [infrastructure_network_vehicle_submode_on_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_vehicle_submode_on_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  ): [infrastructure_network_vehicle_submode_on_infrastructure_link!]!
  "fetch aggregated fields from the table: \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
  infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate(
    "distinct select on columns"
    distinct_on: [infrastructure_network_vehicle_submode_on_infrastructure_link_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [infrastructure_network_vehicle_submode_on_infrastructure_link_order_by!],
    "filter the rows returned"
    where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  ): infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate!
  "fetch data from the table: \"infrastructure_network.vehicle_submode_on_infrastructure_link\" using primary key columns"
  infrastructure_network_vehicle_submode_on_infrastructure_link_by_pk(
    "The infrastructure link that can be safely traversed by the vehicle submode."
    infrastructure_link_id: uuid!,
    "The vehicle submode that can safely traverse the infrastructure link."
    vehicle_submode: reusable_components_vehicle_submode_enum!
  ): infrastructure_network_vehicle_submode_on_infrastructure_link
  "fetch data from the table in a streaming manner: \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
  infrastructure_network_vehicle_submode_on_infrastructure_link_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [infrastructure_network_vehicle_submode_on_infrastructure_link_stream_cursor_input]!,
    "filter the rows returned"
    where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  ): [infrastructure_network_vehicle_submode_on_infrastructure_link!]!
  "execute function \"journey_pattern.check_infra_link_stop_refs_with_new_scheduled_stop_point\" which returns \"journey_pattern.journey_pattern\""
  journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point(
    "input parameters for function \"journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point\""
    args: journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point_args!,
    "distinct select on columns"
    distinct_on: [journey_pattern_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_journey_pattern_bool_exp
  ): [journey_pattern_journey_pattern!]!
  "execute function \"journey_pattern.check_infra_link_stop_refs_with_new_scheduled_stop_point\" and query aggregates on result of table type \"journey_pattern.journey_pattern\""
  journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point_aggregate(
    "input parameters for function \"journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point_aggregate\""
    args: journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point_args!,
    "distinct select on columns"
    distinct_on: [journey_pattern_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_journey_pattern_bool_exp
  ): journey_pattern_journey_pattern_aggregate!
  "fetch data from the table: \"journey_pattern.journey_pattern\""
  journey_pattern_journey_pattern(
    "distinct select on columns"
    distinct_on: [journey_pattern_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_journey_pattern_bool_exp
  ): [journey_pattern_journey_pattern!]!
  "fetch aggregated fields from the table: \"journey_pattern.journey_pattern\""
  journey_pattern_journey_pattern_aggregate(
    "distinct select on columns"
    distinct_on: [journey_pattern_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_journey_pattern_bool_exp
  ): journey_pattern_journey_pattern_aggregate!
  "fetch data from the table: \"journey_pattern.journey_pattern\" using primary key columns"
  journey_pattern_journey_pattern_by_pk(
    "The ID of the journey pattern."
    journey_pattern_id: uuid!
  ): journey_pattern_journey_pattern
  "fetch data from the table in a streaming manner: \"journey_pattern.journey_pattern\""
  journey_pattern_journey_pattern_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [journey_pattern_journey_pattern_stream_cursor_input]!,
    "filter the rows returned"
    where: journey_pattern_journey_pattern_bool_exp
  ): [journey_pattern_journey_pattern!]!
  "fetch data from the table: \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
  journey_pattern_scheduled_stop_point_in_journey_pattern(
    "distinct select on columns"
    distinct_on: [journey_pattern_scheduled_stop_point_in_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_scheduled_stop_point_in_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  ): [journey_pattern_scheduled_stop_point_in_journey_pattern!]!
  "fetch aggregated fields from the table: \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
  journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate(
    "distinct select on columns"
    distinct_on: [journey_pattern_scheduled_stop_point_in_journey_pattern_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [journey_pattern_scheduled_stop_point_in_journey_pattern_order_by!],
    "filter the rows returned"
    where: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  ): journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate!
  "fetch data from the table: \"journey_pattern.scheduled_stop_point_in_journey_pattern\" using primary key columns"
  journey_pattern_scheduled_stop_point_in_journey_pattern_by_pk(
    "The ID of the journey pattern."
    journey_pattern_id: uuid!,
    "The order of the scheduled stop point within the journey pattern."
    scheduled_stop_point_sequence: Int!
  ): journey_pattern_scheduled_stop_point_in_journey_pattern
  "fetch data from the table in a streaming manner: \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
  journey_pattern_scheduled_stop_point_in_journey_pattern_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [journey_pattern_scheduled_stop_point_in_journey_pattern_stream_cursor_input]!,
    "filter the rows returned"
    where: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  ): [journey_pattern_scheduled_stop_point_in_journey_pattern!]!
  "fetch data from the table: \"reusable_components.vehicle_mode\""
  reusable_components_vehicle_mode(
    "distinct select on columns"
    distinct_on: [reusable_components_vehicle_mode_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [reusable_components_vehicle_mode_order_by!],
    "filter the rows returned"
    where: reusable_components_vehicle_mode_bool_exp
  ): [reusable_components_vehicle_mode!]!
  "fetch aggregated fields from the table: \"reusable_components.vehicle_mode\""
  reusable_components_vehicle_mode_aggregate(
    "distinct select on columns"
    distinct_on: [reusable_components_vehicle_mode_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [reusable_components_vehicle_mode_order_by!],
    "filter the rows returned"
    where: reusable_components_vehicle_mode_bool_exp
  ): reusable_components_vehicle_mode_aggregate!
  "fetch data from the table: \"reusable_components.vehicle_mode\" using primary key columns"
  reusable_components_vehicle_mode_by_pk(
    "The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
    vehicle_mode: String!
  ): reusable_components_vehicle_mode
  "fetch data from the table in a streaming manner: \"reusable_components.vehicle_mode\""
  reusable_components_vehicle_mode_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [reusable_components_vehicle_mode_stream_cursor_input]!,
    "filter the rows returned"
    where: reusable_components_vehicle_mode_bool_exp
  ): [reusable_components_vehicle_mode!]!
  "fetch data from the table: \"reusable_components.vehicle_submode\""
  reusable_components_vehicle_submode(
    "distinct select on columns"
    distinct_on: [reusable_components_vehicle_submode_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [reusable_components_vehicle_submode_order_by!],
    "filter the rows returned"
    where: reusable_components_vehicle_submode_bool_exp
  ): [reusable_components_vehicle_submode!]!
  "fetch aggregated fields from the table: \"reusable_components.vehicle_submode\""
  reusable_components_vehicle_submode_aggregate(
    "distinct select on columns"
    distinct_on: [reusable_components_vehicle_submode_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [reusable_components_vehicle_submode_order_by!],
    "filter the rows returned"
    where: reusable_components_vehicle_submode_bool_exp
  ): reusable_components_vehicle_submode_aggregate!
  "fetch data from the table: \"reusable_components.vehicle_submode\" using primary key columns"
  reusable_components_vehicle_submode_by_pk(
    "The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse"
    vehicle_submode: String!
  ): reusable_components_vehicle_submode
  "fetch data from the table in a streaming manner: \"reusable_components.vehicle_submode\""
  reusable_components_vehicle_submode_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [reusable_components_vehicle_submode_stream_cursor_input]!,
    "filter the rows returned"
    where: reusable_components_vehicle_submode_bool_exp
  ): [reusable_components_vehicle_submode!]!
  "fetch data from the table: \"route.direction\""
  route_direction(
    "distinct select on columns"
    distinct_on: [route_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_direction_order_by!],
    "filter the rows returned"
    where: route_direction_bool_exp
  ): [route_direction!]!
  "fetch aggregated fields from the table: \"route.direction\""
  route_direction_aggregate(
    "distinct select on columns"
    distinct_on: [route_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_direction_order_by!],
    "filter the rows returned"
    where: route_direction_bool_exp
  ): route_direction_aggregate!
  "fetch data from the table: \"route.direction\" using primary key columns"
  route_direction_by_pk(
    "The name of the route direction."
    direction: String!
  ): route_direction
  "fetch data from the table in a streaming manner: \"route.direction\""
  route_direction_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [route_direction_stream_cursor_input]!,
    "filter the rows returned"
    where: route_direction_bool_exp
  ): [route_direction!]!
  "fetch data from the table: \"route.infrastructure_link_along_route\""
  route_infrastructure_link_along_route(
    "distinct select on columns"
    distinct_on: [route_infrastructure_link_along_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_infrastructure_link_along_route_order_by!],
    "filter the rows returned"
    where: route_infrastructure_link_along_route_bool_exp
  ): [route_infrastructure_link_along_route!]!
  "fetch aggregated fields from the table: \"route.infrastructure_link_along_route\""
  route_infrastructure_link_along_route_aggregate(
    "distinct select on columns"
    distinct_on: [route_infrastructure_link_along_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_infrastructure_link_along_route_order_by!],
    "filter the rows returned"
    where: route_infrastructure_link_along_route_bool_exp
  ): route_infrastructure_link_along_route_aggregate!
  "fetch data from the table: \"route.infrastructure_link_along_route\" using primary key columns"
  route_infrastructure_link_along_route_by_pk(
    "The order of the infrastructure link within the journey pattern."
    infrastructure_link_sequence: Int!,
    "The ID of the route."
    route_id: uuid!
  ): route_infrastructure_link_along_route
  "fetch data from the table in a streaming manner: \"route.infrastructure_link_along_route\""
  route_infrastructure_link_along_route_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [route_infrastructure_link_along_route_stream_cursor_input]!,
    "filter the rows returned"
    where: route_infrastructure_link_along_route_bool_exp
  ): [route_infrastructure_link_along_route!]!
  "fetch data from the table: \"route.line\""
  route_line(
    "distinct select on columns"
    distinct_on: [route_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_line_order_by!],
    "filter the rows returned"
    where: route_line_bool_exp
  ): [route_line!]!
  "fetch aggregated fields from the table: \"route.line\""
  route_line_aggregate(
    "distinct select on columns"
    distinct_on: [route_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_line_order_by!],
    "filter the rows returned"
    where: route_line_bool_exp
  ): route_line_aggregate!
  "fetch data from the table: \"route.line\" using primary key columns"
  route_line_by_pk(
    "The ID of the line."
    line_id: uuid!
  ): route_line
  "fetch data from the table in a streaming manner: \"route.line\""
  route_line_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [route_line_stream_cursor_input]!,
    "filter the rows returned"
    where: route_line_bool_exp
  ): [route_line!]!
  "fetch data from the table: \"route.route\""
  route_route(
    "distinct select on columns"
    distinct_on: [route_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_route_order_by!],
    "filter the rows returned"
    where: route_route_bool_exp
  ): [route_route!]!
  "fetch aggregated fields from the table: \"route.route\""
  route_route_aggregate(
    "distinct select on columns"
    distinct_on: [route_route_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_route_order_by!],
    "filter the rows returned"
    where: route_route_bool_exp
  ): route_route_aggregate!
  "fetch data from the table: \"route.route\" using primary key columns"
  route_route_by_pk(
    "The ID of the route."
    route_id: uuid!
  ): route_route
  "fetch data from the table in a streaming manner: \"route.route\""
  route_route_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [route_route_stream_cursor_input]!,
    "filter the rows returned"
    where: route_route_bool_exp
  ): [route_route!]!
  "fetch data from the table: \"route.type_of_line\""
  route_type_of_line(
    "distinct select on columns"
    distinct_on: [route_type_of_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_type_of_line_order_by!],
    "filter the rows returned"
    where: route_type_of_line_bool_exp
  ): [route_type_of_line!]!
  "fetch aggregated fields from the table: \"route.type_of_line\""
  route_type_of_line_aggregate(
    "distinct select on columns"
    distinct_on: [route_type_of_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [route_type_of_line_order_by!],
    "filter the rows returned"
    where: route_type_of_line_bool_exp
  ): route_type_of_line_aggregate!
  "fetch data from the table: \"route.type_of_line\" using primary key columns"
  route_type_of_line_by_pk(
    "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
    type_of_line: String!
  ): route_type_of_line
  "fetch data from the table in a streaming manner: \"route.type_of_line\""
  route_type_of_line_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [route_type_of_line_stream_cursor_input]!,
    "filter the rows returned"
    where: route_type_of_line_bool_exp
  ): [route_type_of_line!]!
  "fetch data from the table: \"service_pattern.distance_between_stops_calculation\""
  service_pattern_distance_between_stops_calculation(
    "distinct select on columns"
    distinct_on: [service_pattern_distance_between_stops_calculation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_distance_between_stops_calculation_order_by!],
    "filter the rows returned"
    where: service_pattern_distance_between_stops_calculation_bool_exp
  ): [service_pattern_distance_between_stops_calculation!]!
  "fetch aggregated fields from the table: \"service_pattern.distance_between_stops_calculation\""
  service_pattern_distance_between_stops_calculation_aggregate(
    "distinct select on columns"
    distinct_on: [service_pattern_distance_between_stops_calculation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_distance_between_stops_calculation_order_by!],
    "filter the rows returned"
    where: service_pattern_distance_between_stops_calculation_bool_exp
  ): service_pattern_distance_between_stops_calculation_aggregate!
  "fetch data from the table: \"service_pattern.distance_between_stops_calculation\" using primary key columns"
  service_pattern_distance_between_stops_calculation_by_pk(
    "The ID of the journey pattern."
    journey_pattern_id: uuid!,
    "The observation date for the state of the route related to the journey pattern."
    observation_date: date!,
    "The priority of the route related to the journey pattern."
    route_priority: Int!,
    "The sequence number of the stop interval within the journey pattern."
    stop_interval_sequence: Int!
  ): service_pattern_distance_between_stops_calculation
  "fetch data from the table in a streaming manner: \"service_pattern.distance_between_stops_calculation\""
  service_pattern_distance_between_stops_calculation_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [service_pattern_distance_between_stops_calculation_stream_cursor_input]!,
    "filter the rows returned"
    where: service_pattern_distance_between_stops_calculation_bool_exp
  ): [service_pattern_distance_between_stops_calculation!]!
  "execute function \"service_pattern.get_distances_between_stop_points_by_routes\" which returns \"service_pattern.distance_between_stops_calculation\""
  service_pattern_get_distances_between_stop_points_by_routes(
    "input parameters for function \"service_pattern_get_distances_between_stop_points_by_routes\""
    args: service_pattern_get_distances_between_stop_points_by_routes_args!,
    "distinct select on columns"
    distinct_on: [service_pattern_distance_between_stops_calculation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_distance_between_stops_calculation_order_by!],
    "filter the rows returned"
    where: service_pattern_distance_between_stops_calculation_bool_exp
  ): [service_pattern_distance_between_stops_calculation!]!
  "execute function \"service_pattern.get_distances_between_stop_points_by_routes\" and query aggregates on result of table type \"service_pattern.distance_between_stops_calculation\""
  service_pattern_get_distances_between_stop_points_by_routes_aggregate(
    "input parameters for function \"service_pattern_get_distances_between_stop_points_by_routes_aggregate\""
    args: service_pattern_get_distances_between_stop_points_by_routes_args!,
    "distinct select on columns"
    distinct_on: [service_pattern_distance_between_stops_calculation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_distance_between_stops_calculation_order_by!],
    "filter the rows returned"
    where: service_pattern_distance_between_stops_calculation_bool_exp
  ): service_pattern_distance_between_stops_calculation_aggregate!
  "execute function \"service_pattern.get_distances_between_stop_points_in_journey_patterns\" which returns \"service_pattern.distance_between_stops_calculation\""
  service_pattern_get_distances_between_stop_points_in_journey_patterns(
    "input parameters for function \"service_pattern_get_distances_between_stop_points_in_journey_patterns\""
    args: service_pattern_get_distances_between_stop_points_in_journey_patterns_args!,
    "distinct select on columns"
    distinct_on: [service_pattern_distance_between_stops_calculation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_distance_between_stops_calculation_order_by!],
    "filter the rows returned"
    where: service_pattern_distance_between_stops_calculation_bool_exp
  ): [service_pattern_distance_between_stops_calculation!]!
  "execute function \"service_pattern.get_distances_between_stop_points_in_journey_patterns\" and query aggregates on result of table type \"service_pattern.distance_between_stops_calculation\""
  service_pattern_get_distances_between_stop_points_in_journey_patterns_aggregate(
    "input parameters for function \"service_pattern_get_distances_between_stop_points_in_journey_patterns_aggregate\""
    args: service_pattern_get_distances_between_stop_points_in_journey_patterns_args!,
    "distinct select on columns"
    distinct_on: [service_pattern_distance_between_stops_calculation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_distance_between_stops_calculation_order_by!],
    "filter the rows returned"
    where: service_pattern_distance_between_stops_calculation_bool_exp
  ): service_pattern_distance_between_stops_calculation_aggregate!
  "fetch data from the table: \"service_pattern.scheduled_stop_point\""
  service_pattern_scheduled_stop_point(
    "distinct select on columns"
    distinct_on: [service_pattern_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): [service_pattern_scheduled_stop_point!]!
  "fetch aggregated fields from the table: \"service_pattern.scheduled_stop_point\""
  service_pattern_scheduled_stop_point_aggregate(
    "distinct select on columns"
    distinct_on: [service_pattern_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): service_pattern_scheduled_stop_point_aggregate!
  "fetch data from the table: \"service_pattern.scheduled_stop_point\" using primary key columns"
  service_pattern_scheduled_stop_point_by_pk(
    "The ID of the scheduled stop point."
    scheduled_stop_point_id: uuid!
  ): service_pattern_scheduled_stop_point
  "fetch data from the table in a streaming manner: \"service_pattern.scheduled_stop_point\""
  service_pattern_scheduled_stop_point_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [service_pattern_scheduled_stop_point_stream_cursor_input]!,
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): [service_pattern_scheduled_stop_point!]!
  "fetch data from the table: \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
  service_pattern_vehicle_mode_on_scheduled_stop_point(
    "distinct select on columns"
    distinct_on: [service_pattern_vehicle_mode_on_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_vehicle_mode_on_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp
  ): [service_pattern_vehicle_mode_on_scheduled_stop_point!]!
  "fetch aggregated fields from the table: \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
  service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate(
    "distinct select on columns"
    distinct_on: [service_pattern_vehicle_mode_on_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_vehicle_mode_on_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp
  ): service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate!
  "fetch data from the table: \"service_pattern.vehicle_mode_on_scheduled_stop_point\" using primary key columns"
  service_pattern_vehicle_mode_on_scheduled_stop_point_by_pk(
    "The scheduled stop point that is serviced by the vehicle mode."
    scheduled_stop_point_id: uuid!,
    "The vehicle mode servicing the scheduled stop point."
    vehicle_mode: reusable_components_vehicle_mode_enum!
  ): service_pattern_vehicle_mode_on_scheduled_stop_point
  "fetch data from the table in a streaming manner: \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
  service_pattern_vehicle_mode_on_scheduled_stop_point_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [service_pattern_vehicle_mode_on_scheduled_stop_point_stream_cursor_input]!,
    "filter the rows returned"
    where: service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp
  ): [service_pattern_vehicle_mode_on_scheduled_stop_point!]!
  timetables: timetables_timetables_subscription
  "fetch data from the table: \"timing_pattern.timing_place\""
  timing_pattern_timing_place(
    "distinct select on columns"
    distinct_on: [timing_pattern_timing_place_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timing_pattern_timing_place_order_by!],
    "filter the rows returned"
    where: timing_pattern_timing_place_bool_exp
  ): [timing_pattern_timing_place!]!
  "fetch aggregated fields from the table: \"timing_pattern.timing_place\""
  timing_pattern_timing_place_aggregate(
    "distinct select on columns"
    distinct_on: [timing_pattern_timing_place_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timing_pattern_timing_place_order_by!],
    "filter the rows returned"
    where: timing_pattern_timing_place_bool_exp
  ): timing_pattern_timing_place_aggregate!
  "fetch data from the table: \"timing_pattern.timing_place\" using primary key columns"
  timing_pattern_timing_place_by_pk(timing_place_id: uuid!): timing_pattern_timing_place
  "fetch data from the table in a streaming manner: \"timing_pattern.timing_place\""
  timing_pattern_timing_place_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timing_pattern_timing_place_stream_cursor_input]!,
    "filter the rows returned"
    where: timing_pattern_timing_place_bool_exp
  ): [timing_pattern_timing_place!]!
}

"Reference to a given snapshot of a JOURNEY PATTERN for a given operating day. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729 "
type timetables_journey_pattern_journey_pattern_ref {
  "The ID of the referenced JOURNEY PATTERN"
  journey_pattern_id: uuid!
  journey_pattern_instance: journey_pattern_journey_pattern
  journey_pattern_ref_id: uuid!
  "The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning."
  observation_timestamp: timestamptz!
  "The direction of the route associated with the referenced journey pattern"
  route_direction: timetables_route_direction_enum!
  "The label of the route associated with the referenced journey pattern"
  route_label: String!
  "The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity)."
  route_validity_end: date
  "The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity)."
  route_validity_start: date
  "An array relationship"
  scheduled_stop_point_in_journey_pattern_refs(
    "distinct select on columns"
    distinct_on: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_order_by!],
    "filter the rows returned"
    where: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp
  ): [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref!]!
  "An aggregate relationship"
  scheduled_stop_point_in_journey_pattern_refs_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_order_by!],
    "filter the rows returned"
    where: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp
  ): timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate!
  "The timestamp when the snapshot was taken"
  snapshot_timestamp: timestamptz!
  "The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String!
  "An array relationship"
  vehicle_journeys(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_journey_vehicle_journey_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_journey_vehicle_journey_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_journey_vehicle_journey_bool_exp
  ): [timetables_vehicle_journey_vehicle_journey!]!
  "An aggregate relationship"
  vehicle_journeys_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_journey_vehicle_journey_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_journey_vehicle_journey_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_journey_vehicle_journey_bool_exp
  ): timetables_vehicle_journey_vehicle_journey_aggregate!
}

"aggregated selection of \"journey_pattern.journey_pattern_ref\""
type timetables_journey_pattern_journey_pattern_ref_aggregate {
  aggregate: timetables_journey_pattern_journey_pattern_ref_aggregate_fields
  nodes: [timetables_journey_pattern_journey_pattern_ref!]!
}

"aggregate fields of \"journey_pattern.journey_pattern_ref\""
type timetables_journey_pattern_journey_pattern_ref_aggregate_fields {
  count(columns: [timetables_journey_pattern_journey_pattern_ref_select_column!], distinct: Boolean): Int!
  max: timetables_journey_pattern_journey_pattern_ref_max_fields
  min: timetables_journey_pattern_journey_pattern_ref_min_fields
}

"aggregate max on columns"
type timetables_journey_pattern_journey_pattern_ref_max_fields {
  "The ID of the referenced JOURNEY PATTERN"
  journey_pattern_id: uuid
  journey_pattern_ref_id: uuid
  "The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning."
  observation_timestamp: timestamptz
  "The label of the route associated with the referenced journey pattern"
  route_label: String
  "The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity)."
  route_validity_end: date
  "The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity)."
  route_validity_start: date
  "The timestamp when the snapshot was taken"
  snapshot_timestamp: timestamptz
  "The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
}

"aggregate min on columns"
type timetables_journey_pattern_journey_pattern_ref_min_fields {
  "The ID of the referenced JOURNEY PATTERN"
  journey_pattern_id: uuid
  journey_pattern_ref_id: uuid
  "The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning."
  observation_timestamp: timestamptz
  "The label of the route associated with the referenced journey pattern"
  route_label: String
  "The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity)."
  route_validity_end: date
  "The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity)."
  route_validity_start: date
  "The timestamp when the snapshot was taken"
  snapshot_timestamp: timestamptz
  "The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
}

"response of any mutation on the table \"journey_pattern.journey_pattern_ref\""
type timetables_journey_pattern_journey_pattern_ref_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_journey_pattern_journey_pattern_ref!]!
}

"Long-term planned time data concerning public transport vehicles passing a particular POINT IN JOURNEY PATTERN on a specified VEHICLE JOURNEY for a certain DAY TYPE. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:4:946 "
type timetables_passing_times_timetabled_passing_time {
  "The time when the vehicle arrives to the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the departure time is defined for the passing time. E.g. in case this is the first SCHEDULED STOP POINT of the journey."
  arrival_time: interval
  "The time when the vehicle departs from the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the arrival time is defined for the passing time. E.g. in case this is the last SCHEDULED STOP POINT of the journey."
  departure_time: interval
  "The time when the vehicle can be considered as passing a SCHEDULED STOP POINT. Computed field to ease development; it can never be NULL."
  passing_time: interval!
  "An object relationship"
  scheduled_stop_point_in_journey_pattern_ref: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref!
  "The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes"
  scheduled_stop_point_in_journey_pattern_ref_id: uuid!
  timetabled_passing_time_id: uuid!
  "An object relationship"
  vehicle_journey: timetables_vehicle_journey_vehicle_journey!
  "The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs"
  vehicle_journey_id: uuid!
}

"aggregated selection of \"passing_times.timetabled_passing_time\""
type timetables_passing_times_timetabled_passing_time_aggregate {
  aggregate: timetables_passing_times_timetabled_passing_time_aggregate_fields
  nodes: [timetables_passing_times_timetabled_passing_time!]!
}

"aggregate fields of \"passing_times.timetabled_passing_time\""
type timetables_passing_times_timetabled_passing_time_aggregate_fields {
  count(columns: [timetables_passing_times_timetabled_passing_time_select_column!], distinct: Boolean): Int!
  max: timetables_passing_times_timetabled_passing_time_max_fields
  min: timetables_passing_times_timetabled_passing_time_min_fields
}

"aggregate max on columns"
type timetables_passing_times_timetabled_passing_time_max_fields {
  "The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes"
  scheduled_stop_point_in_journey_pattern_ref_id: uuid
  timetabled_passing_time_id: uuid
  "The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs"
  vehicle_journey_id: uuid
}

"aggregate min on columns"
type timetables_passing_times_timetabled_passing_time_min_fields {
  "The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes"
  scheduled_stop_point_in_journey_pattern_ref_id: uuid
  timetabled_passing_time_id: uuid
  "The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs"
  vehicle_journey_id: uuid
}

"response of any mutation on the table \"passing_times.timetabled_passing_time\""
type timetables_passing_times_timetabled_passing_time_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_passing_times_timetabled_passing_time!]!
}

"""
This return value is used for functions that determine what timetable versions are in effect. In effect will be true for all the timetable version rows that
are valid on given observation day and are the highest priority of that day type. As an example if we have:
Saturday Standard priority valid for 1.1.2023 - 30.6.2023
Saturday Temporary priority valid for 1.5.2023 - 31.5.2023
Saturday Special priority valid for 20.5.2023 - 20.5.2023

If we check the timetable versions for the date 1.2.2023, for Saturday we only get the Standard priority, beacuse it is the only one valid on that time. So that 
row would have in_effect = true. 
If we check the timetable versions for the date 1.5.2023, for Saturday we would get the Standard and the Temporary priority for this date, as they are both valid.
But only the higher priority is in effect on this date. So the Saturday Temporary priority would have in_effect = true, and the Saturday Standard priority would 
have in_effect = false.
If we check the timetable versions for the date 20.5.2023, for Saturday we have all three valid, but only one can be in_effect, and that would be the Special 
priority in this case.
"""
type timetables_return_value_timetable_version {
  "An object relationship"
  day_type: timetables_service_calendar_day_type
  day_type_id: uuid!
  in_effect: Boolean!
  priority: Int!
  "An object relationship"
  substitute_operating_day_by_line_type: timetables_service_calendar_substitute_operating_day_by_line_type
  substitute_operating_day_by_line_type_id: uuid
  validity_end: date!
  validity_start: date!
  "An object relationship"
  vehicle_schedule_frame: timetables_vehicle_schedule_vehicle_schedule_frame
  vehicle_schedule_frame_id: uuid
}

"aggregated selection of \"return_value.timetable_version\""
type timetables_return_value_timetable_version_aggregate {
  aggregate: timetables_return_value_timetable_version_aggregate_fields
  nodes: [timetables_return_value_timetable_version!]!
}

"aggregate fields of \"return_value.timetable_version\""
type timetables_return_value_timetable_version_aggregate_fields {
  avg: timetables_return_value_timetable_version_avg_fields
  count(columns: [timetables_return_value_timetable_version_select_column!], distinct: Boolean): Int!
  max: timetables_return_value_timetable_version_max_fields
  min: timetables_return_value_timetable_version_min_fields
  stddev: timetables_return_value_timetable_version_stddev_fields
  stddev_pop: timetables_return_value_timetable_version_stddev_pop_fields
  stddev_samp: timetables_return_value_timetable_version_stddev_samp_fields
  sum: timetables_return_value_timetable_version_sum_fields
  var_pop: timetables_return_value_timetable_version_var_pop_fields
  var_samp: timetables_return_value_timetable_version_var_samp_fields
  variance: timetables_return_value_timetable_version_variance_fields
}

"aggregate avg on columns"
type timetables_return_value_timetable_version_avg_fields {
  priority: Float
}

"aggregate max on columns"
type timetables_return_value_timetable_version_max_fields {
  day_type_id: uuid
  priority: Int
  substitute_operating_day_by_line_type_id: uuid
  validity_end: date
  validity_start: date
  vehicle_schedule_frame_id: uuid
}

"aggregate min on columns"
type timetables_return_value_timetable_version_min_fields {
  day_type_id: uuid
  priority: Int
  substitute_operating_day_by_line_type_id: uuid
  validity_end: date
  validity_start: date
  vehicle_schedule_frame_id: uuid
}

"response of any mutation on the table \"return_value.timetable_version\""
type timetables_return_value_timetable_version_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_return_value_timetable_version!]!
}

"aggregate stddev on columns"
type timetables_return_value_timetable_version_stddev_fields {
  priority: Float
}

"aggregate stddev_pop on columns"
type timetables_return_value_timetable_version_stddev_pop_fields {
  priority: Float
}

"aggregate stddev_samp on columns"
type timetables_return_value_timetable_version_stddev_samp_fields {
  priority: Float
}

"aggregate sum on columns"
type timetables_return_value_timetable_version_sum_fields {
  priority: Int
}

"aggregate var_pop on columns"
type timetables_return_value_timetable_version_var_pop_fields {
  priority: Float
}

"aggregate var_samp on columns"
type timetables_return_value_timetable_version_var_samp_fields {
  priority: Float
}

"aggregate variance on columns"
type timetables_return_value_timetable_version_variance_fields {
  priority: Float
}

"""
This return value table is used in function vehicle_journey.get_vehicle_schedules_on_date. It consists of vehicle_journey_id, vehicle_schedule_frame_id or
substitute_operating_day_by_line_type_id and also enriched with data, which are used in the UI side.
"""
type timetables_return_value_vehicle_schedule {
  created_at: timestamptz
  "An object relationship"
  day_type: timetables_service_calendar_day_type
  day_type_id: uuid!
  priority: Int!
  substitute_operating_day_by_line_type_id: uuid
  validity_end: date!
  validity_start: date!
  "An object relationship"
  vehicle_journey: timetables_vehicle_journey_vehicle_journey
  vehicle_journey_id: uuid
  vehicle_schedule_frame_id: uuid
}

"aggregated selection of \"return_value.vehicle_schedule\""
type timetables_return_value_vehicle_schedule_aggregate {
  aggregate: timetables_return_value_vehicle_schedule_aggregate_fields
  nodes: [timetables_return_value_vehicle_schedule!]!
}

"aggregate fields of \"return_value.vehicle_schedule\""
type timetables_return_value_vehicle_schedule_aggregate_fields {
  avg: timetables_return_value_vehicle_schedule_avg_fields
  count(columns: [timetables_return_value_vehicle_schedule_select_column!], distinct: Boolean): Int!
  max: timetables_return_value_vehicle_schedule_max_fields
  min: timetables_return_value_vehicle_schedule_min_fields
  stddev: timetables_return_value_vehicle_schedule_stddev_fields
  stddev_pop: timetables_return_value_vehicle_schedule_stddev_pop_fields
  stddev_samp: timetables_return_value_vehicle_schedule_stddev_samp_fields
  sum: timetables_return_value_vehicle_schedule_sum_fields
  var_pop: timetables_return_value_vehicle_schedule_var_pop_fields
  var_samp: timetables_return_value_vehicle_schedule_var_samp_fields
  variance: timetables_return_value_vehicle_schedule_variance_fields
}

"aggregate avg on columns"
type timetables_return_value_vehicle_schedule_avg_fields {
  priority: Float
}

"aggregate max on columns"
type timetables_return_value_vehicle_schedule_max_fields {
  created_at: timestamptz
  day_type_id: uuid
  priority: Int
  substitute_operating_day_by_line_type_id: uuid
  validity_end: date
  validity_start: date
  vehicle_journey_id: uuid
  vehicle_schedule_frame_id: uuid
}

"aggregate min on columns"
type timetables_return_value_vehicle_schedule_min_fields {
  created_at: timestamptz
  day_type_id: uuid
  priority: Int
  substitute_operating_day_by_line_type_id: uuid
  validity_end: date
  validity_start: date
  vehicle_journey_id: uuid
  vehicle_schedule_frame_id: uuid
}

"response of any mutation on the table \"return_value.vehicle_schedule\""
type timetables_return_value_vehicle_schedule_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_return_value_vehicle_schedule!]!
}

"aggregate stddev on columns"
type timetables_return_value_vehicle_schedule_stddev_fields {
  priority: Float
}

"aggregate stddev_pop on columns"
type timetables_return_value_vehicle_schedule_stddev_pop_fields {
  priority: Float
}

"aggregate stddev_samp on columns"
type timetables_return_value_vehicle_schedule_stddev_samp_fields {
  priority: Float
}

"aggregate sum on columns"
type timetables_return_value_vehicle_schedule_sum_fields {
  priority: Int
}

"aggregate var_pop on columns"
type timetables_return_value_vehicle_schedule_var_pop_fields {
  priority: Float
}

"aggregate var_samp on columns"
type timetables_return_value_vehicle_schedule_var_samp_fields {
  priority: Float
}

"aggregate variance on columns"
type timetables_return_value_vehicle_schedule_variance_fields {
  priority: Float
}

"The route directions from Transmodel"
type timetables_route_direction {
  "The name of the route direction"
  direction: String!
  "The opposite direction"
  the_opposite_of_direction: timetables_route_direction_enum
}

"aggregated selection of \"route.direction\""
type timetables_route_direction_aggregate {
  aggregate: timetables_route_direction_aggregate_fields
  nodes: [timetables_route_direction!]!
}

"aggregate fields of \"route.direction\""
type timetables_route_direction_aggregate_fields {
  count(columns: [timetables_route_direction_select_column!], distinct: Boolean): Int!
  max: timetables_route_direction_max_fields
  min: timetables_route_direction_min_fields
}

"aggregate max on columns"
type timetables_route_direction_max_fields {
  "The name of the route direction"
  direction: String
}

"aggregate min on columns"
type timetables_route_direction_min_fields {
  "The name of the route direction"
  direction: String
}

"response of any mutation on the table \"route.direction\""
type timetables_route_direction_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_route_direction!]!
}

"Type of line. https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:424"
type timetables_route_type_of_line {
  "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String!
}

"aggregated selection of \"route.type_of_line\""
type timetables_route_type_of_line_aggregate {
  aggregate: timetables_route_type_of_line_aggregate_fields
  nodes: [timetables_route_type_of_line!]!
}

"aggregate fields of \"route.type_of_line\""
type timetables_route_type_of_line_aggregate_fields {
  count(columns: [timetables_route_type_of_line_select_column!], distinct: Boolean): Int!
  max: timetables_route_type_of_line_max_fields
  min: timetables_route_type_of_line_min_fields
}

"aggregate max on columns"
type timetables_route_type_of_line_max_fields {
  "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
}

"aggregate min on columns"
type timetables_route_type_of_line_min_fields {
  "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
}

"response of any mutation on the table \"route.type_of_line\""
type timetables_route_type_of_line_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_route_type_of_line!]!
}

"A type of day characterised by one or more properties which affect public transport operation. For example: weekday in school holidays. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:3:299 "
type timetables_service_calendar_day_type {
  "An array relationship"
  active_on_days_of_week(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_day_type_active_on_day_of_week_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_day_type_active_on_day_of_week_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_day_type_active_on_day_of_week_bool_exp
  ): [timetables_service_calendar_day_type_active_on_day_of_week!]!
  "An aggregate relationship"
  active_on_days_of_week_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_day_type_active_on_day_of_week_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_day_type_active_on_day_of_week_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_day_type_active_on_day_of_week_bool_exp
  ): timetables_service_calendar_day_type_active_on_day_of_week_aggregate!
  day_type_id: uuid!
  "The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. \"Monday-Thursday\") and special (\"Easter Sunday\") day types"
  label: String!
  "Human-readable name for the DAY TYPE"
  name_i18n(
    "JSON select path"
    path: String
  ): jsonb!
  "An array relationship"
  vehicle_services(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_vehicle_service_bool_exp
  ): [timetables_vehicle_service_vehicle_service!]!
  "An aggregate relationship"
  vehicle_services_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_vehicle_service_bool_exp
  ): timetables_vehicle_service_vehicle_service_aggregate!
}

"Tells on which days of week a particular DAY TYPE is active"
type timetables_service_calendar_day_type_active_on_day_of_week {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Int!
  "An object relationship"
  day_type: timetables_service_calendar_day_type!
  "The DAY TYPE for which we define the activeness"
  day_type_id: uuid!
}

"aggregated selection of \"service_calendar.day_type_active_on_day_of_week\""
type timetables_service_calendar_day_type_active_on_day_of_week_aggregate {
  aggregate: timetables_service_calendar_day_type_active_on_day_of_week_aggregate_fields
  nodes: [timetables_service_calendar_day_type_active_on_day_of_week!]!
}

"aggregate fields of \"service_calendar.day_type_active_on_day_of_week\""
type timetables_service_calendar_day_type_active_on_day_of_week_aggregate_fields {
  avg: timetables_service_calendar_day_type_active_on_day_of_week_avg_fields
  count(columns: [timetables_service_calendar_day_type_active_on_day_of_week_select_column!], distinct: Boolean): Int!
  max: timetables_service_calendar_day_type_active_on_day_of_week_max_fields
  min: timetables_service_calendar_day_type_active_on_day_of_week_min_fields
  stddev: timetables_service_calendar_day_type_active_on_day_of_week_stddev_fields
  stddev_pop: timetables_service_calendar_day_type_active_on_day_of_week_stddev_pop_fields
  stddev_samp: timetables_service_calendar_day_type_active_on_day_of_week_stddev_samp_fields
  sum: timetables_service_calendar_day_type_active_on_day_of_week_sum_fields
  var_pop: timetables_service_calendar_day_type_active_on_day_of_week_var_pop_fields
  var_samp: timetables_service_calendar_day_type_active_on_day_of_week_var_samp_fields
  variance: timetables_service_calendar_day_type_active_on_day_of_week_variance_fields
}

"aggregate avg on columns"
type timetables_service_calendar_day_type_active_on_day_of_week_avg_fields {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Float
}

"aggregate max on columns"
type timetables_service_calendar_day_type_active_on_day_of_week_max_fields {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Int
  "The DAY TYPE for which we define the activeness"
  day_type_id: uuid
}

"aggregate min on columns"
type timetables_service_calendar_day_type_active_on_day_of_week_min_fields {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Int
  "The DAY TYPE for which we define the activeness"
  day_type_id: uuid
}

"response of any mutation on the table \"service_calendar.day_type_active_on_day_of_week\""
type timetables_service_calendar_day_type_active_on_day_of_week_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_service_calendar_day_type_active_on_day_of_week!]!
}

"aggregate stddev on columns"
type timetables_service_calendar_day_type_active_on_day_of_week_stddev_fields {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Float
}

"aggregate stddev_pop on columns"
type timetables_service_calendar_day_type_active_on_day_of_week_stddev_pop_fields {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Float
}

"aggregate stddev_samp on columns"
type timetables_service_calendar_day_type_active_on_day_of_week_stddev_samp_fields {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Float
}

"aggregate sum on columns"
type timetables_service_calendar_day_type_active_on_day_of_week_sum_fields {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Int
}

"aggregate var_pop on columns"
type timetables_service_calendar_day_type_active_on_day_of_week_var_pop_fields {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Float
}

"aggregate var_samp on columns"
type timetables_service_calendar_day_type_active_on_day_of_week_var_samp_fields {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Float
}

"aggregate variance on columns"
type timetables_service_calendar_day_type_active_on_day_of_week_variance_fields {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Float
}

"aggregated selection of \"service_calendar.day_type\""
type timetables_service_calendar_day_type_aggregate {
  aggregate: timetables_service_calendar_day_type_aggregate_fields
  nodes: [timetables_service_calendar_day_type!]!
}

"aggregate fields of \"service_calendar.day_type\""
type timetables_service_calendar_day_type_aggregate_fields {
  count(columns: [timetables_service_calendar_day_type_select_column!], distinct: Boolean): Int!
  max: timetables_service_calendar_day_type_max_fields
  min: timetables_service_calendar_day_type_min_fields
}

"aggregate max on columns"
type timetables_service_calendar_day_type_max_fields {
  day_type_id: uuid
  "The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. \"Monday-Thursday\") and special (\"Easter Sunday\") day types"
  label: String
}

"aggregate min on columns"
type timetables_service_calendar_day_type_min_fields {
  day_type_id: uuid
  "The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. \"Monday-Thursday\") and special (\"Easter Sunday\") day types"
  label: String
}

"response of any mutation on the table \"service_calendar.day_type\""
type timetables_service_calendar_day_type_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_service_calendar_day_type!]!
}

"Models substitute public transit as (1) a reference day or (2) indicating that public transit does not occur on certain date. Substitute operating days are always bound to a type of line."
type timetables_service_calendar_substitute_operating_day_by_line_type {
  "Calculated timestamp for the instant from which the substituting public transit comes into effect."
  begin_datetime: timestamptz!
  "The time from which the substituting public transit comes into effect. If NULL, the substitution is in effect from the start of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys prior to this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys before this time are operated as usual."
  begin_time: interval
  created_at: timestamptz!
  "Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect."
  end_datetime: timestamptz!
  "The time (exclusive) until which the substituting public transit is valid. If NULL, the substitution is in effect until the end of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys starting from this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys starting from this time are operated as usual."
  end_time: interval
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Int
  substitute_operating_day_by_line_type_id: uuid!
  "The id of the substitute operating period"
  substitute_operating_period_id: uuid!
  "The date of operating day being superseded."
  superseded_date: date!
  timezone: String!
  "The type of line this substitute operating day is bound to."
  type_of_line: String!
}

"aggregated selection of \"service_calendar.substitute_operating_day_by_line_type\""
type timetables_service_calendar_substitute_operating_day_by_line_type_aggregate {
  aggregate: timetables_service_calendar_substitute_operating_day_by_line_type_aggregate_fields
  nodes: [timetables_service_calendar_substitute_operating_day_by_line_type!]!
}

"aggregate fields of \"service_calendar.substitute_operating_day_by_line_type\""
type timetables_service_calendar_substitute_operating_day_by_line_type_aggregate_fields {
  avg: timetables_service_calendar_substitute_operating_day_by_line_type_avg_fields
  count(columns: [timetables_service_calendar_substitute_operating_day_by_line_type_select_column!], distinct: Boolean): Int!
  max: timetables_service_calendar_substitute_operating_day_by_line_type_max_fields
  min: timetables_service_calendar_substitute_operating_day_by_line_type_min_fields
  stddev: timetables_service_calendar_substitute_operating_day_by_line_type_stddev_fields
  stddev_pop: timetables_service_calendar_substitute_operating_day_by_line_type_stddev_pop_fields
  stddev_samp: timetables_service_calendar_substitute_operating_day_by_line_type_stddev_samp_fields
  sum: timetables_service_calendar_substitute_operating_day_by_line_type_sum_fields
  var_pop: timetables_service_calendar_substitute_operating_day_by_line_type_var_pop_fields
  var_samp: timetables_service_calendar_substitute_operating_day_by_line_type_var_samp_fields
  variance: timetables_service_calendar_substitute_operating_day_by_line_type_variance_fields
}

"aggregate avg on columns"
type timetables_service_calendar_substitute_operating_day_by_line_type_avg_fields {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Float
}

"aggregate max on columns"
type timetables_service_calendar_substitute_operating_day_by_line_type_max_fields {
  "Calculated timestamp for the instant from which the substituting public transit comes into effect."
  begin_datetime: timestamptz
  created_at: timestamptz
  "Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect."
  end_datetime: timestamptz
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Int
  substitute_operating_day_by_line_type_id: uuid
  "The id of the substitute operating period"
  substitute_operating_period_id: uuid
  "The date of operating day being superseded."
  superseded_date: date
  timezone: String
  "The type of line this substitute operating day is bound to."
  type_of_line: String
}

"aggregate min on columns"
type timetables_service_calendar_substitute_operating_day_by_line_type_min_fields {
  "Calculated timestamp for the instant from which the substituting public transit comes into effect."
  begin_datetime: timestamptz
  created_at: timestamptz
  "Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect."
  end_datetime: timestamptz
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Int
  substitute_operating_day_by_line_type_id: uuid
  "The id of the substitute operating period"
  substitute_operating_period_id: uuid
  "The date of operating day being superseded."
  superseded_date: date
  timezone: String
  "The type of line this substitute operating day is bound to."
  type_of_line: String
}

"response of any mutation on the table \"service_calendar.substitute_operating_day_by_line_type\""
type timetables_service_calendar_substitute_operating_day_by_line_type_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_service_calendar_substitute_operating_day_by_line_type!]!
}

"aggregate stddev on columns"
type timetables_service_calendar_substitute_operating_day_by_line_type_stddev_fields {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Float
}

"aggregate stddev_pop on columns"
type timetables_service_calendar_substitute_operating_day_by_line_type_stddev_pop_fields {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Float
}

"aggregate stddev_samp on columns"
type timetables_service_calendar_substitute_operating_day_by_line_type_stddev_samp_fields {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Float
}

"aggregate sum on columns"
type timetables_service_calendar_substitute_operating_day_by_line_type_sum_fields {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Int
}

"aggregate var_pop on columns"
type timetables_service_calendar_substitute_operating_day_by_line_type_var_pop_fields {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Float
}

"aggregate var_samp on columns"
type timetables_service_calendar_substitute_operating_day_by_line_type_var_samp_fields {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Float
}

"aggregate variance on columns"
type timetables_service_calendar_substitute_operating_day_by_line_type_variance_fields {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Float
}

"Models substitute operating period that consists of substitute operating days by line types."
type timetables_service_calendar_substitute_operating_period {
  "Flag indicating whether operating period is preset or not. Preset operating periods have restrictions on the UI"
  is_preset: Boolean!
  "Substitute operating period's name"
  period_name: String!
  "An array relationship"
  substitute_operating_day_by_line_types(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_substitute_operating_day_by_line_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_substitute_operating_day_by_line_type_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp
  ): [timetables_service_calendar_substitute_operating_day_by_line_type!]!
  "An aggregate relationship"
  substitute_operating_day_by_line_types_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_substitute_operating_day_by_line_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_substitute_operating_day_by_line_type_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp
  ): timetables_service_calendar_substitute_operating_day_by_line_type_aggregate!
  substitute_operating_period_id: uuid!
}

"aggregated selection of \"service_calendar.substitute_operating_period\""
type timetables_service_calendar_substitute_operating_period_aggregate {
  aggregate: timetables_service_calendar_substitute_operating_period_aggregate_fields
  nodes: [timetables_service_calendar_substitute_operating_period!]!
}

"aggregate fields of \"service_calendar.substitute_operating_period\""
type timetables_service_calendar_substitute_operating_period_aggregate_fields {
  count(columns: [timetables_service_calendar_substitute_operating_period_select_column!], distinct: Boolean): Int!
  max: timetables_service_calendar_substitute_operating_period_max_fields
  min: timetables_service_calendar_substitute_operating_period_min_fields
}

"aggregate max on columns"
type timetables_service_calendar_substitute_operating_period_max_fields {
  "Substitute operating period's name"
  period_name: String
  substitute_operating_period_id: uuid
}

"aggregate min on columns"
type timetables_service_calendar_substitute_operating_period_min_fields {
  "Substitute operating period's name"
  period_name: String
  substitute_operating_period_id: uuid
}

"response of any mutation on the table \"service_calendar.substitute_operating_period\""
type timetables_service_calendar_substitute_operating_period_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_service_calendar_substitute_operating_period!]!
}

"Reference the a SCHEDULED STOP POINT within a JOURNEY PATTERN. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729 "
type timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref {
  "An object relationship"
  journey_pattern_ref: timetables_journey_pattern_journey_pattern_ref!
  "JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs"
  journey_pattern_ref_id: uuid!
  scheduled_stop_point_in_journey_pattern_ref_id: uuid!
  scheduled_stop_point_instances(
    "distinct select on columns"
    distinct_on: [service_pattern_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): [service_pattern_scheduled_stop_point!]!
  scheduled_stop_point_instances_aggregate(
    "distinct select on columns"
    distinct_on: [service_pattern_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): service_pattern_scheduled_stop_point_aggregate!
  "The label of the SCHEDULED STOP POINT"
  scheduled_stop_point_label: String!
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Int!
  "An array relationship"
  timetabled_passing_times(
    "distinct select on columns"
    distinct_on: [timetables_passing_times_timetabled_passing_time_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_passing_times_timetabled_passing_time_order_by!],
    "filter the rows returned"
    where: timetables_passing_times_timetabled_passing_time_bool_exp
  ): [timetables_passing_times_timetabled_passing_time!]!
  "An aggregate relationship"
  timetabled_passing_times_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_passing_times_timetabled_passing_time_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_passing_times_timetabled_passing_time_order_by!],
    "filter the rows returned"
    where: timetables_passing_times_timetabled_passing_time_bool_exp
  ): timetables_passing_times_timetabled_passing_time_aggregate!
  "The label of the timing place associated with the referenced scheduled stop point in journey pattern"
  timing_place_label: String
}

"aggregated selection of \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
type timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate {
  aggregate: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate_fields
  nodes: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref!]!
}

"aggregate fields of \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
type timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate_fields {
  avg: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_avg_fields
  count(columns: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_select_column!], distinct: Boolean): Int!
  max: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_max_fields
  min: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_min_fields
  stddev: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_fields
  stddev_pop: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_pop_fields
  stddev_samp: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_samp_fields
  sum: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_sum_fields
  var_pop: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_var_pop_fields
  var_samp: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_var_samp_fields
  variance: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_variance_fields
}

"aggregate avg on columns"
type timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_avg_fields {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Float
}

"aggregate max on columns"
type timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_max_fields {
  "JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs"
  journey_pattern_ref_id: uuid
  scheduled_stop_point_in_journey_pattern_ref_id: uuid
  "The label of the SCHEDULED STOP POINT"
  scheduled_stop_point_label: String
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Int
  "The label of the timing place associated with the referenced scheduled stop point in journey pattern"
  timing_place_label: String
}

"aggregate min on columns"
type timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_min_fields {
  "JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs"
  journey_pattern_ref_id: uuid
  scheduled_stop_point_in_journey_pattern_ref_id: uuid
  "The label of the SCHEDULED STOP POINT"
  scheduled_stop_point_label: String
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Int
  "The label of the timing place associated with the referenced scheduled stop point in journey pattern"
  timing_place_label: String
}

"response of any mutation on the table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
type timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref!]!
}

"aggregate stddev on columns"
type timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_fields {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Float
}

"aggregate stddev_pop on columns"
type timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_pop_fields {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Float
}

"aggregate stddev_samp on columns"
type timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_samp_fields {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Float
}

"aggregate sum on columns"
type timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_sum_fields {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Int
}

"aggregate var_pop on columns"
type timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_var_pop_fields {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Float
}

"aggregate var_samp on columns"
type timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_var_samp_fields {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Float
}

"aggregate variance on columns"
type timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_variance_fields {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Float
}

type timetables_timetables_mutation_frontend {
  "delete data from the table: \"journey_pattern.journey_pattern_ref\""
  timetables_delete_journey_pattern_journey_pattern_ref(
    "filter the rows which have to be deleted"
    where: timetables_journey_pattern_journey_pattern_ref_bool_exp!
  ): timetables_journey_pattern_journey_pattern_ref_mutation_response
  "delete single row from the table: \"journey_pattern.journey_pattern_ref\""
  timetables_delete_journey_pattern_journey_pattern_ref_by_pk(journey_pattern_ref_id: uuid!): timetables_journey_pattern_journey_pattern_ref
  "delete data from the table: \"passing_times.timetabled_passing_time\""
  timetables_delete_passing_times_timetabled_passing_time(
    "filter the rows which have to be deleted"
    where: timetables_passing_times_timetabled_passing_time_bool_exp!
  ): timetables_passing_times_timetabled_passing_time_mutation_response
  "delete single row from the table: \"passing_times.timetabled_passing_time\""
  timetables_delete_passing_times_timetabled_passing_time_by_pk(timetabled_passing_time_id: uuid!): timetables_passing_times_timetabled_passing_time
  "delete data from the table: \"return_value.timetable_version\""
  timetables_delete_return_value_timetable_version(
    "filter the rows which have to be deleted"
    where: timetables_return_value_timetable_version_bool_exp!
  ): timetables_return_value_timetable_version_mutation_response
  "delete data from the table: \"return_value.vehicle_schedule\""
  timetables_delete_return_value_vehicle_schedule(
    "filter the rows which have to be deleted"
    where: timetables_return_value_vehicle_schedule_bool_exp!
  ): timetables_return_value_vehicle_schedule_mutation_response
  "delete data from the table: \"route.direction\""
  timetables_delete_route_direction(
    "filter the rows which have to be deleted"
    where: timetables_route_direction_bool_exp!
  ): timetables_route_direction_mutation_response
  "delete single row from the table: \"route.direction\""
  timetables_delete_route_direction_by_pk(
    "The name of the route direction"
    direction: String!
  ): timetables_route_direction
  "delete data from the table: \"route.type_of_line\""
  timetables_delete_route_type_of_line(
    "filter the rows which have to be deleted"
    where: timetables_route_type_of_line_bool_exp!
  ): timetables_route_type_of_line_mutation_response
  "delete single row from the table: \"route.type_of_line\""
  timetables_delete_route_type_of_line_by_pk(
    "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
    type_of_line: String!
  ): timetables_route_type_of_line
  "delete data from the table: \"service_calendar.day_type\""
  timetables_delete_service_calendar_day_type(
    "filter the rows which have to be deleted"
    where: timetables_service_calendar_day_type_bool_exp!
  ): timetables_service_calendar_day_type_mutation_response
  "delete data from the table: \"service_calendar.day_type_active_on_day_of_week\""
  timetables_delete_service_calendar_day_type_active_on_day_of_week(
    "filter the rows which have to be deleted"
    where: timetables_service_calendar_day_type_active_on_day_of_week_bool_exp!
  ): timetables_service_calendar_day_type_active_on_day_of_week_mutation_response
  "delete single row from the table: \"service_calendar.day_type_active_on_day_of_week\""
  timetables_delete_service_calendar_day_type_active_on_day_of_week_by_pk(
    "ISO week day definition (1 = Monday, 7 = Sunday)"
    day_of_week: Int!,
    "The DAY TYPE for which we define the activeness"
    day_type_id: uuid!
  ): timetables_service_calendar_day_type_active_on_day_of_week
  "delete single row from the table: \"service_calendar.day_type\""
  timetables_delete_service_calendar_day_type_by_pk(day_type_id: uuid!): timetables_service_calendar_day_type
  "delete data from the table: \"service_calendar.substitute_operating_day_by_line_type\""
  timetables_delete_service_calendar_substitute_operating_day_by_line_type(
    "filter the rows which have to be deleted"
    where: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp!
  ): timetables_service_calendar_substitute_operating_day_by_line_type_mutation_response
  "delete single row from the table: \"service_calendar.substitute_operating_day_by_line_type\""
  timetables_delete_service_calendar_substitute_operating_day_by_line_type_by_pk(substitute_operating_day_by_line_type_id: uuid!): timetables_service_calendar_substitute_operating_day_by_line_type
  "delete data from the table: \"service_calendar.substitute_operating_period\""
  timetables_delete_service_calendar_substitute_operating_period(
    "filter the rows which have to be deleted"
    where: timetables_service_calendar_substitute_operating_period_bool_exp!
  ): timetables_service_calendar_substitute_operating_period_mutation_response
  "delete single row from the table: \"service_calendar.substitute_operating_period\""
  timetables_delete_service_calendar_substitute_operating_period_by_pk(substitute_operating_period_id: uuid!): timetables_service_calendar_substitute_operating_period
  "delete data from the table: \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
  timetables_delete_service_pattern_scheduled_stop_point_in_journey_pattern_ref(
    "filter the rows which have to be deleted"
    where: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp!
  ): timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_mutation_response
  "delete single row from the table: \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
  timetables_delete_service_pattern_scheduled_stop_point_in_journey_pattern_ref_by_pk(scheduled_stop_point_in_journey_pattern_ref_id: uuid!): timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref
  "delete data from the table: \"vehicle_journey.vehicle_journey\""
  timetables_delete_vehicle_journey_vehicle_journey(
    "filter the rows which have to be deleted"
    where: timetables_vehicle_journey_vehicle_journey_bool_exp!
  ): timetables_vehicle_journey_vehicle_journey_mutation_response
  "delete single row from the table: \"vehicle_journey.vehicle_journey\""
  timetables_delete_vehicle_journey_vehicle_journey_by_pk(vehicle_journey_id: uuid!): timetables_vehicle_journey_vehicle_journey
  "delete data from the table: \"vehicle_schedule.vehicle_schedule_frame\""
  timetables_delete_vehicle_schedule_vehicle_schedule_frame(
    "filter the rows which have to be deleted"
    where: timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp!
  ): timetables_vehicle_schedule_vehicle_schedule_frame_mutation_response
  "delete single row from the table: \"vehicle_schedule.vehicle_schedule_frame\""
  timetables_delete_vehicle_schedule_vehicle_schedule_frame_by_pk(vehicle_schedule_frame_id: uuid!): timetables_vehicle_schedule_vehicle_schedule_frame
  "delete data from the table: \"vehicle_service.block\""
  timetables_delete_vehicle_service_block(
    "filter the rows which have to be deleted"
    where: timetables_vehicle_service_block_bool_exp!
  ): timetables_vehicle_service_block_mutation_response
  "delete single row from the table: \"vehicle_service.block\""
  timetables_delete_vehicle_service_block_by_pk(block_id: uuid!): timetables_vehicle_service_block
  "delete data from the table: \"vehicle_service.journey_patterns_in_vehicle_service\""
  timetables_delete_vehicle_service_journey_patterns_in_vehicle_service(
    "filter the rows which have to be deleted"
    where: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp!
  ): timetables_vehicle_service_journey_patterns_in_vehicle_service_mutation_response
  "delete single row from the table: \"vehicle_service.journey_patterns_in_vehicle_service\""
  timetables_delete_vehicle_service_journey_patterns_in_vehicle_service_by_pk(
    """
    The journey_pattern_id from journey_pattern.journey_pattern_ref.
     No foreign key reference is set because the target column is not unique.
    """
    journey_pattern_id: uuid!,
    vehicle_service_id: uuid!
  ): timetables_vehicle_service_journey_patterns_in_vehicle_service
  "delete data from the table: \"vehicle_service.vehicle_service\""
  timetables_delete_vehicle_service_vehicle_service(
    "filter the rows which have to be deleted"
    where: timetables_vehicle_service_vehicle_service_bool_exp!
  ): timetables_vehicle_service_vehicle_service_mutation_response
  "delete single row from the table: \"vehicle_service.vehicle_service\""
  timetables_delete_vehicle_service_vehicle_service_by_pk(vehicle_service_id: uuid!): timetables_vehicle_service_vehicle_service
  "delete data from the table: \"vehicle_type.vehicle_type\""
  timetables_delete_vehicle_type_vehicle_type(
    "filter the rows which have to be deleted"
    where: timetables_vehicle_type_vehicle_type_bool_exp!
  ): timetables_vehicle_type_vehicle_type_mutation_response
  "delete single row from the table: \"vehicle_type.vehicle_type\""
  timetables_delete_vehicle_type_vehicle_type_by_pk(vehicle_type_id: uuid!): timetables_vehicle_type_vehicle_type
  "insert data into the table: \"journey_pattern.journey_pattern_ref\""
  timetables_insert_journey_pattern_journey_pattern_ref(
    "the rows to be inserted"
    objects: [timetables_journey_pattern_journey_pattern_ref_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_journey_pattern_journey_pattern_ref_on_conflict
  ): timetables_journey_pattern_journey_pattern_ref_mutation_response
  "insert a single row into the table: \"journey_pattern.journey_pattern_ref\""
  timetables_insert_journey_pattern_journey_pattern_ref_one(
    "the row to be inserted"
    object: timetables_journey_pattern_journey_pattern_ref_insert_input!,
    "upsert condition"
    on_conflict: timetables_journey_pattern_journey_pattern_ref_on_conflict
  ): timetables_journey_pattern_journey_pattern_ref
  "insert data into the table: \"passing_times.timetabled_passing_time\""
  timetables_insert_passing_times_timetabled_passing_time(
    "the rows to be inserted"
    objects: [timetables_passing_times_timetabled_passing_time_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_passing_times_timetabled_passing_time_on_conflict
  ): timetables_passing_times_timetabled_passing_time_mutation_response
  "insert a single row into the table: \"passing_times.timetabled_passing_time\""
  timetables_insert_passing_times_timetabled_passing_time_one(
    "the row to be inserted"
    object: timetables_passing_times_timetabled_passing_time_insert_input!,
    "upsert condition"
    on_conflict: timetables_passing_times_timetabled_passing_time_on_conflict
  ): timetables_passing_times_timetabled_passing_time
  "insert data into the table: \"return_value.timetable_version\""
  timetables_insert_return_value_timetable_version(
    "the rows to be inserted"
    objects: [timetables_return_value_timetable_version_insert_input!]!
  ): timetables_return_value_timetable_version_mutation_response
  "insert a single row into the table: \"return_value.timetable_version\""
  timetables_insert_return_value_timetable_version_one(
    "the row to be inserted"
    object: timetables_return_value_timetable_version_insert_input!
  ): timetables_return_value_timetable_version
  "insert data into the table: \"return_value.vehicle_schedule\""
  timetables_insert_return_value_vehicle_schedule(
    "the rows to be inserted"
    objects: [timetables_return_value_vehicle_schedule_insert_input!]!
  ): timetables_return_value_vehicle_schedule_mutation_response
  "insert a single row into the table: \"return_value.vehicle_schedule\""
  timetables_insert_return_value_vehicle_schedule_one(
    "the row to be inserted"
    object: timetables_return_value_vehicle_schedule_insert_input!
  ): timetables_return_value_vehicle_schedule
  "insert data into the table: \"route.direction\""
  timetables_insert_route_direction(
    "the rows to be inserted"
    objects: [timetables_route_direction_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_route_direction_on_conflict
  ): timetables_route_direction_mutation_response
  "insert a single row into the table: \"route.direction\""
  timetables_insert_route_direction_one(
    "the row to be inserted"
    object: timetables_route_direction_insert_input!,
    "upsert condition"
    on_conflict: timetables_route_direction_on_conflict
  ): timetables_route_direction
  "insert data into the table: \"route.type_of_line\""
  timetables_insert_route_type_of_line(
    "the rows to be inserted"
    objects: [timetables_route_type_of_line_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_route_type_of_line_on_conflict
  ): timetables_route_type_of_line_mutation_response
  "insert a single row into the table: \"route.type_of_line\""
  timetables_insert_route_type_of_line_one(
    "the row to be inserted"
    object: timetables_route_type_of_line_insert_input!,
    "upsert condition"
    on_conflict: timetables_route_type_of_line_on_conflict
  ): timetables_route_type_of_line
  "insert data into the table: \"service_calendar.day_type\""
  timetables_insert_service_calendar_day_type(
    "the rows to be inserted"
    objects: [timetables_service_calendar_day_type_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_service_calendar_day_type_on_conflict
  ): timetables_service_calendar_day_type_mutation_response
  "insert data into the table: \"service_calendar.day_type_active_on_day_of_week\""
  timetables_insert_service_calendar_day_type_active_on_day_of_week(
    "the rows to be inserted"
    objects: [timetables_service_calendar_day_type_active_on_day_of_week_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_service_calendar_day_type_active_on_day_of_week_on_conflict
  ): timetables_service_calendar_day_type_active_on_day_of_week_mutation_response
  "insert a single row into the table: \"service_calendar.day_type_active_on_day_of_week\""
  timetables_insert_service_calendar_day_type_active_on_day_of_week_one(
    "the row to be inserted"
    object: timetables_service_calendar_day_type_active_on_day_of_week_insert_input!,
    "upsert condition"
    on_conflict: timetables_service_calendar_day_type_active_on_day_of_week_on_conflict
  ): timetables_service_calendar_day_type_active_on_day_of_week
  "insert a single row into the table: \"service_calendar.day_type\""
  timetables_insert_service_calendar_day_type_one(
    "the row to be inserted"
    object: timetables_service_calendar_day_type_insert_input!,
    "upsert condition"
    on_conflict: timetables_service_calendar_day_type_on_conflict
  ): timetables_service_calendar_day_type
  "insert data into the table: \"service_calendar.substitute_operating_day_by_line_type\""
  timetables_insert_service_calendar_substitute_operating_day_by_line_type(
    "the rows to be inserted"
    objects: [timetables_service_calendar_substitute_operating_day_by_line_type_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_service_calendar_substitute_operating_day_by_line_type_on_conflict
  ): timetables_service_calendar_substitute_operating_day_by_line_type_mutation_response
  "insert a single row into the table: \"service_calendar.substitute_operating_day_by_line_type\""
  timetables_insert_service_calendar_substitute_operating_day_by_line_type_one(
    "the row to be inserted"
    object: timetables_service_calendar_substitute_operating_day_by_line_type_insert_input!,
    "upsert condition"
    on_conflict: timetables_service_calendar_substitute_operating_day_by_line_type_on_conflict
  ): timetables_service_calendar_substitute_operating_day_by_line_type
  "insert data into the table: \"service_calendar.substitute_operating_period\""
  timetables_insert_service_calendar_substitute_operating_period(
    "the rows to be inserted"
    objects: [timetables_service_calendar_substitute_operating_period_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_service_calendar_substitute_operating_period_on_conflict
  ): timetables_service_calendar_substitute_operating_period_mutation_response
  "insert a single row into the table: \"service_calendar.substitute_operating_period\""
  timetables_insert_service_calendar_substitute_operating_period_one(
    "the row to be inserted"
    object: timetables_service_calendar_substitute_operating_period_insert_input!,
    "upsert condition"
    on_conflict: timetables_service_calendar_substitute_operating_period_on_conflict
  ): timetables_service_calendar_substitute_operating_period
  "insert data into the table: \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
  timetables_insert_service_pattern_scheduled_stop_point_in_journey_pattern_ref(
    "the rows to be inserted"
    objects: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_on_conflict
  ): timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_mutation_response
  "insert a single row into the table: \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
  timetables_insert_service_pattern_scheduled_stop_point_in_journey_pattern_ref_one(
    "the row to be inserted"
    object: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_insert_input!,
    "upsert condition"
    on_conflict: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_on_conflict
  ): timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref
  "insert data into the table: \"vehicle_journey.vehicle_journey\""
  timetables_insert_vehicle_journey_vehicle_journey(
    "the rows to be inserted"
    objects: [timetables_vehicle_journey_vehicle_journey_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_vehicle_journey_vehicle_journey_on_conflict
  ): timetables_vehicle_journey_vehicle_journey_mutation_response
  "insert a single row into the table: \"vehicle_journey.vehicle_journey\""
  timetables_insert_vehicle_journey_vehicle_journey_one(
    "the row to be inserted"
    object: timetables_vehicle_journey_vehicle_journey_insert_input!,
    "upsert condition"
    on_conflict: timetables_vehicle_journey_vehicle_journey_on_conflict
  ): timetables_vehicle_journey_vehicle_journey
  "insert data into the table: \"vehicle_schedule.vehicle_schedule_frame\""
  timetables_insert_vehicle_schedule_vehicle_schedule_frame(
    "the rows to be inserted"
    objects: [timetables_vehicle_schedule_vehicle_schedule_frame_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_vehicle_schedule_vehicle_schedule_frame_on_conflict
  ): timetables_vehicle_schedule_vehicle_schedule_frame_mutation_response
  "insert a single row into the table: \"vehicle_schedule.vehicle_schedule_frame\""
  timetables_insert_vehicle_schedule_vehicle_schedule_frame_one(
    "the row to be inserted"
    object: timetables_vehicle_schedule_vehicle_schedule_frame_insert_input!,
    "upsert condition"
    on_conflict: timetables_vehicle_schedule_vehicle_schedule_frame_on_conflict
  ): timetables_vehicle_schedule_vehicle_schedule_frame
  "insert data into the table: \"vehicle_service.block\""
  timetables_insert_vehicle_service_block(
    "the rows to be inserted"
    objects: [timetables_vehicle_service_block_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_vehicle_service_block_on_conflict
  ): timetables_vehicle_service_block_mutation_response
  "insert a single row into the table: \"vehicle_service.block\""
  timetables_insert_vehicle_service_block_one(
    "the row to be inserted"
    object: timetables_vehicle_service_block_insert_input!,
    "upsert condition"
    on_conflict: timetables_vehicle_service_block_on_conflict
  ): timetables_vehicle_service_block
  "insert data into the table: \"vehicle_service.journey_patterns_in_vehicle_service\""
  timetables_insert_vehicle_service_journey_patterns_in_vehicle_service(
    "the rows to be inserted"
    objects: [timetables_vehicle_service_journey_patterns_in_vehicle_service_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_vehicle_service_journey_patterns_in_vehicle_service_on_conflict
  ): timetables_vehicle_service_journey_patterns_in_vehicle_service_mutation_response
  "insert a single row into the table: \"vehicle_service.journey_patterns_in_vehicle_service\""
  timetables_insert_vehicle_service_journey_patterns_in_vehicle_service_one(
    "the row to be inserted"
    object: timetables_vehicle_service_journey_patterns_in_vehicle_service_insert_input!,
    "upsert condition"
    on_conflict: timetables_vehicle_service_journey_patterns_in_vehicle_service_on_conflict
  ): timetables_vehicle_service_journey_patterns_in_vehicle_service
  "insert data into the table: \"vehicle_service.vehicle_service\""
  timetables_insert_vehicle_service_vehicle_service(
    "the rows to be inserted"
    objects: [timetables_vehicle_service_vehicle_service_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_vehicle_service_vehicle_service_on_conflict
  ): timetables_vehicle_service_vehicle_service_mutation_response
  "insert a single row into the table: \"vehicle_service.vehicle_service\""
  timetables_insert_vehicle_service_vehicle_service_one(
    "the row to be inserted"
    object: timetables_vehicle_service_vehicle_service_insert_input!,
    "upsert condition"
    on_conflict: timetables_vehicle_service_vehicle_service_on_conflict
  ): timetables_vehicle_service_vehicle_service
  "insert data into the table: \"vehicle_type.vehicle_type\""
  timetables_insert_vehicle_type_vehicle_type(
    "the rows to be inserted"
    objects: [timetables_vehicle_type_vehicle_type_insert_input!]!,
    "upsert condition"
    on_conflict: timetables_vehicle_type_vehicle_type_on_conflict
  ): timetables_vehicle_type_vehicle_type_mutation_response
  "insert a single row into the table: \"vehicle_type.vehicle_type\""
  timetables_insert_vehicle_type_vehicle_type_one(
    "the row to be inserted"
    object: timetables_vehicle_type_vehicle_type_insert_input!,
    "upsert condition"
    on_conflict: timetables_vehicle_type_vehicle_type_on_conflict
  ): timetables_vehicle_type_vehicle_type
  "update data of the table: \"journey_pattern.journey_pattern_ref\""
  timetables_update_journey_pattern_journey_pattern_ref(
    "sets the columns of the filtered rows to the given values"
    _set: timetables_journey_pattern_journey_pattern_ref_set_input,
    "filter the rows which have to be updated"
    where: timetables_journey_pattern_journey_pattern_ref_bool_exp!
  ): timetables_journey_pattern_journey_pattern_ref_mutation_response
  "update single row of the table: \"journey_pattern.journey_pattern_ref\""
  timetables_update_journey_pattern_journey_pattern_ref_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: timetables_journey_pattern_journey_pattern_ref_set_input,
    pk_columns: timetables_journey_pattern_journey_pattern_ref_pk_columns_input!
  ): timetables_journey_pattern_journey_pattern_ref
  "update multiples rows of table: \"journey_pattern.journey_pattern_ref\""
  timetables_update_journey_pattern_journey_pattern_ref_many(
    "updates to execute, in order"
    updates: [timetables_journey_pattern_journey_pattern_ref_updates!]!
  ): [timetables_journey_pattern_journey_pattern_ref_mutation_response]
  "update data of the table: \"passing_times.timetabled_passing_time\""
  timetables_update_passing_times_timetabled_passing_time(
    "sets the columns of the filtered rows to the given values"
    _set: timetables_passing_times_timetabled_passing_time_set_input,
    "filter the rows which have to be updated"
    where: timetables_passing_times_timetabled_passing_time_bool_exp!
  ): timetables_passing_times_timetabled_passing_time_mutation_response
  "update single row of the table: \"passing_times.timetabled_passing_time\""
  timetables_update_passing_times_timetabled_passing_time_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: timetables_passing_times_timetabled_passing_time_set_input,
    pk_columns: timetables_passing_times_timetabled_passing_time_pk_columns_input!
  ): timetables_passing_times_timetabled_passing_time
  "update multiples rows of table: \"passing_times.timetabled_passing_time\""
  timetables_update_passing_times_timetabled_passing_time_many(
    "updates to execute, in order"
    updates: [timetables_passing_times_timetabled_passing_time_updates!]!
  ): [timetables_passing_times_timetabled_passing_time_mutation_response]
  "update data of the table: \"return_value.timetable_version\""
  timetables_update_return_value_timetable_version(
    "increments the numeric columns with given value of the filtered values"
    _inc: timetables_return_value_timetable_version_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_return_value_timetable_version_set_input,
    "filter the rows which have to be updated"
    where: timetables_return_value_timetable_version_bool_exp!
  ): timetables_return_value_timetable_version_mutation_response
  "update multiples rows of table: \"return_value.timetable_version\""
  timetables_update_return_value_timetable_version_many(
    "updates to execute, in order"
    updates: [timetables_return_value_timetable_version_updates!]!
  ): [timetables_return_value_timetable_version_mutation_response]
  "update data of the table: \"return_value.vehicle_schedule\""
  timetables_update_return_value_vehicle_schedule(
    "increments the numeric columns with given value of the filtered values"
    _inc: timetables_return_value_vehicle_schedule_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_return_value_vehicle_schedule_set_input,
    "filter the rows which have to be updated"
    where: timetables_return_value_vehicle_schedule_bool_exp!
  ): timetables_return_value_vehicle_schedule_mutation_response
  "update multiples rows of table: \"return_value.vehicle_schedule\""
  timetables_update_return_value_vehicle_schedule_many(
    "updates to execute, in order"
    updates: [timetables_return_value_vehicle_schedule_updates!]!
  ): [timetables_return_value_vehicle_schedule_mutation_response]
  "update data of the table: \"route.direction\""
  timetables_update_route_direction(
    "sets the columns of the filtered rows to the given values"
    _set: timetables_route_direction_set_input,
    "filter the rows which have to be updated"
    where: timetables_route_direction_bool_exp!
  ): timetables_route_direction_mutation_response
  "update single row of the table: \"route.direction\""
  timetables_update_route_direction_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: timetables_route_direction_set_input,
    pk_columns: timetables_route_direction_pk_columns_input!
  ): timetables_route_direction
  "update multiples rows of table: \"route.direction\""
  timetables_update_route_direction_many(
    "updates to execute, in order"
    updates: [timetables_route_direction_updates!]!
  ): [timetables_route_direction_mutation_response]
  "update data of the table: \"route.type_of_line\""
  timetables_update_route_type_of_line(
    "sets the columns of the filtered rows to the given values"
    _set: timetables_route_type_of_line_set_input,
    "filter the rows which have to be updated"
    where: timetables_route_type_of_line_bool_exp!
  ): timetables_route_type_of_line_mutation_response
  "update single row of the table: \"route.type_of_line\""
  timetables_update_route_type_of_line_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: timetables_route_type_of_line_set_input,
    pk_columns: timetables_route_type_of_line_pk_columns_input!
  ): timetables_route_type_of_line
  "update multiples rows of table: \"route.type_of_line\""
  timetables_update_route_type_of_line_many(
    "updates to execute, in order"
    updates: [timetables_route_type_of_line_updates!]!
  ): [timetables_route_type_of_line_mutation_response]
  "update data of the table: \"service_calendar.day_type\""
  timetables_update_service_calendar_day_type(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: timetables_service_calendar_day_type_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: timetables_service_calendar_day_type_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: timetables_service_calendar_day_type_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: timetables_service_calendar_day_type_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: timetables_service_calendar_day_type_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_service_calendar_day_type_set_input,
    "filter the rows which have to be updated"
    where: timetables_service_calendar_day_type_bool_exp!
  ): timetables_service_calendar_day_type_mutation_response
  "update data of the table: \"service_calendar.day_type_active_on_day_of_week\""
  timetables_update_service_calendar_day_type_active_on_day_of_week(
    "increments the numeric columns with given value of the filtered values"
    _inc: timetables_service_calendar_day_type_active_on_day_of_week_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_service_calendar_day_type_active_on_day_of_week_set_input,
    "filter the rows which have to be updated"
    where: timetables_service_calendar_day_type_active_on_day_of_week_bool_exp!
  ): timetables_service_calendar_day_type_active_on_day_of_week_mutation_response
  "update single row of the table: \"service_calendar.day_type_active_on_day_of_week\""
  timetables_update_service_calendar_day_type_active_on_day_of_week_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: timetables_service_calendar_day_type_active_on_day_of_week_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_service_calendar_day_type_active_on_day_of_week_set_input,
    pk_columns: timetables_service_calendar_day_type_active_on_day_of_week_pk_columns_input!
  ): timetables_service_calendar_day_type_active_on_day_of_week
  "update multiples rows of table: \"service_calendar.day_type_active_on_day_of_week\""
  timetables_update_service_calendar_day_type_active_on_day_of_week_many(
    "updates to execute, in order"
    updates: [timetables_service_calendar_day_type_active_on_day_of_week_updates!]!
  ): [timetables_service_calendar_day_type_active_on_day_of_week_mutation_response]
  "update single row of the table: \"service_calendar.day_type\""
  timetables_update_service_calendar_day_type_by_pk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: timetables_service_calendar_day_type_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: timetables_service_calendar_day_type_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: timetables_service_calendar_day_type_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: timetables_service_calendar_day_type_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: timetables_service_calendar_day_type_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_service_calendar_day_type_set_input,
    pk_columns: timetables_service_calendar_day_type_pk_columns_input!
  ): timetables_service_calendar_day_type
  "update multiples rows of table: \"service_calendar.day_type\""
  timetables_update_service_calendar_day_type_many(
    "updates to execute, in order"
    updates: [timetables_service_calendar_day_type_updates!]!
  ): [timetables_service_calendar_day_type_mutation_response]
  "update data of the table: \"service_calendar.substitute_operating_day_by_line_type\""
  timetables_update_service_calendar_substitute_operating_day_by_line_type(
    "increments the numeric columns with given value of the filtered values"
    _inc: timetables_service_calendar_substitute_operating_day_by_line_type_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_service_calendar_substitute_operating_day_by_line_type_set_input,
    "filter the rows which have to be updated"
    where: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp!
  ): timetables_service_calendar_substitute_operating_day_by_line_type_mutation_response
  "update single row of the table: \"service_calendar.substitute_operating_day_by_line_type\""
  timetables_update_service_calendar_substitute_operating_day_by_line_type_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: timetables_service_calendar_substitute_operating_day_by_line_type_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_service_calendar_substitute_operating_day_by_line_type_set_input,
    pk_columns: timetables_service_calendar_substitute_operating_day_by_line_type_pk_columns_input!
  ): timetables_service_calendar_substitute_operating_day_by_line_type
  "update multiples rows of table: \"service_calendar.substitute_operating_day_by_line_type\""
  timetables_update_service_calendar_substitute_operating_day_by_line_type_many(
    "updates to execute, in order"
    updates: [timetables_service_calendar_substitute_operating_day_by_line_type_updates!]!
  ): [timetables_service_calendar_substitute_operating_day_by_line_type_mutation_response]
  "update data of the table: \"service_calendar.substitute_operating_period\""
  timetables_update_service_calendar_substitute_operating_period(
    "sets the columns of the filtered rows to the given values"
    _set: timetables_service_calendar_substitute_operating_period_set_input,
    "filter the rows which have to be updated"
    where: timetables_service_calendar_substitute_operating_period_bool_exp!
  ): timetables_service_calendar_substitute_operating_period_mutation_response
  "update single row of the table: \"service_calendar.substitute_operating_period\""
  timetables_update_service_calendar_substitute_operating_period_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: timetables_service_calendar_substitute_operating_period_set_input,
    pk_columns: timetables_service_calendar_substitute_operating_period_pk_columns_input!
  ): timetables_service_calendar_substitute_operating_period
  "update multiples rows of table: \"service_calendar.substitute_operating_period\""
  timetables_update_service_calendar_substitute_operating_period_many(
    "updates to execute, in order"
    updates: [timetables_service_calendar_substitute_operating_period_updates!]!
  ): [timetables_service_calendar_substitute_operating_period_mutation_response]
  "update data of the table: \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
  timetables_update_service_pattern_scheduled_stop_point_in_journey_pattern_ref(
    "increments the numeric columns with given value of the filtered values"
    _inc: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_set_input,
    "filter the rows which have to be updated"
    where: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp!
  ): timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_mutation_response
  "update single row of the table: \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
  timetables_update_service_pattern_scheduled_stop_point_in_journey_pattern_ref_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_set_input,
    pk_columns: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_pk_columns_input!
  ): timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref
  "update multiples rows of table: \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
  timetables_update_service_pattern_scheduled_stop_point_in_journey_pattern_ref_many(
    "updates to execute, in order"
    updates: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_updates!]!
  ): [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_mutation_response]
  "update data of the table: \"vehicle_journey.vehicle_journey\""
  timetables_update_vehicle_journey_vehicle_journey(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: timetables_vehicle_journey_vehicle_journey_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: timetables_vehicle_journey_vehicle_journey_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: timetables_vehicle_journey_vehicle_journey_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: timetables_vehicle_journey_vehicle_journey_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: timetables_vehicle_journey_vehicle_journey_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_vehicle_journey_vehicle_journey_set_input,
    "filter the rows which have to be updated"
    where: timetables_vehicle_journey_vehicle_journey_bool_exp!
  ): timetables_vehicle_journey_vehicle_journey_mutation_response
  "update single row of the table: \"vehicle_journey.vehicle_journey\""
  timetables_update_vehicle_journey_vehicle_journey_by_pk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: timetables_vehicle_journey_vehicle_journey_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: timetables_vehicle_journey_vehicle_journey_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: timetables_vehicle_journey_vehicle_journey_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: timetables_vehicle_journey_vehicle_journey_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: timetables_vehicle_journey_vehicle_journey_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_vehicle_journey_vehicle_journey_set_input,
    pk_columns: timetables_vehicle_journey_vehicle_journey_pk_columns_input!
  ): timetables_vehicle_journey_vehicle_journey
  "update multiples rows of table: \"vehicle_journey.vehicle_journey\""
  timetables_update_vehicle_journey_vehicle_journey_many(
    "updates to execute, in order"
    updates: [timetables_vehicle_journey_vehicle_journey_updates!]!
  ): [timetables_vehicle_journey_vehicle_journey_mutation_response]
  "update data of the table: \"vehicle_schedule.vehicle_schedule_frame\""
  timetables_update_vehicle_schedule_vehicle_schedule_frame(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: timetables_vehicle_schedule_vehicle_schedule_frame_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: timetables_vehicle_schedule_vehicle_schedule_frame_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: timetables_vehicle_schedule_vehicle_schedule_frame_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: timetables_vehicle_schedule_vehicle_schedule_frame_delete_key_input,
    "increments the numeric columns with given value of the filtered values"
    _inc: timetables_vehicle_schedule_vehicle_schedule_frame_inc_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: timetables_vehicle_schedule_vehicle_schedule_frame_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_vehicle_schedule_vehicle_schedule_frame_set_input,
    "filter the rows which have to be updated"
    where: timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp!
  ): timetables_vehicle_schedule_vehicle_schedule_frame_mutation_response
  "update single row of the table: \"vehicle_schedule.vehicle_schedule_frame\""
  timetables_update_vehicle_schedule_vehicle_schedule_frame_by_pk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: timetables_vehicle_schedule_vehicle_schedule_frame_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: timetables_vehicle_schedule_vehicle_schedule_frame_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: timetables_vehicle_schedule_vehicle_schedule_frame_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: timetables_vehicle_schedule_vehicle_schedule_frame_delete_key_input,
    "increments the numeric columns with given value of the filtered values"
    _inc: timetables_vehicle_schedule_vehicle_schedule_frame_inc_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: timetables_vehicle_schedule_vehicle_schedule_frame_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_vehicle_schedule_vehicle_schedule_frame_set_input,
    pk_columns: timetables_vehicle_schedule_vehicle_schedule_frame_pk_columns_input!
  ): timetables_vehicle_schedule_vehicle_schedule_frame
  "update multiples rows of table: \"vehicle_schedule.vehicle_schedule_frame\""
  timetables_update_vehicle_schedule_vehicle_schedule_frame_many(
    "updates to execute, in order"
    updates: [timetables_vehicle_schedule_vehicle_schedule_frame_updates!]!
  ): [timetables_vehicle_schedule_vehicle_schedule_frame_mutation_response]
  "update data of the table: \"vehicle_service.block\""
  timetables_update_vehicle_service_block(
    "sets the columns of the filtered rows to the given values"
    _set: timetables_vehicle_service_block_set_input,
    "filter the rows which have to be updated"
    where: timetables_vehicle_service_block_bool_exp!
  ): timetables_vehicle_service_block_mutation_response
  "update single row of the table: \"vehicle_service.block\""
  timetables_update_vehicle_service_block_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: timetables_vehicle_service_block_set_input,
    pk_columns: timetables_vehicle_service_block_pk_columns_input!
  ): timetables_vehicle_service_block
  "update multiples rows of table: \"vehicle_service.block\""
  timetables_update_vehicle_service_block_many(
    "updates to execute, in order"
    updates: [timetables_vehicle_service_block_updates!]!
  ): [timetables_vehicle_service_block_mutation_response]
  "update data of the table: \"vehicle_service.journey_patterns_in_vehicle_service\""
  timetables_update_vehicle_service_journey_patterns_in_vehicle_service(
    "increments the numeric columns with given value of the filtered values"
    _inc: timetables_vehicle_service_journey_patterns_in_vehicle_service_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_vehicle_service_journey_patterns_in_vehicle_service_set_input,
    "filter the rows which have to be updated"
    where: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp!
  ): timetables_vehicle_service_journey_patterns_in_vehicle_service_mutation_response
  "update single row of the table: \"vehicle_service.journey_patterns_in_vehicle_service\""
  timetables_update_vehicle_service_journey_patterns_in_vehicle_service_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: timetables_vehicle_service_journey_patterns_in_vehicle_service_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_vehicle_service_journey_patterns_in_vehicle_service_set_input,
    pk_columns: timetables_vehicle_service_journey_patterns_in_vehicle_service_pk_columns_input!
  ): timetables_vehicle_service_journey_patterns_in_vehicle_service
  "update multiples rows of table: \"vehicle_service.journey_patterns_in_vehicle_service\""
  timetables_update_vehicle_service_journey_patterns_in_vehicle_service_many(
    "updates to execute, in order"
    updates: [timetables_vehicle_service_journey_patterns_in_vehicle_service_updates!]!
  ): [timetables_vehicle_service_journey_patterns_in_vehicle_service_mutation_response]
  "update data of the table: \"vehicle_service.vehicle_service\""
  timetables_update_vehicle_service_vehicle_service(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: timetables_vehicle_service_vehicle_service_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: timetables_vehicle_service_vehicle_service_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: timetables_vehicle_service_vehicle_service_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: timetables_vehicle_service_vehicle_service_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: timetables_vehicle_service_vehicle_service_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_vehicle_service_vehicle_service_set_input,
    "filter the rows which have to be updated"
    where: timetables_vehicle_service_vehicle_service_bool_exp!
  ): timetables_vehicle_service_vehicle_service_mutation_response
  "update single row of the table: \"vehicle_service.vehicle_service\""
  timetables_update_vehicle_service_vehicle_service_by_pk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: timetables_vehicle_service_vehicle_service_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: timetables_vehicle_service_vehicle_service_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: timetables_vehicle_service_vehicle_service_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: timetables_vehicle_service_vehicle_service_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: timetables_vehicle_service_vehicle_service_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_vehicle_service_vehicle_service_set_input,
    pk_columns: timetables_vehicle_service_vehicle_service_pk_columns_input!
  ): timetables_vehicle_service_vehicle_service
  "update multiples rows of table: \"vehicle_service.vehicle_service\""
  timetables_update_vehicle_service_vehicle_service_many(
    "updates to execute, in order"
    updates: [timetables_vehicle_service_vehicle_service_updates!]!
  ): [timetables_vehicle_service_vehicle_service_mutation_response]
  "update data of the table: \"vehicle_type.vehicle_type\""
  timetables_update_vehicle_type_vehicle_type(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: timetables_vehicle_type_vehicle_type_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: timetables_vehicle_type_vehicle_type_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: timetables_vehicle_type_vehicle_type_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: timetables_vehicle_type_vehicle_type_delete_key_input,
    "increments the numeric columns with given value of the filtered values"
    _inc: timetables_vehicle_type_vehicle_type_inc_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: timetables_vehicle_type_vehicle_type_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_vehicle_type_vehicle_type_set_input,
    "filter the rows which have to be updated"
    where: timetables_vehicle_type_vehicle_type_bool_exp!
  ): timetables_vehicle_type_vehicle_type_mutation_response
  "update single row of the table: \"vehicle_type.vehicle_type\""
  timetables_update_vehicle_type_vehicle_type_by_pk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: timetables_vehicle_type_vehicle_type_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: timetables_vehicle_type_vehicle_type_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: timetables_vehicle_type_vehicle_type_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: timetables_vehicle_type_vehicle_type_delete_key_input,
    "increments the numeric columns with given value of the filtered values"
    _inc: timetables_vehicle_type_vehicle_type_inc_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: timetables_vehicle_type_vehicle_type_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: timetables_vehicle_type_vehicle_type_set_input,
    pk_columns: timetables_vehicle_type_vehicle_type_pk_columns_input!
  ): timetables_vehicle_type_vehicle_type
  "update multiples rows of table: \"vehicle_type.vehicle_type\""
  timetables_update_vehicle_type_vehicle_type_many(
    "updates to execute, in order"
    updates: [timetables_vehicle_type_vehicle_type_updates!]!
  ): [timetables_vehicle_type_vehicle_type_mutation_response]
}

type timetables_timetables_query {
  "fetch data from the table: \"journey_pattern.journey_pattern_ref\""
  timetables_journey_pattern_journey_pattern_ref(
    "distinct select on columns"
    distinct_on: [timetables_journey_pattern_journey_pattern_ref_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_journey_pattern_journey_pattern_ref_order_by!],
    "filter the rows returned"
    where: timetables_journey_pattern_journey_pattern_ref_bool_exp
  ): [timetables_journey_pattern_journey_pattern_ref!]!
  "fetch aggregated fields from the table: \"journey_pattern.journey_pattern_ref\""
  timetables_journey_pattern_journey_pattern_ref_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_journey_pattern_journey_pattern_ref_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_journey_pattern_journey_pattern_ref_order_by!],
    "filter the rows returned"
    where: timetables_journey_pattern_journey_pattern_ref_bool_exp
  ): timetables_journey_pattern_journey_pattern_ref_aggregate!
  "fetch data from the table: \"journey_pattern.journey_pattern_ref\" using primary key columns"
  timetables_journey_pattern_journey_pattern_ref_by_pk(journey_pattern_ref_id: uuid!): timetables_journey_pattern_journey_pattern_ref
  "fetch data from the table: \"passing_times.timetabled_passing_time\""
  timetables_passing_times_timetabled_passing_time(
    "distinct select on columns"
    distinct_on: [timetables_passing_times_timetabled_passing_time_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_passing_times_timetabled_passing_time_order_by!],
    "filter the rows returned"
    where: timetables_passing_times_timetabled_passing_time_bool_exp
  ): [timetables_passing_times_timetabled_passing_time!]!
  "fetch aggregated fields from the table: \"passing_times.timetabled_passing_time\""
  timetables_passing_times_timetabled_passing_time_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_passing_times_timetabled_passing_time_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_passing_times_timetabled_passing_time_order_by!],
    "filter the rows returned"
    where: timetables_passing_times_timetabled_passing_time_bool_exp
  ): timetables_passing_times_timetabled_passing_time_aggregate!
  "fetch data from the table: \"passing_times.timetabled_passing_time\" using primary key columns"
  timetables_passing_times_timetabled_passing_time_by_pk(timetabled_passing_time_id: uuid!): timetables_passing_times_timetabled_passing_time
  "fetch data from the table: \"return_value.timetable_version\""
  timetables_return_value_timetable_version(
    "distinct select on columns"
    distinct_on: [timetables_return_value_timetable_version_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_timetable_version_order_by!],
    "filter the rows returned"
    where: timetables_return_value_timetable_version_bool_exp
  ): [timetables_return_value_timetable_version!]!
  "fetch aggregated fields from the table: \"return_value.timetable_version\""
  timetables_return_value_timetable_version_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_return_value_timetable_version_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_timetable_version_order_by!],
    "filter the rows returned"
    where: timetables_return_value_timetable_version_bool_exp
  ): timetables_return_value_timetable_version_aggregate!
  "fetch data from the table: \"return_value.vehicle_schedule\""
  timetables_return_value_vehicle_schedule(
    "distinct select on columns"
    distinct_on: [timetables_return_value_vehicle_schedule_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_vehicle_schedule_order_by!],
    "filter the rows returned"
    where: timetables_return_value_vehicle_schedule_bool_exp
  ): [timetables_return_value_vehicle_schedule!]!
  "fetch aggregated fields from the table: \"return_value.vehicle_schedule\""
  timetables_return_value_vehicle_schedule_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_return_value_vehicle_schedule_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_vehicle_schedule_order_by!],
    "filter the rows returned"
    where: timetables_return_value_vehicle_schedule_bool_exp
  ): timetables_return_value_vehicle_schedule_aggregate!
  "fetch data from the table: \"route.direction\""
  timetables_route_direction(
    "distinct select on columns"
    distinct_on: [timetables_route_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_route_direction_order_by!],
    "filter the rows returned"
    where: timetables_route_direction_bool_exp
  ): [timetables_route_direction!]!
  "fetch aggregated fields from the table: \"route.direction\""
  timetables_route_direction_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_route_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_route_direction_order_by!],
    "filter the rows returned"
    where: timetables_route_direction_bool_exp
  ): timetables_route_direction_aggregate!
  "fetch data from the table: \"route.direction\" using primary key columns"
  timetables_route_direction_by_pk(
    "The name of the route direction"
    direction: String!
  ): timetables_route_direction
  "fetch data from the table: \"route.type_of_line\""
  timetables_route_type_of_line(
    "distinct select on columns"
    distinct_on: [timetables_route_type_of_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_route_type_of_line_order_by!],
    "filter the rows returned"
    where: timetables_route_type_of_line_bool_exp
  ): [timetables_route_type_of_line!]!
  "fetch aggregated fields from the table: \"route.type_of_line\""
  timetables_route_type_of_line_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_route_type_of_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_route_type_of_line_order_by!],
    "filter the rows returned"
    where: timetables_route_type_of_line_bool_exp
  ): timetables_route_type_of_line_aggregate!
  "fetch data from the table: \"route.type_of_line\" using primary key columns"
  timetables_route_type_of_line_by_pk(
    "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
    type_of_line: String!
  ): timetables_route_type_of_line
  "fetch data from the table: \"service_calendar.day_type\""
  timetables_service_calendar_day_type(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_day_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_day_type_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_day_type_bool_exp
  ): [timetables_service_calendar_day_type!]!
  "fetch data from the table: \"service_calendar.day_type_active_on_day_of_week\""
  timetables_service_calendar_day_type_active_on_day_of_week(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_day_type_active_on_day_of_week_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_day_type_active_on_day_of_week_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_day_type_active_on_day_of_week_bool_exp
  ): [timetables_service_calendar_day_type_active_on_day_of_week!]!
  "fetch aggregated fields from the table: \"service_calendar.day_type_active_on_day_of_week\""
  timetables_service_calendar_day_type_active_on_day_of_week_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_day_type_active_on_day_of_week_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_day_type_active_on_day_of_week_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_day_type_active_on_day_of_week_bool_exp
  ): timetables_service_calendar_day_type_active_on_day_of_week_aggregate!
  "fetch data from the table: \"service_calendar.day_type_active_on_day_of_week\" using primary key columns"
  timetables_service_calendar_day_type_active_on_day_of_week_by_pk(
    "ISO week day definition (1 = Monday, 7 = Sunday)"
    day_of_week: Int!,
    "The DAY TYPE for which we define the activeness"
    day_type_id: uuid!
  ): timetables_service_calendar_day_type_active_on_day_of_week
  "fetch aggregated fields from the table: \"service_calendar.day_type\""
  timetables_service_calendar_day_type_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_day_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_day_type_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_day_type_bool_exp
  ): timetables_service_calendar_day_type_aggregate!
  "fetch data from the table: \"service_calendar.day_type\" using primary key columns"
  timetables_service_calendar_day_type_by_pk(day_type_id: uuid!): timetables_service_calendar_day_type
  "execute function \"service_calendar.get_active_day_types_for_date\" which returns \"service_calendar.day_type\""
  timetables_service_calendar_get_active_day_types_for_date(
    "input parameters for function \"service_calendar_get_active_day_types_for_date\""
    args: timetables_service_calendar_get_active_day_types_for_date_args!,
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_day_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_day_type_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_day_type_bool_exp
  ): [timetables_service_calendar_day_type!]!
  "execute function \"service_calendar.get_active_day_types_for_date\" and query aggregates on result of table type \"service_calendar.day_type\""
  timetables_service_calendar_get_active_day_types_for_date_aggregate(
    "input parameters for function \"service_calendar_get_active_day_types_for_date_aggregate\""
    args: timetables_service_calendar_get_active_day_types_for_date_args!,
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_day_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_day_type_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_day_type_bool_exp
  ): timetables_service_calendar_day_type_aggregate!
  "fetch data from the table: \"service_calendar.substitute_operating_day_by_line_type\""
  timetables_service_calendar_substitute_operating_day_by_line_type(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_substitute_operating_day_by_line_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_substitute_operating_day_by_line_type_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp
  ): [timetables_service_calendar_substitute_operating_day_by_line_type!]!
  "fetch aggregated fields from the table: \"service_calendar.substitute_operating_day_by_line_type\""
  timetables_service_calendar_substitute_operating_day_by_line_type_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_substitute_operating_day_by_line_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_substitute_operating_day_by_line_type_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp
  ): timetables_service_calendar_substitute_operating_day_by_line_type_aggregate!
  "fetch data from the table: \"service_calendar.substitute_operating_day_by_line_type\" using primary key columns"
  timetables_service_calendar_substitute_operating_day_by_line_type_by_pk(substitute_operating_day_by_line_type_id: uuid!): timetables_service_calendar_substitute_operating_day_by_line_type
  "fetch data from the table: \"service_calendar.substitute_operating_period\""
  timetables_service_calendar_substitute_operating_period(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_substitute_operating_period_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_substitute_operating_period_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_substitute_operating_period_bool_exp
  ): [timetables_service_calendar_substitute_operating_period!]!
  "fetch aggregated fields from the table: \"service_calendar.substitute_operating_period\""
  timetables_service_calendar_substitute_operating_period_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_substitute_operating_period_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_substitute_operating_period_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_substitute_operating_period_bool_exp
  ): timetables_service_calendar_substitute_operating_period_aggregate!
  "fetch data from the table: \"service_calendar.substitute_operating_period\" using primary key columns"
  timetables_service_calendar_substitute_operating_period_by_pk(substitute_operating_period_id: uuid!): timetables_service_calendar_substitute_operating_period
  "fetch data from the table: \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
  timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref(
    "distinct select on columns"
    distinct_on: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_order_by!],
    "filter the rows returned"
    where: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp
  ): [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref!]!
  "fetch aggregated fields from the table: \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
  timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_order_by!],
    "filter the rows returned"
    where: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp
  ): timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate!
  "fetch data from the table: \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\" using primary key columns"
  timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_by_pk(scheduled_stop_point_in_journey_pattern_ref_id: uuid!): timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref
  "execute function \"vehicle_journey.get_vehicle_schedules_on_date\" which returns \"return_value.vehicle_schedule\""
  timetables_vehicle_journey_get_vehicle_schedules_on_date(
    "input parameters for function \"vehicle_journey_get_vehicle_schedules_on_date\""
    args: timetables_vehicle_journey_get_vehicle_schedules_on_date_args!,
    "distinct select on columns"
    distinct_on: [timetables_return_value_vehicle_schedule_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_vehicle_schedule_order_by!],
    "filter the rows returned"
    where: timetables_return_value_vehicle_schedule_bool_exp
  ): [timetables_return_value_vehicle_schedule!]!
  "execute function \"vehicle_journey.get_vehicle_schedules_on_date\" and query aggregates on result of table type \"return_value.vehicle_schedule\""
  timetables_vehicle_journey_get_vehicle_schedules_on_date_aggregate(
    "input parameters for function \"vehicle_journey_get_vehicle_schedules_on_date_aggregate\""
    args: timetables_vehicle_journey_get_vehicle_schedules_on_date_args!,
    "distinct select on columns"
    distinct_on: [timetables_return_value_vehicle_schedule_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_vehicle_schedule_order_by!],
    "filter the rows returned"
    where: timetables_return_value_vehicle_schedule_bool_exp
  ): timetables_return_value_vehicle_schedule_aggregate!
  "fetch data from the table: \"vehicle_journey.vehicle_journey\""
  timetables_vehicle_journey_vehicle_journey(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_journey_vehicle_journey_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_journey_vehicle_journey_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_journey_vehicle_journey_bool_exp
  ): [timetables_vehicle_journey_vehicle_journey!]!
  "fetch aggregated fields from the table: \"vehicle_journey.vehicle_journey\""
  timetables_vehicle_journey_vehicle_journey_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_journey_vehicle_journey_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_journey_vehicle_journey_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_journey_vehicle_journey_bool_exp
  ): timetables_vehicle_journey_vehicle_journey_aggregate!
  "fetch data from the table: \"vehicle_journey.vehicle_journey\" using primary key columns"
  timetables_vehicle_journey_vehicle_journey_by_pk(vehicle_journey_id: uuid!): timetables_vehicle_journey_vehicle_journey
  "fetch data from the table: \"vehicle_schedule.vehicle_schedule_frame\""
  timetables_vehicle_schedule_vehicle_schedule_frame(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_schedule_vehicle_schedule_frame_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_schedule_vehicle_schedule_frame_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp
  ): [timetables_vehicle_schedule_vehicle_schedule_frame!]!
  "fetch aggregated fields from the table: \"vehicle_schedule.vehicle_schedule_frame\""
  timetables_vehicle_schedule_vehicle_schedule_frame_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_schedule_vehicle_schedule_frame_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_schedule_vehicle_schedule_frame_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp
  ): timetables_vehicle_schedule_vehicle_schedule_frame_aggregate!
  "fetch data from the table: \"vehicle_schedule.vehicle_schedule_frame\" using primary key columns"
  timetables_vehicle_schedule_vehicle_schedule_frame_by_pk(vehicle_schedule_frame_id: uuid!): timetables_vehicle_schedule_vehicle_schedule_frame
  "fetch data from the table: \"vehicle_service.block\""
  timetables_vehicle_service_block(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_block_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_block_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_block_bool_exp
  ): [timetables_vehicle_service_block!]!
  "fetch aggregated fields from the table: \"vehicle_service.block\""
  timetables_vehicle_service_block_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_block_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_block_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_block_bool_exp
  ): timetables_vehicle_service_block_aggregate!
  "fetch data from the table: \"vehicle_service.block\" using primary key columns"
  timetables_vehicle_service_block_by_pk(block_id: uuid!): timetables_vehicle_service_block
  "execute function \"vehicle_service.get_timetable_versions_by_journey_pattern_ids\" which returns \"return_value.timetable_version\""
  timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids(
    "input parameters for function \"vehicle_service_get_timetable_versions_by_journey_pattern_ids\""
    args: timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids_args!,
    "distinct select on columns"
    distinct_on: [timetables_return_value_timetable_version_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_timetable_version_order_by!],
    "filter the rows returned"
    where: timetables_return_value_timetable_version_bool_exp
  ): [timetables_return_value_timetable_version!]!
  "execute function \"vehicle_service.get_timetable_versions_by_journey_pattern_ids\" and query aggregates on result of table type \"return_value.timetable_version\""
  timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids_aggregate(
    "input parameters for function \"vehicle_service_get_timetable_versions_by_journey_pattern_ids_aggregate\""
    args: timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids_args!,
    "distinct select on columns"
    distinct_on: [timetables_return_value_timetable_version_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_timetable_version_order_by!],
    "filter the rows returned"
    where: timetables_return_value_timetable_version_bool_exp
  ): timetables_return_value_timetable_version_aggregate!
  "execute function \"vehicle_service.get_timetables_and_substitute_operating_days\" which returns \"return_value.timetable_version\""
  timetables_vehicle_service_get_timetables_and_substitute_operating_days(
    "input parameters for function \"vehicle_service_get_timetables_and_substitute_operating_days\""
    args: timetables_vehicle_service_get_timetables_and_substitute_operating_days_args!,
    "distinct select on columns"
    distinct_on: [timetables_return_value_timetable_version_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_timetable_version_order_by!],
    "filter the rows returned"
    where: timetables_return_value_timetable_version_bool_exp
  ): [timetables_return_value_timetable_version!]!
  "execute function \"vehicle_service.get_timetables_and_substitute_operating_days\" and query aggregates on result of table type \"return_value.timetable_version\""
  timetables_vehicle_service_get_timetables_and_substitute_operating_days_aggregate(
    "input parameters for function \"vehicle_service_get_timetables_and_substitute_operating_days_aggregate\""
    args: timetables_vehicle_service_get_timetables_and_substitute_operating_days_args!,
    "distinct select on columns"
    distinct_on: [timetables_return_value_timetable_version_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_timetable_version_order_by!],
    "filter the rows returned"
    where: timetables_return_value_timetable_version_bool_exp
  ): timetables_return_value_timetable_version_aggregate!
  "fetch data from the table: \"vehicle_service.journey_patterns_in_vehicle_service\""
  timetables_vehicle_service_journey_patterns_in_vehicle_service(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_journey_patterns_in_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_journey_patterns_in_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp
  ): [timetables_vehicle_service_journey_patterns_in_vehicle_service!]!
  "fetch aggregated fields from the table: \"vehicle_service.journey_patterns_in_vehicle_service\""
  timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_journey_patterns_in_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_journey_patterns_in_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp
  ): timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate!
  "fetch data from the table: \"vehicle_service.journey_patterns_in_vehicle_service\" using primary key columns"
  timetables_vehicle_service_journey_patterns_in_vehicle_service_by_pk(
    """
    The journey_pattern_id from journey_pattern.journey_pattern_ref.
     No foreign key reference is set because the target column is not unique.
    """
    journey_pattern_id: uuid!,
    vehicle_service_id: uuid!
  ): timetables_vehicle_service_journey_patterns_in_vehicle_service
  "fetch data from the table: \"vehicle_service.vehicle_service\""
  timetables_vehicle_service_vehicle_service(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_vehicle_service_bool_exp
  ): [timetables_vehicle_service_vehicle_service!]!
  "fetch aggregated fields from the table: \"vehicle_service.vehicle_service\""
  timetables_vehicle_service_vehicle_service_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_vehicle_service_bool_exp
  ): timetables_vehicle_service_vehicle_service_aggregate!
  "fetch data from the table: \"vehicle_service.vehicle_service\" using primary key columns"
  timetables_vehicle_service_vehicle_service_by_pk(vehicle_service_id: uuid!): timetables_vehicle_service_vehicle_service
  "fetch data from the table: \"vehicle_type.vehicle_type\""
  timetables_vehicle_type_vehicle_type(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_type_vehicle_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_type_vehicle_type_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_type_vehicle_type_bool_exp
  ): [timetables_vehicle_type_vehicle_type!]!
  "fetch aggregated fields from the table: \"vehicle_type.vehicle_type\""
  timetables_vehicle_type_vehicle_type_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_type_vehicle_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_type_vehicle_type_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_type_vehicle_type_bool_exp
  ): timetables_vehicle_type_vehicle_type_aggregate!
  "fetch data from the table: \"vehicle_type.vehicle_type\" using primary key columns"
  timetables_vehicle_type_vehicle_type_by_pk(vehicle_type_id: uuid!): timetables_vehicle_type_vehicle_type
}

type timetables_timetables_subscription {
  "fetch data from the table: \"journey_pattern.journey_pattern_ref\""
  timetables_journey_pattern_journey_pattern_ref(
    "distinct select on columns"
    distinct_on: [timetables_journey_pattern_journey_pattern_ref_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_journey_pattern_journey_pattern_ref_order_by!],
    "filter the rows returned"
    where: timetables_journey_pattern_journey_pattern_ref_bool_exp
  ): [timetables_journey_pattern_journey_pattern_ref!]!
  "fetch aggregated fields from the table: \"journey_pattern.journey_pattern_ref\""
  timetables_journey_pattern_journey_pattern_ref_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_journey_pattern_journey_pattern_ref_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_journey_pattern_journey_pattern_ref_order_by!],
    "filter the rows returned"
    where: timetables_journey_pattern_journey_pattern_ref_bool_exp
  ): timetables_journey_pattern_journey_pattern_ref_aggregate!
  "fetch data from the table: \"journey_pattern.journey_pattern_ref\" using primary key columns"
  timetables_journey_pattern_journey_pattern_ref_by_pk(journey_pattern_ref_id: uuid!): timetables_journey_pattern_journey_pattern_ref
  "fetch data from the table in a streaming manner: \"journey_pattern.journey_pattern_ref\""
  timetables_journey_pattern_journey_pattern_ref_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_journey_pattern_journey_pattern_ref_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_journey_pattern_journey_pattern_ref_bool_exp
  ): [timetables_journey_pattern_journey_pattern_ref!]!
  "fetch data from the table: \"passing_times.timetabled_passing_time\""
  timetables_passing_times_timetabled_passing_time(
    "distinct select on columns"
    distinct_on: [timetables_passing_times_timetabled_passing_time_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_passing_times_timetabled_passing_time_order_by!],
    "filter the rows returned"
    where: timetables_passing_times_timetabled_passing_time_bool_exp
  ): [timetables_passing_times_timetabled_passing_time!]!
  "fetch aggregated fields from the table: \"passing_times.timetabled_passing_time\""
  timetables_passing_times_timetabled_passing_time_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_passing_times_timetabled_passing_time_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_passing_times_timetabled_passing_time_order_by!],
    "filter the rows returned"
    where: timetables_passing_times_timetabled_passing_time_bool_exp
  ): timetables_passing_times_timetabled_passing_time_aggregate!
  "fetch data from the table: \"passing_times.timetabled_passing_time\" using primary key columns"
  timetables_passing_times_timetabled_passing_time_by_pk(timetabled_passing_time_id: uuid!): timetables_passing_times_timetabled_passing_time
  "fetch data from the table in a streaming manner: \"passing_times.timetabled_passing_time\""
  timetables_passing_times_timetabled_passing_time_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_passing_times_timetabled_passing_time_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_passing_times_timetabled_passing_time_bool_exp
  ): [timetables_passing_times_timetabled_passing_time!]!
  "fetch data from the table: \"return_value.timetable_version\""
  timetables_return_value_timetable_version(
    "distinct select on columns"
    distinct_on: [timetables_return_value_timetable_version_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_timetable_version_order_by!],
    "filter the rows returned"
    where: timetables_return_value_timetable_version_bool_exp
  ): [timetables_return_value_timetable_version!]!
  "fetch aggregated fields from the table: \"return_value.timetable_version\""
  timetables_return_value_timetable_version_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_return_value_timetable_version_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_timetable_version_order_by!],
    "filter the rows returned"
    where: timetables_return_value_timetable_version_bool_exp
  ): timetables_return_value_timetable_version_aggregate!
  "fetch data from the table in a streaming manner: \"return_value.timetable_version\""
  timetables_return_value_timetable_version_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_return_value_timetable_version_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_return_value_timetable_version_bool_exp
  ): [timetables_return_value_timetable_version!]!
  "fetch data from the table: \"return_value.vehicle_schedule\""
  timetables_return_value_vehicle_schedule(
    "distinct select on columns"
    distinct_on: [timetables_return_value_vehicle_schedule_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_vehicle_schedule_order_by!],
    "filter the rows returned"
    where: timetables_return_value_vehicle_schedule_bool_exp
  ): [timetables_return_value_vehicle_schedule!]!
  "fetch aggregated fields from the table: \"return_value.vehicle_schedule\""
  timetables_return_value_vehicle_schedule_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_return_value_vehicle_schedule_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_vehicle_schedule_order_by!],
    "filter the rows returned"
    where: timetables_return_value_vehicle_schedule_bool_exp
  ): timetables_return_value_vehicle_schedule_aggregate!
  "fetch data from the table in a streaming manner: \"return_value.vehicle_schedule\""
  timetables_return_value_vehicle_schedule_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_return_value_vehicle_schedule_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_return_value_vehicle_schedule_bool_exp
  ): [timetables_return_value_vehicle_schedule!]!
  "fetch data from the table: \"route.direction\""
  timetables_route_direction(
    "distinct select on columns"
    distinct_on: [timetables_route_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_route_direction_order_by!],
    "filter the rows returned"
    where: timetables_route_direction_bool_exp
  ): [timetables_route_direction!]!
  "fetch aggregated fields from the table: \"route.direction\""
  timetables_route_direction_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_route_direction_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_route_direction_order_by!],
    "filter the rows returned"
    where: timetables_route_direction_bool_exp
  ): timetables_route_direction_aggregate!
  "fetch data from the table: \"route.direction\" using primary key columns"
  timetables_route_direction_by_pk(
    "The name of the route direction"
    direction: String!
  ): timetables_route_direction
  "fetch data from the table in a streaming manner: \"route.direction\""
  timetables_route_direction_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_route_direction_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_route_direction_bool_exp
  ): [timetables_route_direction!]!
  "fetch data from the table: \"route.type_of_line\""
  timetables_route_type_of_line(
    "distinct select on columns"
    distinct_on: [timetables_route_type_of_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_route_type_of_line_order_by!],
    "filter the rows returned"
    where: timetables_route_type_of_line_bool_exp
  ): [timetables_route_type_of_line!]!
  "fetch aggregated fields from the table: \"route.type_of_line\""
  timetables_route_type_of_line_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_route_type_of_line_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_route_type_of_line_order_by!],
    "filter the rows returned"
    where: timetables_route_type_of_line_bool_exp
  ): timetables_route_type_of_line_aggregate!
  "fetch data from the table: \"route.type_of_line\" using primary key columns"
  timetables_route_type_of_line_by_pk(
    "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
    type_of_line: String!
  ): timetables_route_type_of_line
  "fetch data from the table in a streaming manner: \"route.type_of_line\""
  timetables_route_type_of_line_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_route_type_of_line_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_route_type_of_line_bool_exp
  ): [timetables_route_type_of_line!]!
  "fetch data from the table: \"service_calendar.day_type\""
  timetables_service_calendar_day_type(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_day_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_day_type_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_day_type_bool_exp
  ): [timetables_service_calendar_day_type!]!
  "fetch data from the table: \"service_calendar.day_type_active_on_day_of_week\""
  timetables_service_calendar_day_type_active_on_day_of_week(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_day_type_active_on_day_of_week_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_day_type_active_on_day_of_week_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_day_type_active_on_day_of_week_bool_exp
  ): [timetables_service_calendar_day_type_active_on_day_of_week!]!
  "fetch aggregated fields from the table: \"service_calendar.day_type_active_on_day_of_week\""
  timetables_service_calendar_day_type_active_on_day_of_week_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_day_type_active_on_day_of_week_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_day_type_active_on_day_of_week_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_day_type_active_on_day_of_week_bool_exp
  ): timetables_service_calendar_day_type_active_on_day_of_week_aggregate!
  "fetch data from the table: \"service_calendar.day_type_active_on_day_of_week\" using primary key columns"
  timetables_service_calendar_day_type_active_on_day_of_week_by_pk(
    "ISO week day definition (1 = Monday, 7 = Sunday)"
    day_of_week: Int!,
    "The DAY TYPE for which we define the activeness"
    day_type_id: uuid!
  ): timetables_service_calendar_day_type_active_on_day_of_week
  "fetch data from the table in a streaming manner: \"service_calendar.day_type_active_on_day_of_week\""
  timetables_service_calendar_day_type_active_on_day_of_week_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_service_calendar_day_type_active_on_day_of_week_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_service_calendar_day_type_active_on_day_of_week_bool_exp
  ): [timetables_service_calendar_day_type_active_on_day_of_week!]!
  "fetch aggregated fields from the table: \"service_calendar.day_type\""
  timetables_service_calendar_day_type_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_day_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_day_type_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_day_type_bool_exp
  ): timetables_service_calendar_day_type_aggregate!
  "fetch data from the table: \"service_calendar.day_type\" using primary key columns"
  timetables_service_calendar_day_type_by_pk(day_type_id: uuid!): timetables_service_calendar_day_type
  "fetch data from the table in a streaming manner: \"service_calendar.day_type\""
  timetables_service_calendar_day_type_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_service_calendar_day_type_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_service_calendar_day_type_bool_exp
  ): [timetables_service_calendar_day_type!]!
  "execute function \"service_calendar.get_active_day_types_for_date\" which returns \"service_calendar.day_type\""
  timetables_service_calendar_get_active_day_types_for_date(
    "input parameters for function \"service_calendar_get_active_day_types_for_date\""
    args: timetables_service_calendar_get_active_day_types_for_date_args!,
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_day_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_day_type_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_day_type_bool_exp
  ): [timetables_service_calendar_day_type!]!
  "execute function \"service_calendar.get_active_day_types_for_date\" and query aggregates on result of table type \"service_calendar.day_type\""
  timetables_service_calendar_get_active_day_types_for_date_aggregate(
    "input parameters for function \"service_calendar_get_active_day_types_for_date_aggregate\""
    args: timetables_service_calendar_get_active_day_types_for_date_args!,
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_day_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_day_type_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_day_type_bool_exp
  ): timetables_service_calendar_day_type_aggregate!
  "fetch data from the table: \"service_calendar.substitute_operating_day_by_line_type\""
  timetables_service_calendar_substitute_operating_day_by_line_type(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_substitute_operating_day_by_line_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_substitute_operating_day_by_line_type_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp
  ): [timetables_service_calendar_substitute_operating_day_by_line_type!]!
  "fetch aggregated fields from the table: \"service_calendar.substitute_operating_day_by_line_type\""
  timetables_service_calendar_substitute_operating_day_by_line_type_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_substitute_operating_day_by_line_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_substitute_operating_day_by_line_type_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp
  ): timetables_service_calendar_substitute_operating_day_by_line_type_aggregate!
  "fetch data from the table: \"service_calendar.substitute_operating_day_by_line_type\" using primary key columns"
  timetables_service_calendar_substitute_operating_day_by_line_type_by_pk(substitute_operating_day_by_line_type_id: uuid!): timetables_service_calendar_substitute_operating_day_by_line_type
  "fetch data from the table in a streaming manner: \"service_calendar.substitute_operating_day_by_line_type\""
  timetables_service_calendar_substitute_operating_day_by_line_type_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_service_calendar_substitute_operating_day_by_line_type_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp
  ): [timetables_service_calendar_substitute_operating_day_by_line_type!]!
  "fetch data from the table: \"service_calendar.substitute_operating_period\""
  timetables_service_calendar_substitute_operating_period(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_substitute_operating_period_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_substitute_operating_period_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_substitute_operating_period_bool_exp
  ): [timetables_service_calendar_substitute_operating_period!]!
  "fetch aggregated fields from the table: \"service_calendar.substitute_operating_period\""
  timetables_service_calendar_substitute_operating_period_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_service_calendar_substitute_operating_period_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_calendar_substitute_operating_period_order_by!],
    "filter the rows returned"
    where: timetables_service_calendar_substitute_operating_period_bool_exp
  ): timetables_service_calendar_substitute_operating_period_aggregate!
  "fetch data from the table: \"service_calendar.substitute_operating_period\" using primary key columns"
  timetables_service_calendar_substitute_operating_period_by_pk(substitute_operating_period_id: uuid!): timetables_service_calendar_substitute_operating_period
  "fetch data from the table in a streaming manner: \"service_calendar.substitute_operating_period\""
  timetables_service_calendar_substitute_operating_period_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_service_calendar_substitute_operating_period_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_service_calendar_substitute_operating_period_bool_exp
  ): [timetables_service_calendar_substitute_operating_period!]!
  "fetch data from the table: \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
  timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref(
    "distinct select on columns"
    distinct_on: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_order_by!],
    "filter the rows returned"
    where: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp
  ): [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref!]!
  "fetch aggregated fields from the table: \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
  timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_order_by!],
    "filter the rows returned"
    where: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp
  ): timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate!
  "fetch data from the table: \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\" using primary key columns"
  timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_by_pk(scheduled_stop_point_in_journey_pattern_ref_id: uuid!): timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref
  "fetch data from the table in a streaming manner: \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
  timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp
  ): [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref!]!
  "execute function \"vehicle_journey.get_vehicle_schedules_on_date\" which returns \"return_value.vehicle_schedule\""
  timetables_vehicle_journey_get_vehicle_schedules_on_date(
    "input parameters for function \"vehicle_journey_get_vehicle_schedules_on_date\""
    args: timetables_vehicle_journey_get_vehicle_schedules_on_date_args!,
    "distinct select on columns"
    distinct_on: [timetables_return_value_vehicle_schedule_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_vehicle_schedule_order_by!],
    "filter the rows returned"
    where: timetables_return_value_vehicle_schedule_bool_exp
  ): [timetables_return_value_vehicle_schedule!]!
  "execute function \"vehicle_journey.get_vehicle_schedules_on_date\" and query aggregates on result of table type \"return_value.vehicle_schedule\""
  timetables_vehicle_journey_get_vehicle_schedules_on_date_aggregate(
    "input parameters for function \"vehicle_journey_get_vehicle_schedules_on_date_aggregate\""
    args: timetables_vehicle_journey_get_vehicle_schedules_on_date_args!,
    "distinct select on columns"
    distinct_on: [timetables_return_value_vehicle_schedule_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_vehicle_schedule_order_by!],
    "filter the rows returned"
    where: timetables_return_value_vehicle_schedule_bool_exp
  ): timetables_return_value_vehicle_schedule_aggregate!
  "fetch data from the table: \"vehicle_journey.vehicle_journey\""
  timetables_vehicle_journey_vehicle_journey(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_journey_vehicle_journey_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_journey_vehicle_journey_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_journey_vehicle_journey_bool_exp
  ): [timetables_vehicle_journey_vehicle_journey!]!
  "fetch aggregated fields from the table: \"vehicle_journey.vehicle_journey\""
  timetables_vehicle_journey_vehicle_journey_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_journey_vehicle_journey_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_journey_vehicle_journey_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_journey_vehicle_journey_bool_exp
  ): timetables_vehicle_journey_vehicle_journey_aggregate!
  "fetch data from the table: \"vehicle_journey.vehicle_journey\" using primary key columns"
  timetables_vehicle_journey_vehicle_journey_by_pk(vehicle_journey_id: uuid!): timetables_vehicle_journey_vehicle_journey
  "fetch data from the table in a streaming manner: \"vehicle_journey.vehicle_journey\""
  timetables_vehicle_journey_vehicle_journey_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_vehicle_journey_vehicle_journey_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_vehicle_journey_vehicle_journey_bool_exp
  ): [timetables_vehicle_journey_vehicle_journey!]!
  "fetch data from the table: \"vehicle_schedule.vehicle_schedule_frame\""
  timetables_vehicle_schedule_vehicle_schedule_frame(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_schedule_vehicle_schedule_frame_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_schedule_vehicle_schedule_frame_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp
  ): [timetables_vehicle_schedule_vehicle_schedule_frame!]!
  "fetch aggregated fields from the table: \"vehicle_schedule.vehicle_schedule_frame\""
  timetables_vehicle_schedule_vehicle_schedule_frame_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_schedule_vehicle_schedule_frame_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_schedule_vehicle_schedule_frame_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp
  ): timetables_vehicle_schedule_vehicle_schedule_frame_aggregate!
  "fetch data from the table: \"vehicle_schedule.vehicle_schedule_frame\" using primary key columns"
  timetables_vehicle_schedule_vehicle_schedule_frame_by_pk(vehicle_schedule_frame_id: uuid!): timetables_vehicle_schedule_vehicle_schedule_frame
  "fetch data from the table in a streaming manner: \"vehicle_schedule.vehicle_schedule_frame\""
  timetables_vehicle_schedule_vehicle_schedule_frame_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_vehicle_schedule_vehicle_schedule_frame_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp
  ): [timetables_vehicle_schedule_vehicle_schedule_frame!]!
  "fetch data from the table: \"vehicle_service.block\""
  timetables_vehicle_service_block(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_block_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_block_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_block_bool_exp
  ): [timetables_vehicle_service_block!]!
  "fetch aggregated fields from the table: \"vehicle_service.block\""
  timetables_vehicle_service_block_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_block_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_block_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_block_bool_exp
  ): timetables_vehicle_service_block_aggregate!
  "fetch data from the table: \"vehicle_service.block\" using primary key columns"
  timetables_vehicle_service_block_by_pk(block_id: uuid!): timetables_vehicle_service_block
  "fetch data from the table in a streaming manner: \"vehicle_service.block\""
  timetables_vehicle_service_block_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_vehicle_service_block_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_vehicle_service_block_bool_exp
  ): [timetables_vehicle_service_block!]!
  "execute function \"vehicle_service.get_timetable_versions_by_journey_pattern_ids\" which returns \"return_value.timetable_version\""
  timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids(
    "input parameters for function \"vehicle_service_get_timetable_versions_by_journey_pattern_ids\""
    args: timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids_args!,
    "distinct select on columns"
    distinct_on: [timetables_return_value_timetable_version_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_timetable_version_order_by!],
    "filter the rows returned"
    where: timetables_return_value_timetable_version_bool_exp
  ): [timetables_return_value_timetable_version!]!
  "execute function \"vehicle_service.get_timetable_versions_by_journey_pattern_ids\" and query aggregates on result of table type \"return_value.timetable_version\""
  timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids_aggregate(
    "input parameters for function \"vehicle_service_get_timetable_versions_by_journey_pattern_ids_aggregate\""
    args: timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids_args!,
    "distinct select on columns"
    distinct_on: [timetables_return_value_timetable_version_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_timetable_version_order_by!],
    "filter the rows returned"
    where: timetables_return_value_timetable_version_bool_exp
  ): timetables_return_value_timetable_version_aggregate!
  "execute function \"vehicle_service.get_timetables_and_substitute_operating_days\" which returns \"return_value.timetable_version\""
  timetables_vehicle_service_get_timetables_and_substitute_operating_days(
    "input parameters for function \"vehicle_service_get_timetables_and_substitute_operating_days\""
    args: timetables_vehicle_service_get_timetables_and_substitute_operating_days_args!,
    "distinct select on columns"
    distinct_on: [timetables_return_value_timetable_version_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_timetable_version_order_by!],
    "filter the rows returned"
    where: timetables_return_value_timetable_version_bool_exp
  ): [timetables_return_value_timetable_version!]!
  "execute function \"vehicle_service.get_timetables_and_substitute_operating_days\" and query aggregates on result of table type \"return_value.timetable_version\""
  timetables_vehicle_service_get_timetables_and_substitute_operating_days_aggregate(
    "input parameters for function \"vehicle_service_get_timetables_and_substitute_operating_days_aggregate\""
    args: timetables_vehicle_service_get_timetables_and_substitute_operating_days_args!,
    "distinct select on columns"
    distinct_on: [timetables_return_value_timetable_version_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_return_value_timetable_version_order_by!],
    "filter the rows returned"
    where: timetables_return_value_timetable_version_bool_exp
  ): timetables_return_value_timetable_version_aggregate!
  "fetch data from the table: \"vehicle_service.journey_patterns_in_vehicle_service\""
  timetables_vehicle_service_journey_patterns_in_vehicle_service(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_journey_patterns_in_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_journey_patterns_in_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp
  ): [timetables_vehicle_service_journey_patterns_in_vehicle_service!]!
  "fetch aggregated fields from the table: \"vehicle_service.journey_patterns_in_vehicle_service\""
  timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_journey_patterns_in_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_journey_patterns_in_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp
  ): timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate!
  "fetch data from the table: \"vehicle_service.journey_patterns_in_vehicle_service\" using primary key columns"
  timetables_vehicle_service_journey_patterns_in_vehicle_service_by_pk(
    """
    The journey_pattern_id from journey_pattern.journey_pattern_ref.
     No foreign key reference is set because the target column is not unique.
    """
    journey_pattern_id: uuid!,
    vehicle_service_id: uuid!
  ): timetables_vehicle_service_journey_patterns_in_vehicle_service
  "fetch data from the table in a streaming manner: \"vehicle_service.journey_patterns_in_vehicle_service\""
  timetables_vehicle_service_journey_patterns_in_vehicle_service_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_vehicle_service_journey_patterns_in_vehicle_service_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp
  ): [timetables_vehicle_service_journey_patterns_in_vehicle_service!]!
  "fetch data from the table: \"vehicle_service.vehicle_service\""
  timetables_vehicle_service_vehicle_service(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_vehicle_service_bool_exp
  ): [timetables_vehicle_service_vehicle_service!]!
  "fetch aggregated fields from the table: \"vehicle_service.vehicle_service\""
  timetables_vehicle_service_vehicle_service_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_vehicle_service_bool_exp
  ): timetables_vehicle_service_vehicle_service_aggregate!
  "fetch data from the table: \"vehicle_service.vehicle_service\" using primary key columns"
  timetables_vehicle_service_vehicle_service_by_pk(vehicle_service_id: uuid!): timetables_vehicle_service_vehicle_service
  "fetch data from the table in a streaming manner: \"vehicle_service.vehicle_service\""
  timetables_vehicle_service_vehicle_service_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_vehicle_service_vehicle_service_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_vehicle_service_vehicle_service_bool_exp
  ): [timetables_vehicle_service_vehicle_service!]!
  "fetch data from the table: \"vehicle_type.vehicle_type\""
  timetables_vehicle_type_vehicle_type(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_type_vehicle_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_type_vehicle_type_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_type_vehicle_type_bool_exp
  ): [timetables_vehicle_type_vehicle_type!]!
  "fetch aggregated fields from the table: \"vehicle_type.vehicle_type\""
  timetables_vehicle_type_vehicle_type_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_type_vehicle_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_type_vehicle_type_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_type_vehicle_type_bool_exp
  ): timetables_vehicle_type_vehicle_type_aggregate!
  "fetch data from the table: \"vehicle_type.vehicle_type\" using primary key columns"
  timetables_vehicle_type_vehicle_type_by_pk(vehicle_type_id: uuid!): timetables_vehicle_type_vehicle_type
  "fetch data from the table in a streaming manner: \"vehicle_type.vehicle_type\""
  timetables_vehicle_type_vehicle_type_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [timetables_vehicle_type_vehicle_type_stream_cursor_input]!,
    "filter the rows returned"
    where: timetables_vehicle_type_vehicle_type_bool_exp
  ): [timetables_vehicle_type_vehicle_type!]!
}

"The planned movement of a public transport vehicle on a DAY TYPE from the start point to the end point of a JOURNEY PATTERN on a specified ROUTE. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:1:1:831 "
type timetables_vehicle_journey_vehicle_journey {
  "An object relationship"
  block: timetables_vehicle_service_block!
  "The BLOCK to which this VEHICLE JOURNEY belongs"
  block_id: uuid!
  "The contract number for this vehicle journey."
  contract_number: String!
  "Displayed name of the journey."
  displayed_name: String
  "A computed field, executes function \"vehicle_journey.vehicle_journey_end_time\""
  end_time: String
  "Is the journey a backup journey."
  is_backup_journey: Boolean!
  "Is the journey an extra journey."
  is_extra_journey: Boolean!
  "It is required to use the same vehicle type as required in vehicle service."
  is_vehicle_type_mandatory: Boolean!
  "Name that user can give to the vehicle journey."
  journey_name_i18n(
    "JSON select path"
    path: String
  ): jsonb
  "An object relationship"
  journey_pattern_ref: timetables_journey_pattern_journey_pattern_ref!
  "The JOURNEY PATTERN on which the VEHICLE JOURNEY travels"
  journey_pattern_ref_id: uuid!
  "STANDARD | DRY_RUN | SERVICE_JOURNEY"
  journey_type: String!
  "LAYOVER TIMEs describe a certain time allowance that may be given at the end of each VEHICLE JOURNEY, before starting the next one, to compensate delays or for other purposes (e.g. rest time for the driver). This layover time can be regarded as a buffer time, which may or may not be actually consumed in real time operation."
  layover_time: interval
  "A computed field, executes function \"vehicle_journey.vehicle_journey_start_time\""
  start_time: String
  "An array relationship"
  timetabled_passing_times(
    "distinct select on columns"
    distinct_on: [timetables_passing_times_timetabled_passing_time_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_passing_times_timetabled_passing_time_order_by!],
    "filter the rows returned"
    where: timetables_passing_times_timetabled_passing_time_bool_exp
  ): [timetables_passing_times_timetabled_passing_time!]!
  "An aggregate relationship"
  timetabled_passing_times_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_passing_times_timetabled_passing_time_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_passing_times_timetabled_passing_time_order_by!],
    "filter the rows returned"
    where: timetables_passing_times_timetabled_passing_time_bool_exp
  ): timetables_passing_times_timetabled_passing_time_aggregate!
  "Turnaround time is the time taken by a vehicle to proceed from the end of a ROUTE to the start of another."
  turnaround_time: interval
  vehicle_journey_id: uuid!
}

"aggregated selection of \"vehicle_journey.vehicle_journey\""
type timetables_vehicle_journey_vehicle_journey_aggregate {
  aggregate: timetables_vehicle_journey_vehicle_journey_aggregate_fields
  nodes: [timetables_vehicle_journey_vehicle_journey!]!
}

"aggregate fields of \"vehicle_journey.vehicle_journey\""
type timetables_vehicle_journey_vehicle_journey_aggregate_fields {
  count(columns: [timetables_vehicle_journey_vehicle_journey_select_column!], distinct: Boolean): Int!
  max: timetables_vehicle_journey_vehicle_journey_max_fields
  min: timetables_vehicle_journey_vehicle_journey_min_fields
}

"aggregate max on columns"
type timetables_vehicle_journey_vehicle_journey_max_fields {
  "The BLOCK to which this VEHICLE JOURNEY belongs"
  block_id: uuid
  "The contract number for this vehicle journey."
  contract_number: String
  "Displayed name of the journey."
  displayed_name: String
  "A computed field, executes function \"vehicle_journey.vehicle_journey_end_time\""
  end_time: String
  "The JOURNEY PATTERN on which the VEHICLE JOURNEY travels"
  journey_pattern_ref_id: uuid
  "STANDARD | DRY_RUN | SERVICE_JOURNEY"
  journey_type: String
  "A computed field, executes function \"vehicle_journey.vehicle_journey_start_time\""
  start_time: String
  vehicle_journey_id: uuid
}

"aggregate min on columns"
type timetables_vehicle_journey_vehicle_journey_min_fields {
  "The BLOCK to which this VEHICLE JOURNEY belongs"
  block_id: uuid
  "The contract number for this vehicle journey."
  contract_number: String
  "Displayed name of the journey."
  displayed_name: String
  "A computed field, executes function \"vehicle_journey.vehicle_journey_end_time\""
  end_time: String
  "The JOURNEY PATTERN on which the VEHICLE JOURNEY travels"
  journey_pattern_ref_id: uuid
  "STANDARD | DRY_RUN | SERVICE_JOURNEY"
  journey_type: String
  "A computed field, executes function \"vehicle_journey.vehicle_journey_start_time\""
  start_time: String
  vehicle_journey_id: uuid
}

"response of any mutation on the table \"vehicle_journey.vehicle_journey\""
type timetables_vehicle_journey_vehicle_journey_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_vehicle_journey_vehicle_journey!]!
}

"A coherent set of BLOCKS, COMPOUND BLOCKs, COURSEs of JOURNEY and VEHICLE SCHEDULEs to which the same set of VALIDITY CONDITIONs have been assigned. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:7:2:993 "
type timetables_vehicle_schedule_vehicle_schedule_frame {
  "Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus."
  booking_description_i18n(
    "JSON select path"
    path: String
  ): jsonb
  "Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus."
  booking_label: String!
  created_at: timestamptz!
  "Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus."
  label: String!
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  name_i18n(
    "JSON select path"
    path: String
  ): jsonb
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Int!
  "OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid."
  validity_end: date!
  """
  
  A denormalized column for actual daterange when vehicle schedule frame is valid,
  that is, a closed date range [validity_start, validity_end].
  Added to make working with PostgreSQL functions easier:
  they typically expect ranges to be half closed.
  """
  validity_range: daterange!
  "OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid."
  validity_start: date!
  vehicle_schedule_frame_id: uuid!
  "An array relationship"
  vehicle_services(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_vehicle_service_bool_exp
  ): [timetables_vehicle_service_vehicle_service!]!
  "An aggregate relationship"
  vehicle_services_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_vehicle_service_bool_exp
  ): timetables_vehicle_service_vehicle_service_aggregate!
}

"aggregated selection of \"vehicle_schedule.vehicle_schedule_frame\""
type timetables_vehicle_schedule_vehicle_schedule_frame_aggregate {
  aggregate: timetables_vehicle_schedule_vehicle_schedule_frame_aggregate_fields
  nodes: [timetables_vehicle_schedule_vehicle_schedule_frame!]!
}

"aggregate fields of \"vehicle_schedule.vehicle_schedule_frame\""
type timetables_vehicle_schedule_vehicle_schedule_frame_aggregate_fields {
  avg: timetables_vehicle_schedule_vehicle_schedule_frame_avg_fields
  count(columns: [timetables_vehicle_schedule_vehicle_schedule_frame_select_column!], distinct: Boolean): Int!
  max: timetables_vehicle_schedule_vehicle_schedule_frame_max_fields
  min: timetables_vehicle_schedule_vehicle_schedule_frame_min_fields
  stddev: timetables_vehicle_schedule_vehicle_schedule_frame_stddev_fields
  stddev_pop: timetables_vehicle_schedule_vehicle_schedule_frame_stddev_pop_fields
  stddev_samp: timetables_vehicle_schedule_vehicle_schedule_frame_stddev_samp_fields
  sum: timetables_vehicle_schedule_vehicle_schedule_frame_sum_fields
  var_pop: timetables_vehicle_schedule_vehicle_schedule_frame_var_pop_fields
  var_samp: timetables_vehicle_schedule_vehicle_schedule_frame_var_samp_fields
  variance: timetables_vehicle_schedule_vehicle_schedule_frame_variance_fields
}

"aggregate avg on columns"
type timetables_vehicle_schedule_vehicle_schedule_frame_avg_fields {
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Float
}

"aggregate max on columns"
type timetables_vehicle_schedule_vehicle_schedule_frame_max_fields {
  "Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus."
  booking_label: String
  created_at: timestamptz
  "Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus."
  label: String
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid."
  validity_end: date
  "OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid."
  validity_start: date
  vehicle_schedule_frame_id: uuid
}

"aggregate min on columns"
type timetables_vehicle_schedule_vehicle_schedule_frame_min_fields {
  "Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus."
  booking_label: String
  created_at: timestamptz
  "Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus."
  label: String
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid."
  validity_end: date
  "OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid."
  validity_start: date
  vehicle_schedule_frame_id: uuid
}

"response of any mutation on the table \"vehicle_schedule.vehicle_schedule_frame\""
type timetables_vehicle_schedule_vehicle_schedule_frame_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_vehicle_schedule_vehicle_schedule_frame!]!
}

"aggregate stddev on columns"
type timetables_vehicle_schedule_vehicle_schedule_frame_stddev_fields {
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Float
}

"aggregate stddev_pop on columns"
type timetables_vehicle_schedule_vehicle_schedule_frame_stddev_pop_fields {
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Float
}

"aggregate stddev_samp on columns"
type timetables_vehicle_schedule_vehicle_schedule_frame_stddev_samp_fields {
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Float
}

"aggregate sum on columns"
type timetables_vehicle_schedule_vehicle_schedule_frame_sum_fields {
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Int
}

"aggregate var_pop on columns"
type timetables_vehicle_schedule_vehicle_schedule_frame_var_pop_fields {
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Float
}

"aggregate var_samp on columns"
type timetables_vehicle_schedule_vehicle_schedule_frame_var_samp_fields {
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Float
}

"aggregate variance on columns"
type timetables_vehicle_schedule_vehicle_schedule_frame_variance_fields {
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Float
}

"The work of a vehicle from the time it leaves a PARKING POINT after parking until its next return to park at a PARKING POINT. Any subsequent departure from a PARKING POINT after parking marks the start of a new BLOCK. The period of a BLOCK has to be covered by DUTies. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:958 "
type timetables_vehicle_service_block {
  block_id: uuid!
  "Finishing time after end of vehicle service block."
  finishing_time: interval
  "Preparation time before start of vehicle service block."
  preparing_time: interval
  "An array relationship"
  vehicle_journeys(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_journey_vehicle_journey_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_journey_vehicle_journey_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_journey_vehicle_journey_bool_exp
  ): [timetables_vehicle_journey_vehicle_journey!]!
  "An aggregate relationship"
  vehicle_journeys_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_journey_vehicle_journey_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_journey_vehicle_journey_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_journey_vehicle_journey_bool_exp
  ): timetables_vehicle_journey_vehicle_journey_aggregate!
  "An object relationship"
  vehicle_service: timetables_vehicle_service_vehicle_service!
  "The VEHICLE SERVICE to which this BLOCK belongs."
  vehicle_service_id: uuid!
  "An object relationship"
  vehicle_type: timetables_vehicle_type_vehicle_type
  "Reference to vehicle_type.vehicle_type."
  vehicle_type_id: uuid
}

"aggregated selection of \"vehicle_service.block\""
type timetables_vehicle_service_block_aggregate {
  aggregate: timetables_vehicle_service_block_aggregate_fields
  nodes: [timetables_vehicle_service_block!]!
}

"aggregate fields of \"vehicle_service.block\""
type timetables_vehicle_service_block_aggregate_fields {
  count(columns: [timetables_vehicle_service_block_select_column!], distinct: Boolean): Int!
  max: timetables_vehicle_service_block_max_fields
  min: timetables_vehicle_service_block_min_fields
}

"aggregate max on columns"
type timetables_vehicle_service_block_max_fields {
  block_id: uuid
  "The VEHICLE SERVICE to which this BLOCK belongs."
  vehicle_service_id: uuid
  "Reference to vehicle_type.vehicle_type."
  vehicle_type_id: uuid
}

"aggregate min on columns"
type timetables_vehicle_service_block_min_fields {
  block_id: uuid
  "The VEHICLE SERVICE to which this BLOCK belongs."
  vehicle_service_id: uuid
  "Reference to vehicle_type.vehicle_type."
  vehicle_type_id: uuid
}

"response of any mutation on the table \"vehicle_service.block\""
type timetables_vehicle_service_block_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_vehicle_service_block!]!
}

"""
A denormalized table containing relationships between vehicle_services and journey_patterns (via journey_pattern_ref.journey_pattern_id).
 Without this table this relationship could be found via vehicle_service -> block -> vehicle_journey -> journey_pattern_ref.
 Kept up to date with triggers, should not be updated manually.
"""
type timetables_vehicle_service_journey_patterns_in_vehicle_service {
  """
  The journey_pattern_id from journey_pattern.journey_pattern_ref.
   No foreign key reference is set because the target column is not unique.
  """
  journey_pattern_id: uuid!
  journey_pattern_instance: journey_pattern_journey_pattern
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Int!
  "An object relationship"
  vehicle_service: timetables_vehicle_service_vehicle_service!
  vehicle_service_id: uuid!
}

"aggregated selection of \"vehicle_service.journey_patterns_in_vehicle_service\""
type timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate {
  aggregate: timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate_fields
  nodes: [timetables_vehicle_service_journey_patterns_in_vehicle_service!]!
}

"aggregate fields of \"vehicle_service.journey_patterns_in_vehicle_service\""
type timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate_fields {
  avg: timetables_vehicle_service_journey_patterns_in_vehicle_service_avg_fields
  count(columns: [timetables_vehicle_service_journey_patterns_in_vehicle_service_select_column!], distinct: Boolean): Int!
  max: timetables_vehicle_service_journey_patterns_in_vehicle_service_max_fields
  min: timetables_vehicle_service_journey_patterns_in_vehicle_service_min_fields
  stddev: timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_fields
  stddev_pop: timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_pop_fields
  stddev_samp: timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_samp_fields
  sum: timetables_vehicle_service_journey_patterns_in_vehicle_service_sum_fields
  var_pop: timetables_vehicle_service_journey_patterns_in_vehicle_service_var_pop_fields
  var_samp: timetables_vehicle_service_journey_patterns_in_vehicle_service_var_samp_fields
  variance: timetables_vehicle_service_journey_patterns_in_vehicle_service_variance_fields
}

"aggregate avg on columns"
type timetables_vehicle_service_journey_patterns_in_vehicle_service_avg_fields {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Float
}

"aggregate max on columns"
type timetables_vehicle_service_journey_patterns_in_vehicle_service_max_fields {
  """
  The journey_pattern_id from journey_pattern.journey_pattern_ref.
   No foreign key reference is set because the target column is not unique.
  """
  journey_pattern_id: uuid
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Int
  vehicle_service_id: uuid
}

"aggregate min on columns"
type timetables_vehicle_service_journey_patterns_in_vehicle_service_min_fields {
  """
  The journey_pattern_id from journey_pattern.journey_pattern_ref.
   No foreign key reference is set because the target column is not unique.
  """
  journey_pattern_id: uuid
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Int
  vehicle_service_id: uuid
}

"response of any mutation on the table \"vehicle_service.journey_patterns_in_vehicle_service\""
type timetables_vehicle_service_journey_patterns_in_vehicle_service_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_vehicle_service_journey_patterns_in_vehicle_service!]!
}

"aggregate stddev on columns"
type timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_fields {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Float
}

"aggregate stddev_pop on columns"
type timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_pop_fields {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Float
}

"aggregate stddev_samp on columns"
type timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_samp_fields {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Float
}

"aggregate sum on columns"
type timetables_vehicle_service_journey_patterns_in_vehicle_service_sum_fields {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Int
}

"aggregate var_pop on columns"
type timetables_vehicle_service_journey_patterns_in_vehicle_service_var_pop_fields {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Float
}

"aggregate var_samp on columns"
type timetables_vehicle_service_journey_patterns_in_vehicle_service_var_samp_fields {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Float
}

"aggregate variance on columns"
type timetables_vehicle_service_journey_patterns_in_vehicle_service_variance_fields {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Float
}

"A work plan for a single vehicle for a whole day, planned for a specific DAY TYPE. A VEHICLE SERVICE includes one or several BLOCKs. If there is no service on a given day, it does not include any BLOCKs. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:965 "
type timetables_vehicle_service_vehicle_service {
  "An array relationship"
  blocks(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_block_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_block_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_block_bool_exp
  ): [timetables_vehicle_service_block!]!
  "An aggregate relationship"
  blocks_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_block_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_block_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_block_bool_exp
  ): timetables_vehicle_service_block_aggregate!
  "An object relationship"
  day_type: timetables_service_calendar_day_type!
  "The DAY TYPE for the VEHICLE SERVICE."
  day_type_id: uuid!
  "An array relationship"
  journey_patterns_in_vehicle_service(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_journey_patterns_in_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_journey_patterns_in_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp
  ): [timetables_vehicle_service_journey_patterns_in_vehicle_service!]!
  "An aggregate relationship"
  journey_patterns_in_vehicle_service_aggregate(
    "distinct select on columns"
    distinct_on: [timetables_vehicle_service_journey_patterns_in_vehicle_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [timetables_vehicle_service_journey_patterns_in_vehicle_service_order_by!],
    "filter the rows returned"
    where: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp
  ): timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate!
  "Name for vehicle service."
  name_i18n(
    "JSON select path"
    path: String
  ): jsonb
  "An object relationship"
  vehicle_schedule_frame: timetables_vehicle_schedule_vehicle_schedule_frame!
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  vehicle_schedule_frame_id: uuid!
  vehicle_service_id: uuid!
}

"aggregated selection of \"vehicle_service.vehicle_service\""
type timetables_vehicle_service_vehicle_service_aggregate {
  aggregate: timetables_vehicle_service_vehicle_service_aggregate_fields
  nodes: [timetables_vehicle_service_vehicle_service!]!
}

"aggregate fields of \"vehicle_service.vehicle_service\""
type timetables_vehicle_service_vehicle_service_aggregate_fields {
  count(columns: [timetables_vehicle_service_vehicle_service_select_column!], distinct: Boolean): Int!
  max: timetables_vehicle_service_vehicle_service_max_fields
  min: timetables_vehicle_service_vehicle_service_min_fields
}

"aggregate max on columns"
type timetables_vehicle_service_vehicle_service_max_fields {
  "The DAY TYPE for the VEHICLE SERVICE."
  day_type_id: uuid
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  vehicle_schedule_frame_id: uuid
  vehicle_service_id: uuid
}

"aggregate min on columns"
type timetables_vehicle_service_vehicle_service_min_fields {
  "The DAY TYPE for the VEHICLE SERVICE."
  day_type_id: uuid
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  vehicle_schedule_frame_id: uuid
  vehicle_service_id: uuid
}

"response of any mutation on the table \"vehicle_service.vehicle_service\""
type timetables_vehicle_service_vehicle_service_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_vehicle_service_vehicle_service!]!
}

"The VEHICLE entity is used to describe the physical public transport vehicles available for short-term planning of operations and daily assignment (in contrast to logical vehicles considered for resource planning of operations and daily assignment (in contrast to logical vehicles cplanning). Each VEHICLE shall be classified as of a particular VEHICLE TYPE."
type timetables_vehicle_type_vehicle_type {
  "Description of the vehicle type."
  description_i18n(
    "JSON select path"
    path: String
  ): jsonb
  "ID used in Hastus to represent the vehicle type."
  hsl_id: smallint!
  "Label of the vehicle type."
  label: String!
  vehicle_type_id: uuid!
}

"aggregated selection of \"vehicle_type.vehicle_type\""
type timetables_vehicle_type_vehicle_type_aggregate {
  aggregate: timetables_vehicle_type_vehicle_type_aggregate_fields
  nodes: [timetables_vehicle_type_vehicle_type!]!
}

"aggregate fields of \"vehicle_type.vehicle_type\""
type timetables_vehicle_type_vehicle_type_aggregate_fields {
  avg: timetables_vehicle_type_vehicle_type_avg_fields
  count(columns: [timetables_vehicle_type_vehicle_type_select_column!], distinct: Boolean): Int!
  max: timetables_vehicle_type_vehicle_type_max_fields
  min: timetables_vehicle_type_vehicle_type_min_fields
  stddev: timetables_vehicle_type_vehicle_type_stddev_fields
  stddev_pop: timetables_vehicle_type_vehicle_type_stddev_pop_fields
  stddev_samp: timetables_vehicle_type_vehicle_type_stddev_samp_fields
  sum: timetables_vehicle_type_vehicle_type_sum_fields
  var_pop: timetables_vehicle_type_vehicle_type_var_pop_fields
  var_samp: timetables_vehicle_type_vehicle_type_var_samp_fields
  variance: timetables_vehicle_type_vehicle_type_variance_fields
}

"aggregate avg on columns"
type timetables_vehicle_type_vehicle_type_avg_fields {
  "ID used in Hastus to represent the vehicle type."
  hsl_id: Float
}

"aggregate max on columns"
type timetables_vehicle_type_vehicle_type_max_fields {
  "ID used in Hastus to represent the vehicle type."
  hsl_id: smallint
  "Label of the vehicle type."
  label: String
  vehicle_type_id: uuid
}

"aggregate min on columns"
type timetables_vehicle_type_vehicle_type_min_fields {
  "ID used in Hastus to represent the vehicle type."
  hsl_id: smallint
  "Label of the vehicle type."
  label: String
  vehicle_type_id: uuid
}

"response of any mutation on the table \"vehicle_type.vehicle_type\""
type timetables_vehicle_type_vehicle_type_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timetables_vehicle_type_vehicle_type!]!
}

"aggregate stddev on columns"
type timetables_vehicle_type_vehicle_type_stddev_fields {
  "ID used in Hastus to represent the vehicle type."
  hsl_id: Float
}

"aggregate stddev_pop on columns"
type timetables_vehicle_type_vehicle_type_stddev_pop_fields {
  "ID used in Hastus to represent the vehicle type."
  hsl_id: Float
}

"aggregate stddev_samp on columns"
type timetables_vehicle_type_vehicle_type_stddev_samp_fields {
  "ID used in Hastus to represent the vehicle type."
  hsl_id: Float
}

"aggregate sum on columns"
type timetables_vehicle_type_vehicle_type_sum_fields {
  "ID used in Hastus to represent the vehicle type."
  hsl_id: smallint
}

"aggregate var_pop on columns"
type timetables_vehicle_type_vehicle_type_var_pop_fields {
  "ID used in Hastus to represent the vehicle type."
  hsl_id: Float
}

"aggregate var_samp on columns"
type timetables_vehicle_type_vehicle_type_var_samp_fields {
  "ID used in Hastus to represent the vehicle type."
  hsl_id: Float
}

"aggregate variance on columns"
type timetables_vehicle_type_vehicle_type_variance_fields {
  "ID used in Hastus to represent the vehicle type."
  hsl_id: Float
}

"A set of SCHEDULED STOP POINTs against which the timing information necessary to build schedules may be recorded. In HSL context this is \"Hastus paikka\". Based on Transmodel entity TIMING POINT: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:2:709 "
type timing_pattern_timing_place {
  description(
    "JSON select path"
    path: String
  ): jsonb
  label: String!
  "An array relationship"
  scheduled_stop_points(
    "distinct select on columns"
    distinct_on: [service_pattern_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): [service_pattern_scheduled_stop_point!]!
  "An aggregate relationship"
  scheduled_stop_points_aggregate(
    "distinct select on columns"
    distinct_on: [service_pattern_scheduled_stop_point_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [service_pattern_scheduled_stop_point_order_by!],
    "filter the rows returned"
    where: service_pattern_scheduled_stop_point_bool_exp
  ): service_pattern_scheduled_stop_point_aggregate!
  timing_place_id: uuid!
}

"aggregated selection of \"timing_pattern.timing_place\""
type timing_pattern_timing_place_aggregate {
  aggregate: timing_pattern_timing_place_aggregate_fields
  nodes: [timing_pattern_timing_place!]!
}

"aggregate fields of \"timing_pattern.timing_place\""
type timing_pattern_timing_place_aggregate_fields {
  count(columns: [timing_pattern_timing_place_select_column!], distinct: Boolean): Int!
  max: timing_pattern_timing_place_max_fields
  min: timing_pattern_timing_place_min_fields
}

"aggregate max on columns"
type timing_pattern_timing_place_max_fields {
  label: String
  timing_place_id: uuid
}

"aggregate min on columns"
type timing_pattern_timing_place_min_fields {
  label: String
  timing_place_id: uuid
}

"response of any mutation on the table \"timing_pattern.timing_place\""
type timing_pattern_timing_place_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [timing_pattern_timing_place!]!
}

"ordering argument of a cursor"
enum cursor_ordering {
  "ascending ordering of the cursor"
  ASC
  "descending ordering of the cursor"
  DESC
}

"unique or primary key constraints on table \"hsl_route.legacy_hsl_municipality_code\""
enum hsl_route_legacy_hsl_municipality_code_constraint {
  "unique or primary key constraint on columns \"hsl_municipality\""
  legacy_hsl_municipality_code_pkey
}

"select columns of table \"hsl_route.legacy_hsl_municipality_code\""
enum hsl_route_legacy_hsl_municipality_code_select_column {
  "column name"
  hsl_municipality
  "column name"
  jore3_code
}

"update columns of table \"hsl_route.legacy_hsl_municipality_code\""
enum hsl_route_legacy_hsl_municipality_code_update_column {
  "column name"
  hsl_municipality
  "column name"
  jore3_code
}

"unique or primary key constraints on table \"hsl_route.transport_target\""
enum hsl_route_transport_target_constraint {
  "unique or primary key constraint on columns \"transport_target\""
  transport_target_pkey
}

enum hsl_route_transport_target_enum {
  espoo_and_kauniainen_internal_traffic
  espoo_regional_traffic
  helsinki_internal_traffic
  kerava_internal_traffic
  kerava_regional_traffic
  kirkkonummi_internal_traffic
  kirkkonummi_regional_traffic
  sipoo_internal_traffic
  siuntio_internal_traffic
  siuntio_regional_traffic
  transverse_regional
  tuusula_internal_traffic
  tuusula_regional_traffic
  vantaa_internal_traffic
  vantaa_regional_traffic
}

"select columns of table \"hsl_route.transport_target\""
enum hsl_route_transport_target_select_column {
  "column name"
  transport_target
}

"update columns of table \"hsl_route.transport_target\""
enum hsl_route_transport_target_update_column {
  "column name"
  transport_target
}

"unique or primary key constraints on table \"infrastructure_network.direction\""
enum infrastructure_network_direction_constraint {
  "unique or primary key constraint on columns \"value\""
  direction_pkey
}

enum infrastructure_network_direction_enum {
  backward
  bidirectional
  forward
}

"select columns of table \"infrastructure_network.direction\""
enum infrastructure_network_direction_select_column {
  "column name"
  value
}

"update columns of table \"infrastructure_network.direction\""
enum infrastructure_network_direction_update_column {
  "column name"
  value
}

"unique or primary key constraints on table \"infrastructure_network.external_source\""
enum infrastructure_network_external_source_constraint {
  "unique or primary key constraint on columns \"value\""
  external_source_pkey
}

enum infrastructure_network_external_source_enum {
  digiroad_r
  hsl_fixup
}

"select columns of table \"infrastructure_network.external_source\""
enum infrastructure_network_external_source_select_column {
  "column name"
  value
}

"update columns of table \"infrastructure_network.external_source\""
enum infrastructure_network_external_source_update_column {
  "column name"
  value
}

"unique or primary key constraints on table \"infrastructure_network.infrastructure_link\""
enum infrastructure_network_infrastructure_link_constraint {
  "unique or primary key constraint on columns \"external_link_id\", \"external_link_source\""
  infrastructure_link_external_link_id_external_link_source_idx
  "unique or primary key constraint on columns \"infrastructure_link_id\""
  infrastructure_link_pkey
}

"select columns of table \"infrastructure_network.infrastructure_link\""
enum infrastructure_network_infrastructure_link_select_column {
  "column name"
  direction
  "column name"
  estimated_length_in_metres
  "column name"
  external_link_id
  "column name"
  external_link_source
  "column name"
  infrastructure_link_id
  "column name"
  shape
}

"select \"infrastructure_network_infrastructure_link_aggregate_bool_exp_avg_arguments_columns\" columns of table \"infrastructure_network.infrastructure_link\""
enum infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_avg_arguments_columns {
  "column name"
  estimated_length_in_metres
}

"select \"infrastructure_network_infrastructure_link_aggregate_bool_exp_corr_arguments_columns\" columns of table \"infrastructure_network.infrastructure_link\""
enum infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_corr_arguments_columns {
  "column name"
  estimated_length_in_metres
}

"select \"infrastructure_network_infrastructure_link_aggregate_bool_exp_covar_samp_arguments_columns\" columns of table \"infrastructure_network.infrastructure_link\""
enum infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_covar_samp_arguments_columns {
  "column name"
  estimated_length_in_metres
}

"select \"infrastructure_network_infrastructure_link_aggregate_bool_exp_max_arguments_columns\" columns of table \"infrastructure_network.infrastructure_link\""
enum infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_max_arguments_columns {
  "column name"
  estimated_length_in_metres
}

"select \"infrastructure_network_infrastructure_link_aggregate_bool_exp_min_arguments_columns\" columns of table \"infrastructure_network.infrastructure_link\""
enum infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_min_arguments_columns {
  "column name"
  estimated_length_in_metres
}

"select \"infrastructure_network_infrastructure_link_aggregate_bool_exp_stddev_samp_arguments_columns\" columns of table \"infrastructure_network.infrastructure_link\""
enum infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_stddev_samp_arguments_columns {
  "column name"
  estimated_length_in_metres
}

"select \"infrastructure_network_infrastructure_link_aggregate_bool_exp_sum_arguments_columns\" columns of table \"infrastructure_network.infrastructure_link\""
enum infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_sum_arguments_columns {
  "column name"
  estimated_length_in_metres
}

"select \"infrastructure_network_infrastructure_link_aggregate_bool_exp_var_samp_arguments_columns\" columns of table \"infrastructure_network.infrastructure_link\""
enum infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_var_samp_arguments_columns {
  "column name"
  estimated_length_in_metres
}

"update columns of table \"infrastructure_network.infrastructure_link\""
enum infrastructure_network_infrastructure_link_update_column {
  "column name"
  direction
  "column name"
  estimated_length_in_metres
  "column name"
  external_link_id
  "column name"
  external_link_source
  "column name"
  infrastructure_link_id
  "column name"
  shape
}

"unique or primary key constraints on table \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
enum infrastructure_network_vehicle_submode_on_infrastructure_link_constraint {
  "unique or primary key constraint on columns \"infrastructure_link_id\", \"vehicle_submode\""
  vehicle_submode_on_infrastructure_link_pkey
}

"select columns of table \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
enum infrastructure_network_vehicle_submode_on_infrastructure_link_select_column {
  "column name"
  infrastructure_link_id
  "column name"
  vehicle_submode
}

"update columns of table \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
enum infrastructure_network_vehicle_submode_on_infrastructure_link_update_column {
  "column name"
  infrastructure_link_id
  "column name"
  vehicle_submode
}

"unique or primary key constraints on table \"journey_pattern.journey_pattern\""
enum journey_pattern_journey_pattern_constraint {
  "unique or primary key constraint on columns \"on_route_id\""
  journey_pattern_on_route_id_idx
  "unique or primary key constraint on columns \"journey_pattern_id\""
  journey_pattern_pkey
}

"select columns of table \"journey_pattern.journey_pattern\""
enum journey_pattern_journey_pattern_select_column {
  "column name"
  journey_pattern_id
  "column name"
  on_route_id
}

"update columns of table \"journey_pattern.journey_pattern\""
enum journey_pattern_journey_pattern_update_column {
  "column name"
  journey_pattern_id
  "column name"
  on_route_id
}

"unique or primary key constraints on table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
enum journey_pattern_scheduled_stop_point_in_journey_pattern_constraint {
  "unique or primary key constraint on columns \"scheduled_stop_point_sequence\", \"journey_pattern_id\""
  scheduled_stop_point_in_journey_pattern_pkey
}

"select columns of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
enum journey_pattern_scheduled_stop_point_in_journey_pattern_select_column {
  "column name"
  is_loading_time_allowed
  "column name"
  is_regulated_timing_point
  "column name"
  is_used_as_timing_point
  "column name"
  is_via_point
  "column name"
  journey_pattern_id
  "column name"
  scheduled_stop_point_label
  "column name"
  scheduled_stop_point_sequence
  "column name"
  via_point_name_i18n
  "column name"
  via_point_short_name_i18n
}

"select \"journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
enum journey_pattern_scheduled_stop_point_in_journey_pattern_select_column_journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  is_loading_time_allowed
  "column name"
  is_regulated_timing_point
  "column name"
  is_used_as_timing_point
  "column name"
  is_via_point
}

"select \"journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
enum journey_pattern_scheduled_stop_point_in_journey_pattern_select_column_journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  is_loading_time_allowed
  "column name"
  is_regulated_timing_point
  "column name"
  is_used_as_timing_point
  "column name"
  is_via_point
}

"update columns of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
enum journey_pattern_scheduled_stop_point_in_journey_pattern_update_column {
  "column name"
  is_loading_time_allowed
  "column name"
  is_regulated_timing_point
  "column name"
  is_used_as_timing_point
  "column name"
  is_via_point
  "column name"
  journey_pattern_id
  "column name"
  scheduled_stop_point_label
  "column name"
  scheduled_stop_point_sequence
  "column name"
  via_point_name_i18n
  "column name"
  via_point_short_name_i18n
}

"column ordering options"
enum order_by {
  "in ascending order, nulls last"
  asc
  "in ascending order, nulls first"
  asc_nulls_first
  "in ascending order, nulls last"
  asc_nulls_last
  "in descending order, nulls first"
  desc
  "in descending order, nulls first"
  desc_nulls_first
  "in descending order, nulls last"
  desc_nulls_last
}

"unique or primary key constraints on table \"reusable_components.vehicle_mode\""
enum reusable_components_vehicle_mode_constraint {
  "unique or primary key constraint on columns \"vehicle_mode\""
  vehicle_mode_pkey
}

enum reusable_components_vehicle_mode_enum {
  bus
  ferry
  metro
  train
  tram
}

"select columns of table \"reusable_components.vehicle_mode\""
enum reusable_components_vehicle_mode_select_column {
  "column name"
  vehicle_mode
}

"update columns of table \"reusable_components.vehicle_mode\""
enum reusable_components_vehicle_mode_update_column {
  "column name"
  vehicle_mode
}

"unique or primary key constraints on table \"reusable_components.vehicle_submode\""
enum reusable_components_vehicle_submode_constraint {
  "unique or primary key constraint on columns \"vehicle_submode\""
  vehicle_submode_pkey
}

enum reusable_components_vehicle_submode_enum {
  "bus"
  generic_bus
  "ferry"
  generic_ferry
  "metro"
  generic_metro
  "train"
  generic_train
  "tram"
  generic_tram
  "bus"
  tall_electric_bus
}

"select columns of table \"reusable_components.vehicle_submode\""
enum reusable_components_vehicle_submode_select_column {
  "column name"
  belonging_to_vehicle_mode
  "column name"
  vehicle_submode
}

"update columns of table \"reusable_components.vehicle_submode\""
enum reusable_components_vehicle_submode_update_column {
  "column name"
  belonging_to_vehicle_mode
  "column name"
  vehicle_submode
}

"unique or primary key constraints on table \"route.direction\""
enum route_direction_constraint {
  "unique or primary key constraint on columns \"direction\""
  direction_pkey
}

enum route_direction_enum {
  "clockwise"
  anticlockwise
  "anticlockwise"
  clockwise
  "westbound"
  eastbound
  "outbound"
  inbound
  "southbound"
  northbound
  "inbound"
  outbound
  "northbound"
  southbound
  "eastbound"
  westbound
}

"select columns of table \"route.direction\""
enum route_direction_select_column {
  "column name"
  direction
  "column name"
  the_opposite_of_direction
}

"update columns of table \"route.direction\""
enum route_direction_update_column {
  "column name"
  direction
  "column name"
  the_opposite_of_direction
}

"unique or primary key constraints on table \"route.infrastructure_link_along_route\""
enum route_infrastructure_link_along_route_constraint {
  "unique or primary key constraint on columns \"infrastructure_link_sequence\", \"route_id\""
  infrastructure_link_along_route_pkey
}

"select columns of table \"route.infrastructure_link_along_route\""
enum route_infrastructure_link_along_route_select_column {
  "column name"
  infrastructure_link_id
  "column name"
  infrastructure_link_sequence
  "column name"
  is_traversal_forwards
  "column name"
  route_id
}

"select \"route_infrastructure_link_along_route_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"route.infrastructure_link_along_route\""
enum route_infrastructure_link_along_route_select_column_route_infrastructure_link_along_route_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  is_traversal_forwards
}

"select \"route_infrastructure_link_along_route_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"route.infrastructure_link_along_route\""
enum route_infrastructure_link_along_route_select_column_route_infrastructure_link_along_route_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  is_traversal_forwards
}

"update columns of table \"route.infrastructure_link_along_route\""
enum route_infrastructure_link_along_route_update_column {
  "column name"
  infrastructure_link_id
  "column name"
  infrastructure_link_sequence
  "column name"
  is_traversal_forwards
  "column name"
  route_id
}

"unique or primary key constraints on table \"route.line\""
enum route_line_constraint {
  "unique or primary key constraint on columns \"line_id\""
  line_pkey
}

"select columns of table \"route.line\""
enum route_line_select_column {
  "column name"
  label
  "column name"
  legacy_hsl_municipality_code
  "column name"
  line_id
  "column name"
  name_i18n
  "column name"
  primary_vehicle_mode
  "column name"
  priority
  "column name"
  short_name_i18n
  "column name"
  transport_target
  "column name"
  type_of_line
  "column name"
  validity_end
  "column name"
  validity_start
}

"update columns of table \"route.line\""
enum route_line_update_column {
  "column name"
  label
  "column name"
  legacy_hsl_municipality_code
  "column name"
  line_id
  "column name"
  name_i18n
  "column name"
  primary_vehicle_mode
  "column name"
  priority
  "column name"
  short_name_i18n
  "column name"
  transport_target
  "column name"
  type_of_line
  "column name"
  validity_end
  "column name"
  validity_start
}

"unique or primary key constraints on table \"route.route\""
enum route_route_constraint {
  "unique or primary key constraint on columns \"route_id\""
  route_pkey
}

"select columns of table \"route.route\""
enum route_route_select_column {
  "column name"
  description_i18n
  "column name"
  destination_name_i18n
  "column name"
  destination_short_name_i18n
  "column name"
  direction
  "column name"
  label
  "column name"
  legacy_hsl_municipality_code
  "column name"
  name_i18n
  "column name"
  on_line_id
  "column name"
  origin_name_i18n
  "column name"
  origin_short_name_i18n
  "column name"
  priority
  "column name"
  route_id
  "column name"
  unique_label
  "column name"
  validity_end
  "column name"
  validity_start
  "column name"
  variant
}

"update columns of table \"route.route\""
enum route_route_update_column {
  "column name"
  description_i18n
  "column name"
  destination_name_i18n
  "column name"
  destination_short_name_i18n
  "column name"
  direction
  "column name"
  label
  "column name"
  legacy_hsl_municipality_code
  "column name"
  name_i18n
  "column name"
  on_line_id
  "column name"
  origin_name_i18n
  "column name"
  origin_short_name_i18n
  "column name"
  priority
  "column name"
  route_id
  "column name"
  validity_end
  "column name"
  validity_start
  "column name"
  variant
}

"unique or primary key constraints on table \"route.type_of_line\""
enum route_type_of_line_constraint {
  "unique or primary key constraint on columns \"type_of_line\""
  type_of_line_pkey
}

enum route_type_of_line_enum {
  "tram"
  city_tram_service
  "bus"
  demand_and_response_bus_service
  "bus"
  express_bus_service
  "ferry"
  ferry_service
  "metro"
  metro_service
  "bus"
  regional_bus_service
  "train"
  regional_rail_service
  "tram"
  regional_tram_service
  "bus"
  special_needs_bus
  "bus"
  stopping_bus_service
  "train"
  suburban_railway
}

"select columns of table \"route.type_of_line\""
enum route_type_of_line_select_column {
  "column name"
  belonging_to_vehicle_mode
  "column name"
  type_of_line
}

"update columns of table \"route.type_of_line\""
enum route_type_of_line_update_column {
  "column name"
  belonging_to_vehicle_mode
  "column name"
  type_of_line
}

"unique or primary key constraints on table \"service_pattern.distance_between_stops_calculation\""
enum service_pattern_distance_between_stops_calculation_constraint {
  "unique or primary key constraint on columns \"observation_date\", \"stop_interval_sequence\", \"journey_pattern_id\", \"route_priority\""
  distance_between_stops_calculation_pkey
}

"select columns of table \"service_pattern.distance_between_stops_calculation\""
enum service_pattern_distance_between_stops_calculation_select_column {
  "column name"
  distance_in_metres
  "column name"
  end_stop_label
  "column name"
  journey_pattern_id
  "column name"
  observation_date
  "column name"
  route_id
  "column name"
  route_priority
  "column name"
  start_stop_label
  "column name"
  stop_interval_sequence
}

"update columns of table \"service_pattern.distance_between_stops_calculation\""
enum service_pattern_distance_between_stops_calculation_update_column {
  "column name"
  distance_in_metres
  "column name"
  end_stop_label
  "column name"
  journey_pattern_id
  "column name"
  observation_date
  "column name"
  route_id
  "column name"
  route_priority
  "column name"
  start_stop_label
  "column name"
  stop_interval_sequence
}

"unique or primary key constraints on table \"service_pattern.scheduled_stop_point\""
enum service_pattern_scheduled_stop_point_constraint {
  "unique or primary key constraint on columns \"scheduled_stop_point_id\""
  scheduled_stop_point_pkey
}

"select columns of table \"service_pattern.scheduled_stop_point\""
enum service_pattern_scheduled_stop_point_select_column {
  "column name"
  direction
  "column name"
  label
  "column name"
  located_on_infrastructure_link_id
  "column name"
  measured_location
  "column name"
  priority
  "column name"
  scheduled_stop_point_id
  "column name"
  timing_place_id
  "column name"
  validity_end
  "column name"
  validity_start
}

"update columns of table \"service_pattern.scheduled_stop_point\""
enum service_pattern_scheduled_stop_point_update_column {
  "column name"
  direction
  "column name"
  label
  "column name"
  located_on_infrastructure_link_id
  "column name"
  measured_location
  "column name"
  priority
  "column name"
  scheduled_stop_point_id
  "column name"
  timing_place_id
  "column name"
  validity_end
  "column name"
  validity_start
}

"unique or primary key constraints on table \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
enum service_pattern_vehicle_mode_on_scheduled_stop_point_constraint {
  "unique or primary key constraint on columns \"scheduled_stop_point_id\", \"vehicle_mode\""
  scheduled_stop_point_serviced_by_vehicle_mode_pkey
}

"select columns of table \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
enum service_pattern_vehicle_mode_on_scheduled_stop_point_select_column {
  "column name"
  scheduled_stop_point_id
  "column name"
  vehicle_mode
}

"update columns of table \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
enum service_pattern_vehicle_mode_on_scheduled_stop_point_update_column {
  "column name"
  scheduled_stop_point_id
  "column name"
  vehicle_mode
}

"ordering argument of a cursor"
enum timetables_cursor_ordering {
  "ascending ordering of the cursor"
  ASC
  "descending ordering of the cursor"
  DESC
}

"unique or primary key constraints on table \"journey_pattern.journey_pattern_ref\""
enum timetables_journey_pattern_journey_pattern_ref_constraint {
  "unique or primary key constraint on columns \"journey_pattern_ref_id\""
  journey_pattern_ref_pkey
}

"select columns of table \"journey_pattern.journey_pattern_ref\""
enum timetables_journey_pattern_journey_pattern_ref_select_column {
  "column name"
  journey_pattern_id
  "column name"
  journey_pattern_ref_id
  "column name"
  observation_timestamp
  "column name"
  route_direction
  "column name"
  route_label
  "column name"
  route_validity_end
  "column name"
  route_validity_start
  "column name"
  snapshot_timestamp
  "column name"
  type_of_line
}

"update columns of table \"journey_pattern.journey_pattern_ref\""
enum timetables_journey_pattern_journey_pattern_ref_update_column {
  "column name"
  journey_pattern_id
  "column name"
  journey_pattern_ref_id
  "column name"
  observation_timestamp
  "column name"
  route_direction
  "column name"
  route_label
  "column name"
  route_validity_end
  "column name"
  route_validity_start
  "column name"
  snapshot_timestamp
  "column name"
  type_of_line
}

"unique or primary key constraints on table \"passing_times.timetabled_passing_time\""
enum timetables_passing_times_timetabled_passing_time_constraint {
  "unique or primary key constraint on columns \"timetabled_passing_time_id\""
  timetabled_passing_time_pkey
  "unique or primary key constraint on columns \"scheduled_stop_point_in_journey_pattern_ref_id\", \"vehicle_journey_id\""
  timetabled_passing_time_stop_point_unique_idx
}

"select columns of table \"passing_times.timetabled_passing_time\""
enum timetables_passing_times_timetabled_passing_time_select_column {
  "column name"
  arrival_time
  "column name"
  departure_time
  "column name"
  passing_time
  "column name"
  scheduled_stop_point_in_journey_pattern_ref_id
  "column name"
  timetabled_passing_time_id
  "column name"
  vehicle_journey_id
}

"update columns of table \"passing_times.timetabled_passing_time\""
enum timetables_passing_times_timetabled_passing_time_update_column {
  "column name"
  arrival_time
  "column name"
  departure_time
  "column name"
  scheduled_stop_point_in_journey_pattern_ref_id
  "column name"
  timetabled_passing_time_id
  "column name"
  vehicle_journey_id
}

"select columns of table \"return_value.timetable_version\""
enum timetables_return_value_timetable_version_select_column {
  "column name"
  day_type_id
  "column name"
  in_effect
  "column name"
  priority
  "column name"
  substitute_operating_day_by_line_type_id
  "column name"
  validity_end
  "column name"
  validity_start
  "column name"
  vehicle_schedule_frame_id
}

"select columns of table \"return_value.vehicle_schedule\""
enum timetables_return_value_vehicle_schedule_select_column {
  "column name"
  created_at
  "column name"
  day_type_id
  "column name"
  priority
  "column name"
  substitute_operating_day_by_line_type_id
  "column name"
  validity_end
  "column name"
  validity_start
  "column name"
  vehicle_journey_id
  "column name"
  vehicle_schedule_frame_id
}

"unique or primary key constraints on table \"route.direction\""
enum timetables_route_direction_constraint {
  "unique or primary key constraint on columns \"direction\""
  direction_pkey
}

enum timetables_route_direction_enum {
  "clockwise"
  anticlockwise
  "anticlockwise"
  clockwise
  "westbound"
  eastbound
  "outbound"
  inbound
  "southbound"
  northbound
  "inbound"
  outbound
  "northbound"
  southbound
  "eastbound"
  westbound
}

"select columns of table \"route.direction\""
enum timetables_route_direction_select_column {
  "column name"
  direction
  "column name"
  the_opposite_of_direction
}

"update columns of table \"route.direction\""
enum timetables_route_direction_update_column {
  "column name"
  direction
  "column name"
  the_opposite_of_direction
}

"unique or primary key constraints on table \"route.type_of_line\""
enum timetables_route_type_of_line_constraint {
  "unique or primary key constraint on columns \"type_of_line\""
  type_of_line_pkey
}

"select columns of table \"route.type_of_line\""
enum timetables_route_type_of_line_select_column {
  "column name"
  type_of_line
}

"update columns of table \"route.type_of_line\""
enum timetables_route_type_of_line_update_column {
  "column name"
  type_of_line
}

"unique or primary key constraints on table \"service_calendar.day_type_active_on_day_of_week\""
enum timetables_service_calendar_day_type_active_on_day_of_week_constraint {
  "unique or primary key constraint on columns \"day_of_week\", \"day_type_id\""
  day_type_active_on_day_of_week_pkey
}

"select columns of table \"service_calendar.day_type_active_on_day_of_week\""
enum timetables_service_calendar_day_type_active_on_day_of_week_select_column {
  "column name"
  day_of_week
  "column name"
  day_type_id
}

"update columns of table \"service_calendar.day_type_active_on_day_of_week\""
enum timetables_service_calendar_day_type_active_on_day_of_week_update_column {
  "column name"
  day_of_week
  "column name"
  day_type_id
}

"unique or primary key constraints on table \"service_calendar.day_type\""
enum timetables_service_calendar_day_type_constraint {
  "unique or primary key constraint on columns \"day_type_id\""
  day_type_pkey
  "unique or primary key constraint on columns \"label\""
  service_calendar_day_type_label_idx
}

"select columns of table \"service_calendar.day_type\""
enum timetables_service_calendar_day_type_select_column {
  "column name"
  day_type_id
  "column name"
  label
  "column name"
  name_i18n
}

"update columns of table \"service_calendar.day_type\""
enum timetables_service_calendar_day_type_update_column {
  "column name"
  day_type_id
  "column name"
  label
  "column name"
  name_i18n
}

"unique or primary key constraints on table \"service_calendar.substitute_operating_day_by_line_type\""
enum timetables_service_calendar_substitute_operating_day_by_line_type_constraint {
  "unique or primary key constraint on columns \"substitute_operating_day_by_line_type_id\""
  substitute_operating_day_by_line_type_pkey
}

"select columns of table \"service_calendar.substitute_operating_day_by_line_type\""
enum timetables_service_calendar_substitute_operating_day_by_line_type_select_column {
  "column name"
  begin_datetime
  "column name"
  begin_time
  "column name"
  created_at
  "column name"
  end_datetime
  "column name"
  end_time
  "column name"
  substitute_day_of_week
  "column name"
  substitute_operating_day_by_line_type_id
  "column name"
  substitute_operating_period_id
  "column name"
  superseded_date
  "column name"
  timezone
  "column name"
  type_of_line
}

"update columns of table \"service_calendar.substitute_operating_day_by_line_type\""
enum timetables_service_calendar_substitute_operating_day_by_line_type_update_column {
  "column name"
  begin_time
  "column name"
  created_at
  "column name"
  end_time
  "column name"
  substitute_day_of_week
  "column name"
  substitute_operating_day_by_line_type_id
  "column name"
  substitute_operating_period_id
  "column name"
  superseded_date
  "column name"
  timezone
  "column name"
  type_of_line
}

"unique or primary key constraints on table \"service_calendar.substitute_operating_period\""
enum timetables_service_calendar_substitute_operating_period_constraint {
  "unique or primary key constraint on columns \"period_name\""
  substitute_operating_period_period_name_key
  "unique or primary key constraint on columns \"substitute_operating_period_id\""
  substitute_operating_period_pkey
}

"select columns of table \"service_calendar.substitute_operating_period\""
enum timetables_service_calendar_substitute_operating_period_select_column {
  "column name"
  is_preset
  "column name"
  period_name
  "column name"
  substitute_operating_period_id
}

"update columns of table \"service_calendar.substitute_operating_period\""
enum timetables_service_calendar_substitute_operating_period_update_column {
  "column name"
  is_preset
  "column name"
  period_name
  "column name"
  substitute_operating_period_id
}

"unique or primary key constraints on table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
enum timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_constraint {
  "unique or primary key constraint on columns \"scheduled_stop_point_in_journey_pattern_ref_id\""
  scheduled_stop_point_in_journey_pattern_ref_pkey
  "unique or primary key constraint on columns \"scheduled_stop_point_sequence\", \"journey_pattern_ref_id\""
  service_pattern_scheduled_stop_point_in_journey_pattern_ref_idx
}

"select columns of table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
enum timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_select_column {
  "column name"
  journey_pattern_ref_id
  "column name"
  scheduled_stop_point_in_journey_pattern_ref_id
  "column name"
  scheduled_stop_point_label
  "column name"
  scheduled_stop_point_sequence
  "column name"
  timing_place_label
}

"update columns of table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
enum timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_update_column {
  "column name"
  journey_pattern_ref_id
  "column name"
  scheduled_stop_point_in_journey_pattern_ref_id
  "column name"
  scheduled_stop_point_label
  "column name"
  scheduled_stop_point_sequence
  "column name"
  timing_place_label
}

"unique or primary key constraints on table \"vehicle_journey.vehicle_journey\""
enum timetables_vehicle_journey_vehicle_journey_constraint {
  "unique or primary key constraint on columns \"vehicle_journey_id\""
  vehicle_journey_pkey
}

"select columns of table \"vehicle_journey.vehicle_journey\""
enum timetables_vehicle_journey_vehicle_journey_select_column {
  "column name"
  block_id
  "column name"
  contract_number
  "column name"
  displayed_name
  "column name"
  is_backup_journey
  "column name"
  is_extra_journey
  "column name"
  is_vehicle_type_mandatory
  "column name"
  journey_name_i18n
  "column name"
  journey_pattern_ref_id
  "column name"
  journey_type
  "column name"
  layover_time
  "column name"
  turnaround_time
  "column name"
  vehicle_journey_id
}

"select \"vehicle_journey_vehicle_journey_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"vehicle_journey.vehicle_journey\""
enum timetables_vehicle_journey_vehicle_journey_select_column_vehicle_journey_vehicle_journey_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  is_backup_journey
  "column name"
  is_extra_journey
  "column name"
  is_vehicle_type_mandatory
}

"select \"vehicle_journey_vehicle_journey_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"vehicle_journey.vehicle_journey\""
enum timetables_vehicle_journey_vehicle_journey_select_column_vehicle_journey_vehicle_journey_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  is_backup_journey
  "column name"
  is_extra_journey
  "column name"
  is_vehicle_type_mandatory
}

"update columns of table \"vehicle_journey.vehicle_journey\""
enum timetables_vehicle_journey_vehicle_journey_update_column {
  "column name"
  block_id
  "column name"
  contract_number
  "column name"
  displayed_name
  "column name"
  is_backup_journey
  "column name"
  is_extra_journey
  "column name"
  is_vehicle_type_mandatory
  "column name"
  journey_name_i18n
  "column name"
  journey_pattern_ref_id
  "column name"
  journey_type
  "column name"
  layover_time
  "column name"
  turnaround_time
  "column name"
  vehicle_journey_id
}

"unique or primary key constraints on table \"vehicle_schedule.vehicle_schedule_frame\""
enum timetables_vehicle_schedule_vehicle_schedule_frame_constraint {
  "unique or primary key constraint on columns \"vehicle_schedule_frame_id\""
  vehicle_schedule_frame_pkey
}

"select columns of table \"vehicle_schedule.vehicle_schedule_frame\""
enum timetables_vehicle_schedule_vehicle_schedule_frame_select_column {
  "column name"
  booking_description_i18n
  "column name"
  booking_label
  "column name"
  created_at
  "column name"
  label
  "column name"
  name_i18n
  "column name"
  priority
  "column name"
  validity_end
  "column name"
  validity_range
  "column name"
  validity_start
  "column name"
  vehicle_schedule_frame_id
}

"update columns of table \"vehicle_schedule.vehicle_schedule_frame\""
enum timetables_vehicle_schedule_vehicle_schedule_frame_update_column {
  "column name"
  booking_description_i18n
  "column name"
  booking_label
  "column name"
  created_at
  "column name"
  label
  "column name"
  name_i18n
  "column name"
  priority
  "column name"
  validity_end
  "column name"
  validity_start
  "column name"
  vehicle_schedule_frame_id
}

"unique or primary key constraints on table \"vehicle_service.block\""
enum timetables_vehicle_service_block_constraint {
  "unique or primary key constraint on columns \"block_id\""
  block_pkey
}

"select columns of table \"vehicle_service.block\""
enum timetables_vehicle_service_block_select_column {
  "column name"
  block_id
  "column name"
  finishing_time
  "column name"
  preparing_time
  "column name"
  vehicle_service_id
  "column name"
  vehicle_type_id
}

"update columns of table \"vehicle_service.block\""
enum timetables_vehicle_service_block_update_column {
  "column name"
  block_id
  "column name"
  finishing_time
  "column name"
  preparing_time
  "column name"
  vehicle_service_id
  "column name"
  vehicle_type_id
}

"unique or primary key constraints on table \"vehicle_service.journey_patterns_in_vehicle_service\""
enum timetables_vehicle_service_journey_patterns_in_vehicle_service_constraint {
  "unique or primary key constraint on columns \"journey_pattern_id\", \"vehicle_service_id\""
  journey_patterns_in_vehicle_service_pkey
}

"select columns of table \"vehicle_service.journey_patterns_in_vehicle_service\""
enum timetables_vehicle_service_journey_patterns_in_vehicle_service_select_column {
  "column name"
  journey_pattern_id
  "column name"
  reference_count
  "column name"
  vehicle_service_id
}

"update columns of table \"vehicle_service.journey_patterns_in_vehicle_service\""
enum timetables_vehicle_service_journey_patterns_in_vehicle_service_update_column {
  "column name"
  journey_pattern_id
  "column name"
  reference_count
  "column name"
  vehicle_service_id
}

"unique or primary key constraints on table \"vehicle_service.vehicle_service\""
enum timetables_vehicle_service_vehicle_service_constraint {
  "unique or primary key constraint on columns \"vehicle_service_id\""
  vehicle_service_pkey
}

"select columns of table \"vehicle_service.vehicle_service\""
enum timetables_vehicle_service_vehicle_service_select_column {
  "column name"
  day_type_id
  "column name"
  name_i18n
  "column name"
  vehicle_schedule_frame_id
  "column name"
  vehicle_service_id
}

"update columns of table \"vehicle_service.vehicle_service\""
enum timetables_vehicle_service_vehicle_service_update_column {
  "column name"
  day_type_id
  "column name"
  name_i18n
  "column name"
  vehicle_schedule_frame_id
  "column name"
  vehicle_service_id
}

"unique or primary key constraints on table \"vehicle_type.vehicle_type\""
enum timetables_vehicle_type_vehicle_type_constraint {
  "unique or primary key constraint on columns \"hsl_id\""
  vehicle_type_hsl_id_idx
  "unique or primary key constraint on columns \"label\""
  vehicle_type_label_idx
  "unique or primary key constraint on columns \"vehicle_type_id\""
  vehicle_type_pkey
}

"select columns of table \"vehicle_type.vehicle_type\""
enum timetables_vehicle_type_vehicle_type_select_column {
  "column name"
  description_i18n
  "column name"
  hsl_id
  "column name"
  label
  "column name"
  vehicle_type_id
}

"update columns of table \"vehicle_type.vehicle_type\""
enum timetables_vehicle_type_vehicle_type_update_column {
  "column name"
  description_i18n
  "column name"
  hsl_id
  "column name"
  label
  "column name"
  vehicle_type_id
}

"unique or primary key constraints on table \"timing_pattern.timing_place\""
enum timing_pattern_timing_place_constraint {
  "unique or primary key constraint on columns \"label\""
  timing_place_label_idx
  "unique or primary key constraint on columns \"timing_place_id\""
  timing_place_pkey
}

"select columns of table \"timing_pattern.timing_place\""
enum timing_pattern_timing_place_select_column {
  "column name"
  description
  "column name"
  label
  "column name"
  timing_place_id
}

"update columns of table \"timing_pattern.timing_place\""
enum timing_pattern_timing_place_update_column {
  "column name"
  description
  "column name"
  label
  "column name"
  timing_place_id
}

scalar _uuid

scalar date

scalar daterange

scalar float8

scalar geography

scalar geometry

scalar interval

scalar jsonb

scalar smallint

scalar timestamptz

scalar uuid

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

input CombineTimetablesInput {
  stagingVehicleScheduleFrameIds: [uuid]!
  targetPriority: Int!
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input ReplaceTimetablesInput {
  stagingVehicleScheduleFrameIds: [uuid]!
  targetPriority: Int!
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  "does the column match the given case-insensitive pattern"
  _ilike: String
  _in: [String!]
  "does the column match the given POSIX regular expression, case insensitive"
  _iregex: String
  _is_null: Boolean
  "does the column match the given pattern"
  _like: String
  _lt: String
  _lte: String
  _neq: String
  "does the column NOT match the given case-insensitive pattern"
  _nilike: String
  _nin: [String!]
  "does the column NOT match the given POSIX regular expression, case insensitive"
  _niregex: String
  "does the column NOT match the given pattern"
  _nlike: String
  "does the column NOT match the given POSIX regular expression, case sensitive"
  _nregex: String
  "does the column NOT match the given SQL regular expression"
  _nsimilar: String
  "does the column match the given POSIX regular expression, case sensitive"
  _regex: String
  "does the column match the given SQL regular expression"
  _similar: String
}

input ToCombineTargetVehicleScheduleFrameIdInput {
  stagingVehicleScheduleFrameId: uuid!
  targetPriority: Int!
}

input ToReplaceVehicleScheduleFrameIdsInput {
  stagingVehicleScheduleFrameId: uuid!
  targetPriority: Int!
}

"Boolean expression to compare columns of type \"date\". All fields are combined with logical 'AND'."
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"Boolean expression to compare columns of type \"daterange\". All fields are combined with logical 'AND'."
input daterange_comparison_exp {
  _eq: daterange
  _gt: daterange
  _gte: daterange
  _in: [daterange!]
  _is_null: Boolean
  _lt: daterange
  _lte: daterange
  _neq: daterange
  _nin: [daterange!]
}

"Boolean expression to compare columns of type \"float8\". All fields are combined with logical 'AND'."
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

input geography_cast_exp {
  geometry: geometry_comparison_exp
}

"Boolean expression to compare columns of type \"geography\". All fields are combined with logical 'AND'."
input geography_comparison_exp {
  _cast: geography_cast_exp
  _eq: geography
  _gt: geography
  _gte: geography
  _in: [geography!]
  _is_null: Boolean
  _lt: geography
  _lte: geography
  _neq: geography
  _nin: [geography!]
  "is the column within a given distance from the given geography value"
  _st_d_within: st_d_within_geography_input
  "does the column spatially intersect the given geography value"
  _st_intersects: geography
}

input geometry_cast_exp {
  geography: geography_comparison_exp
}

"Boolean expression to compare columns of type \"geometry\". All fields are combined with logical 'AND'."
input geometry_comparison_exp {
  _cast: geometry_cast_exp
  _eq: geometry
  _gt: geometry
  _gte: geometry
  _in: [geometry!]
  _is_null: Boolean
  _lt: geometry
  _lte: geometry
  _neq: geometry
  _nin: [geometry!]
  "is the column within a given 3D distance from the given geometry value"
  _st_3d_d_within: st_d_within_input
  "does the column spatially intersect the given geometry value in 3D"
  _st_3d_intersects: geometry
  "does the column contain the given geometry value"
  _st_contains: geometry
  "does the column cross the given geometry value"
  _st_crosses: geometry
  "is the column within a given distance from the given geometry value"
  _st_d_within: st_d_within_input
  "is the column equal to given geometry value (directionality is ignored)"
  _st_equals: geometry
  "does the column spatially intersect the given geometry value"
  _st_intersects: geometry
  "does the column 'spatially overlap' (intersect but not completely contain) the given geometry value"
  _st_overlaps: geometry
  "does the column have atleast one point in common with the given geometry value"
  _st_touches: geometry
  "is the column contained in the given geometry value"
  _st_within: geometry
}

"Boolean expression to filter rows from the table \"hsl_route.legacy_hsl_municipality_code\". All fields are combined with a logical 'AND'."
input hsl_route_legacy_hsl_municipality_code_bool_exp {
  _and: [hsl_route_legacy_hsl_municipality_code_bool_exp!]
  _not: hsl_route_legacy_hsl_municipality_code_bool_exp
  _or: [hsl_route_legacy_hsl_municipality_code_bool_exp!]
  hsl_municipality: String_comparison_exp
  jore3_code: smallint_comparison_exp
  lines: route_line_bool_exp
  lines_aggregate: route_line_aggregate_bool_exp
  routes: route_route_bool_exp
  routes_aggregate: route_route_aggregate_bool_exp
}

"input type for incrementing numeric columns in table \"hsl_route.legacy_hsl_municipality_code\""
input hsl_route_legacy_hsl_municipality_code_inc_input {
  jore3_code: smallint
}

"input type for inserting data into table \"hsl_route.legacy_hsl_municipality_code\""
input hsl_route_legacy_hsl_municipality_code_insert_input {
  hsl_municipality: String
  jore3_code: smallint
  lines: route_line_arr_rel_insert_input
  routes: route_route_arr_rel_insert_input
}

"input type for inserting object relation for remote table \"hsl_route.legacy_hsl_municipality_code\""
input hsl_route_legacy_hsl_municipality_code_obj_rel_insert_input {
  data: hsl_route_legacy_hsl_municipality_code_insert_input!
  "upsert condition"
  on_conflict: hsl_route_legacy_hsl_municipality_code_on_conflict
}

"on_conflict condition type for table \"hsl_route.legacy_hsl_municipality_code\""
input hsl_route_legacy_hsl_municipality_code_on_conflict {
  constraint: hsl_route_legacy_hsl_municipality_code_constraint!
  update_columns: [hsl_route_legacy_hsl_municipality_code_update_column!]! = []
  where: hsl_route_legacy_hsl_municipality_code_bool_exp
}

"Ordering options when selecting data from \"hsl_route.legacy_hsl_municipality_code\"."
input hsl_route_legacy_hsl_municipality_code_order_by {
  hsl_municipality: order_by
  jore3_code: order_by
  lines_aggregate: route_line_aggregate_order_by
  routes_aggregate: route_route_aggregate_order_by
}

"primary key columns input for table: hsl_route.legacy_hsl_municipality_code"
input hsl_route_legacy_hsl_municipality_code_pk_columns_input {
  hsl_municipality: String!
}

"input type for updating data in table \"hsl_route.legacy_hsl_municipality_code\""
input hsl_route_legacy_hsl_municipality_code_set_input {
  hsl_municipality: String
  jore3_code: smallint
}

"Streaming cursor of the table \"hsl_route_legacy_hsl_municipality_code\""
input hsl_route_legacy_hsl_municipality_code_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: hsl_route_legacy_hsl_municipality_code_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input hsl_route_legacy_hsl_municipality_code_stream_cursor_value_input {
  hsl_municipality: String
  jore3_code: smallint
}

input hsl_route_legacy_hsl_municipality_code_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: hsl_route_legacy_hsl_municipality_code_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: hsl_route_legacy_hsl_municipality_code_set_input
  "filter the rows which have to be updated"
  where: hsl_route_legacy_hsl_municipality_code_bool_exp!
}

"Boolean expression to filter rows from the table \"hsl_route.transport_target\". All fields are combined with a logical 'AND'."
input hsl_route_transport_target_bool_exp {
  _and: [hsl_route_transport_target_bool_exp!]
  _not: hsl_route_transport_target_bool_exp
  _or: [hsl_route_transport_target_bool_exp!]
  lines: route_line_bool_exp
  lines_aggregate: route_line_aggregate_bool_exp
  transport_target: String_comparison_exp
}

"Boolean expression to compare columns of type \"hsl_route_transport_target_enum\". All fields are combined with logical 'AND'."
input hsl_route_transport_target_enum_comparison_exp {
  _eq: hsl_route_transport_target_enum
  _in: [hsl_route_transport_target_enum!]
  _is_null: Boolean
  _neq: hsl_route_transport_target_enum
  _nin: [hsl_route_transport_target_enum!]
}

"input type for inserting data into table \"hsl_route.transport_target\""
input hsl_route_transport_target_insert_input {
  lines: route_line_arr_rel_insert_input
  transport_target: String
}

"input type for inserting object relation for remote table \"hsl_route.transport_target\""
input hsl_route_transport_target_obj_rel_insert_input {
  data: hsl_route_transport_target_insert_input!
  "upsert condition"
  on_conflict: hsl_route_transport_target_on_conflict
}

"on_conflict condition type for table \"hsl_route.transport_target\""
input hsl_route_transport_target_on_conflict {
  constraint: hsl_route_transport_target_constraint!
  update_columns: [hsl_route_transport_target_update_column!]! = []
  where: hsl_route_transport_target_bool_exp
}

"Ordering options when selecting data from \"hsl_route.transport_target\"."
input hsl_route_transport_target_order_by {
  lines_aggregate: route_line_aggregate_order_by
  transport_target: order_by
}

"primary key columns input for table: hsl_route.transport_target"
input hsl_route_transport_target_pk_columns_input {
  transport_target: String!
}

"input type for updating data in table \"hsl_route.transport_target\""
input hsl_route_transport_target_set_input {
  transport_target: String
}

"Streaming cursor of the table \"hsl_route_transport_target\""
input hsl_route_transport_target_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: hsl_route_transport_target_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input hsl_route_transport_target_stream_cursor_value_input {
  transport_target: String
}

input hsl_route_transport_target_updates {
  "sets the columns of the filtered rows to the given values"
  _set: hsl_route_transport_target_set_input
  "filter the rows which have to be updated"
  where: hsl_route_transport_target_bool_exp!
}

"Boolean expression to filter rows from the table \"infrastructure_network.direction\". All fields are combined with a logical 'AND'."
input infrastructure_network_direction_bool_exp {
  _and: [infrastructure_network_direction_bool_exp!]
  _not: infrastructure_network_direction_bool_exp
  _or: [infrastructure_network_direction_bool_exp!]
  infrastructure_links: infrastructure_network_infrastructure_link_bool_exp
  infrastructure_links_aggregate: infrastructure_network_infrastructure_link_aggregate_bool_exp
  value: String_comparison_exp
}

"Boolean expression to compare columns of type \"infrastructure_network_direction_enum\". All fields are combined with logical 'AND'."
input infrastructure_network_direction_enum_comparison_exp {
  _eq: infrastructure_network_direction_enum
  _in: [infrastructure_network_direction_enum!]
  _is_null: Boolean
  _neq: infrastructure_network_direction_enum
  _nin: [infrastructure_network_direction_enum!]
}

"input type for inserting data into table \"infrastructure_network.direction\""
input infrastructure_network_direction_insert_input {
  infrastructure_links: infrastructure_network_infrastructure_link_arr_rel_insert_input
  value: String
}

"input type for inserting object relation for remote table \"infrastructure_network.direction\""
input infrastructure_network_direction_obj_rel_insert_input {
  data: infrastructure_network_direction_insert_input!
  "upsert condition"
  on_conflict: infrastructure_network_direction_on_conflict
}

"on_conflict condition type for table \"infrastructure_network.direction\""
input infrastructure_network_direction_on_conflict {
  constraint: infrastructure_network_direction_constraint!
  update_columns: [infrastructure_network_direction_update_column!]! = []
  where: infrastructure_network_direction_bool_exp
}

"Ordering options when selecting data from \"infrastructure_network.direction\"."
input infrastructure_network_direction_order_by {
  infrastructure_links_aggregate: infrastructure_network_infrastructure_link_aggregate_order_by
  value: order_by
}

"primary key columns input for table: infrastructure_network.direction"
input infrastructure_network_direction_pk_columns_input {
  value: String!
}

"input type for updating data in table \"infrastructure_network.direction\""
input infrastructure_network_direction_set_input {
  value: String
}

"Streaming cursor of the table \"infrastructure_network_direction\""
input infrastructure_network_direction_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: infrastructure_network_direction_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input infrastructure_network_direction_stream_cursor_value_input {
  value: String
}

input infrastructure_network_direction_updates {
  "sets the columns of the filtered rows to the given values"
  _set: infrastructure_network_direction_set_input
  "filter the rows which have to be updated"
  where: infrastructure_network_direction_bool_exp!
}

"Boolean expression to filter rows from the table \"infrastructure_network.external_source\". All fields are combined with a logical 'AND'."
input infrastructure_network_external_source_bool_exp {
  _and: [infrastructure_network_external_source_bool_exp!]
  _not: infrastructure_network_external_source_bool_exp
  _or: [infrastructure_network_external_source_bool_exp!]
  infrastructure_links: infrastructure_network_infrastructure_link_bool_exp
  infrastructure_links_aggregate: infrastructure_network_infrastructure_link_aggregate_bool_exp
  value: String_comparison_exp
}

"Boolean expression to compare columns of type \"infrastructure_network_external_source_enum\". All fields are combined with logical 'AND'."
input infrastructure_network_external_source_enum_comparison_exp {
  _eq: infrastructure_network_external_source_enum
  _in: [infrastructure_network_external_source_enum!]
  _is_null: Boolean
  _neq: infrastructure_network_external_source_enum
  _nin: [infrastructure_network_external_source_enum!]
}

"input type for inserting data into table \"infrastructure_network.external_source\""
input infrastructure_network_external_source_insert_input {
  infrastructure_links: infrastructure_network_infrastructure_link_arr_rel_insert_input
  value: String
}

"input type for inserting object relation for remote table \"infrastructure_network.external_source\""
input infrastructure_network_external_source_obj_rel_insert_input {
  data: infrastructure_network_external_source_insert_input!
  "upsert condition"
  on_conflict: infrastructure_network_external_source_on_conflict
}

"on_conflict condition type for table \"infrastructure_network.external_source\""
input infrastructure_network_external_source_on_conflict {
  constraint: infrastructure_network_external_source_constraint!
  update_columns: [infrastructure_network_external_source_update_column!]! = []
  where: infrastructure_network_external_source_bool_exp
}

"Ordering options when selecting data from \"infrastructure_network.external_source\"."
input infrastructure_network_external_source_order_by {
  infrastructure_links_aggregate: infrastructure_network_infrastructure_link_aggregate_order_by
  value: order_by
}

"primary key columns input for table: infrastructure_network.external_source"
input infrastructure_network_external_source_pk_columns_input {
  value: String!
}

"input type for updating data in table \"infrastructure_network.external_source\""
input infrastructure_network_external_source_set_input {
  value: String
}

"Streaming cursor of the table \"infrastructure_network_external_source\""
input infrastructure_network_external_source_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: infrastructure_network_external_source_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input infrastructure_network_external_source_stream_cursor_value_input {
  value: String
}

input infrastructure_network_external_source_updates {
  "sets the columns of the filtered rows to the given values"
  _set: infrastructure_network_external_source_set_input
  "filter the rows which have to be updated"
  where: infrastructure_network_external_source_bool_exp!
}

input infrastructure_network_find_point_direction_on_link_args {
  infrastructure_link_uuid: uuid
  point_max_distance_in_meters: float8
  point_of_interest: geography
}

input infrastructure_network_infrastructure_link_aggregate_bool_exp {
  avg: infrastructure_network_infrastructure_link_aggregate_bool_exp_avg
  corr: infrastructure_network_infrastructure_link_aggregate_bool_exp_corr
  count: infrastructure_network_infrastructure_link_aggregate_bool_exp_count
  covar_samp: infrastructure_network_infrastructure_link_aggregate_bool_exp_covar_samp
  max: infrastructure_network_infrastructure_link_aggregate_bool_exp_max
  min: infrastructure_network_infrastructure_link_aggregate_bool_exp_min
  stddev_samp: infrastructure_network_infrastructure_link_aggregate_bool_exp_stddev_samp
  sum: infrastructure_network_infrastructure_link_aggregate_bool_exp_sum
  var_samp: infrastructure_network_infrastructure_link_aggregate_bool_exp_var_samp
}

input infrastructure_network_infrastructure_link_aggregate_bool_exp_avg {
  arguments: infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_avg_arguments_columns!
  distinct: Boolean
  filter: infrastructure_network_infrastructure_link_bool_exp
  predicate: float8_comparison_exp!
}

input infrastructure_network_infrastructure_link_aggregate_bool_exp_corr {
  arguments: infrastructure_network_infrastructure_link_aggregate_bool_exp_corr_arguments!
  distinct: Boolean
  filter: infrastructure_network_infrastructure_link_bool_exp
  predicate: float8_comparison_exp!
}

input infrastructure_network_infrastructure_link_aggregate_bool_exp_corr_arguments {
  X: infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_corr_arguments_columns!
  Y: infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_corr_arguments_columns!
}

input infrastructure_network_infrastructure_link_aggregate_bool_exp_count {
  arguments: [infrastructure_network_infrastructure_link_select_column!]
  distinct: Boolean
  filter: infrastructure_network_infrastructure_link_bool_exp
  predicate: Int_comparison_exp!
}

input infrastructure_network_infrastructure_link_aggregate_bool_exp_covar_samp {
  arguments: infrastructure_network_infrastructure_link_aggregate_bool_exp_covar_samp_arguments!
  distinct: Boolean
  filter: infrastructure_network_infrastructure_link_bool_exp
  predicate: float8_comparison_exp!
}

input infrastructure_network_infrastructure_link_aggregate_bool_exp_covar_samp_arguments {
  X: infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_covar_samp_arguments_columns!
  Y: infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_covar_samp_arguments_columns!
}

input infrastructure_network_infrastructure_link_aggregate_bool_exp_max {
  arguments: infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_max_arguments_columns!
  distinct: Boolean
  filter: infrastructure_network_infrastructure_link_bool_exp
  predicate: float8_comparison_exp!
}

input infrastructure_network_infrastructure_link_aggregate_bool_exp_min {
  arguments: infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_min_arguments_columns!
  distinct: Boolean
  filter: infrastructure_network_infrastructure_link_bool_exp
  predicate: float8_comparison_exp!
}

input infrastructure_network_infrastructure_link_aggregate_bool_exp_stddev_samp {
  arguments: infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_stddev_samp_arguments_columns!
  distinct: Boolean
  filter: infrastructure_network_infrastructure_link_bool_exp
  predicate: float8_comparison_exp!
}

input infrastructure_network_infrastructure_link_aggregate_bool_exp_sum {
  arguments: infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_sum_arguments_columns!
  distinct: Boolean
  filter: infrastructure_network_infrastructure_link_bool_exp
  predicate: float8_comparison_exp!
}

input infrastructure_network_infrastructure_link_aggregate_bool_exp_var_samp {
  arguments: infrastructure_network_infrastructure_link_select_column_infrastructure_network_infrastructure_link_aggregate_bool_exp_var_samp_arguments_columns!
  distinct: Boolean
  filter: infrastructure_network_infrastructure_link_bool_exp
  predicate: float8_comparison_exp!
}

"order by aggregate values of table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_aggregate_order_by {
  avg: infrastructure_network_infrastructure_link_avg_order_by
  count: order_by
  max: infrastructure_network_infrastructure_link_max_order_by
  min: infrastructure_network_infrastructure_link_min_order_by
  stddev: infrastructure_network_infrastructure_link_stddev_order_by
  stddev_pop: infrastructure_network_infrastructure_link_stddev_pop_order_by
  stddev_samp: infrastructure_network_infrastructure_link_stddev_samp_order_by
  sum: infrastructure_network_infrastructure_link_sum_order_by
  var_pop: infrastructure_network_infrastructure_link_var_pop_order_by
  var_samp: infrastructure_network_infrastructure_link_var_samp_order_by
  variance: infrastructure_network_infrastructure_link_variance_order_by
}

"input type for inserting array relation for remote table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_arr_rel_insert_input {
  data: [infrastructure_network_infrastructure_link_insert_input!]!
  "upsert condition"
  on_conflict: infrastructure_network_infrastructure_link_on_conflict
}

"order by avg() on columns of table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_avg_order_by {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: order_by
}

"Boolean expression to filter rows from the table \"infrastructure_network.infrastructure_link\". All fields are combined with a logical 'AND'."
input infrastructure_network_infrastructure_link_bool_exp {
  _and: [infrastructure_network_infrastructure_link_bool_exp!]
  _not: infrastructure_network_infrastructure_link_bool_exp
  _or: [infrastructure_network_infrastructure_link_bool_exp!]
  direction: infrastructure_network_direction_enum_comparison_exp
  directionByDirection: infrastructure_network_direction_bool_exp
  estimated_length_in_metres: float8_comparison_exp
  external_link_id: String_comparison_exp
  external_link_source: infrastructure_network_external_source_enum_comparison_exp
  external_source: infrastructure_network_external_source_bool_exp
  infrastructure_link_along_routes: route_infrastructure_link_along_route_bool_exp
  infrastructure_link_along_routes_aggregate: route_infrastructure_link_along_route_aggregate_bool_exp
  infrastructure_link_id: uuid_comparison_exp
  scheduled_stop_points_located_on_infrastructure_link: service_pattern_scheduled_stop_point_bool_exp
  scheduled_stop_points_located_on_infrastructure_link_aggregate: service_pattern_scheduled_stop_point_aggregate_bool_exp
  shape: geography_comparison_exp
  vehicle_submode_on_infrastructure_link: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  vehicle_submode_on_infrastructure_link_aggregate: infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate_bool_exp
  vehicle_submode_on_infrastructure_links: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  vehicle_submode_on_infrastructure_links_aggregate: infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate_bool_exp
}

"input type for incrementing numeric columns in table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_inc_input {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: float8
}

"input type for inserting data into table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_insert_input {
  "The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string."
  direction: infrastructure_network_direction_enum
  directionByDirection: infrastructure_network_direction_obj_rel_insert_input
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: float8
  external_link_id: String
  external_link_source: infrastructure_network_external_source_enum
  external_source: infrastructure_network_external_source_obj_rel_insert_input
  infrastructure_link_along_routes: route_infrastructure_link_along_route_arr_rel_insert_input
  "The ID of the infrastructure link."
  infrastructure_link_id: uuid
  scheduled_stop_points_located_on_infrastructure_link: service_pattern_scheduled_stop_point_arr_rel_insert_input
  "A PostGIS LinestringZ geography in EPSG:4326 describing the infrastructure link."
  shape: geography
  vehicle_submode_on_infrastructure_link: infrastructure_network_vehicle_submode_on_infrastructure_link_arr_rel_insert_input
  vehicle_submode_on_infrastructure_links: infrastructure_network_vehicle_submode_on_infrastructure_link_arr_rel_insert_input
}

"order by max() on columns of table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_max_order_by {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: order_by
  external_link_id: order_by
  "The ID of the infrastructure link."
  infrastructure_link_id: order_by
}

"order by min() on columns of table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_min_order_by {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: order_by
  external_link_id: order_by
  "The ID of the infrastructure link."
  infrastructure_link_id: order_by
}

"input type for inserting object relation for remote table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_obj_rel_insert_input {
  data: infrastructure_network_infrastructure_link_insert_input!
  "upsert condition"
  on_conflict: infrastructure_network_infrastructure_link_on_conflict
}

"on_conflict condition type for table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_on_conflict {
  constraint: infrastructure_network_infrastructure_link_constraint!
  update_columns: [infrastructure_network_infrastructure_link_update_column!]! = []
  where: infrastructure_network_infrastructure_link_bool_exp
}

"Ordering options when selecting data from \"infrastructure_network.infrastructure_link\"."
input infrastructure_network_infrastructure_link_order_by {
  direction: order_by
  directionByDirection: infrastructure_network_direction_order_by
  estimated_length_in_metres: order_by
  external_link_id: order_by
  external_link_source: order_by
  external_source: infrastructure_network_external_source_order_by
  infrastructure_link_along_routes_aggregate: route_infrastructure_link_along_route_aggregate_order_by
  infrastructure_link_id: order_by
  scheduled_stop_points_located_on_infrastructure_link_aggregate: service_pattern_scheduled_stop_point_aggregate_order_by
  shape: order_by
  vehicle_submode_on_infrastructure_link_aggregate: infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate_order_by
  vehicle_submode_on_infrastructure_links_aggregate: infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate_order_by
}

"primary key columns input for table: infrastructure_network.infrastructure_link"
input infrastructure_network_infrastructure_link_pk_columns_input {
  "The ID of the infrastructure link."
  infrastructure_link_id: uuid!
}

"input type for updating data in table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_set_input {
  "The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string."
  direction: infrastructure_network_direction_enum
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: float8
  external_link_id: String
  external_link_source: infrastructure_network_external_source_enum
  "The ID of the infrastructure link."
  infrastructure_link_id: uuid
  "A PostGIS LinestringZ geography in EPSG:4326 describing the infrastructure link."
  shape: geography
}

"order by stddev() on columns of table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_stddev_order_by {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: order_by
}

"order by stddev_pop() on columns of table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_stddev_pop_order_by {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: order_by
}

"order by stddev_samp() on columns of table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_stddev_samp_order_by {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: order_by
}

"Streaming cursor of the table \"infrastructure_network_infrastructure_link\""
input infrastructure_network_infrastructure_link_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: infrastructure_network_infrastructure_link_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input infrastructure_network_infrastructure_link_stream_cursor_value_input {
  "The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string."
  direction: infrastructure_network_direction_enum
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: float8
  external_link_id: String
  external_link_source: infrastructure_network_external_source_enum
  "The ID of the infrastructure link."
  infrastructure_link_id: uuid
  "A PostGIS LinestringZ geography in EPSG:4326 describing the infrastructure link."
  shape: geography
}

"order by sum() on columns of table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_sum_order_by {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: order_by
}

input infrastructure_network_infrastructure_link_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: infrastructure_network_infrastructure_link_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: infrastructure_network_infrastructure_link_set_input
  "filter the rows which have to be updated"
  where: infrastructure_network_infrastructure_link_bool_exp!
}

"order by var_pop() on columns of table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_var_pop_order_by {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: order_by
}

"order by var_samp() on columns of table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_var_samp_order_by {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: order_by
}

"order by variance() on columns of table \"infrastructure_network.infrastructure_link\""
input infrastructure_network_infrastructure_link_variance_order_by {
  "The estimated length of the infrastructure link in metres."
  estimated_length_in_metres: order_by
}

input infrastructure_network_resolve_point_to_closest_link_args {
  geog: geography
}

input infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate_bool_exp {
  count: infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate_bool_exp_count
}

input infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate_bool_exp_count {
  arguments: [infrastructure_network_vehicle_submode_on_infrastructure_link_select_column!]
  distinct: Boolean
  filter: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
input infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate_order_by {
  count: order_by
  max: infrastructure_network_vehicle_submode_on_infrastructure_link_max_order_by
  min: infrastructure_network_vehicle_submode_on_infrastructure_link_min_order_by
}

"input type for inserting array relation for remote table \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
input infrastructure_network_vehicle_submode_on_infrastructure_link_arr_rel_insert_input {
  data: [infrastructure_network_vehicle_submode_on_infrastructure_link_insert_input!]!
  "upsert condition"
  on_conflict: infrastructure_network_vehicle_submode_on_infrastructure_link_on_conflict
}

"Boolean expression to filter rows from the table \"infrastructure_network.vehicle_submode_on_infrastructure_link\". All fields are combined with a logical 'AND'."
input infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp {
  _and: [infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp!]
  _not: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  _or: [infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp!]
  infrastructure_link: infrastructure_network_infrastructure_link_bool_exp
  infrastructure_link_id: uuid_comparison_exp
  vehicleSubmodeByVehicleSubmode: reusable_components_vehicle_submode_bool_exp
  vehicle_submode: reusable_components_vehicle_submode_enum_comparison_exp
}

"input type for inserting data into table \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
input infrastructure_network_vehicle_submode_on_infrastructure_link_insert_input {
  infrastructure_link: infrastructure_network_infrastructure_link_obj_rel_insert_input
  "The infrastructure link that can be safely traversed by the vehicle submode."
  infrastructure_link_id: uuid
  vehicleSubmodeByVehicleSubmode: reusable_components_vehicle_submode_obj_rel_insert_input
  "The vehicle submode that can safely traverse the infrastructure link."
  vehicle_submode: reusable_components_vehicle_submode_enum
}

"order by max() on columns of table \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
input infrastructure_network_vehicle_submode_on_infrastructure_link_max_order_by {
  "The infrastructure link that can be safely traversed by the vehicle submode."
  infrastructure_link_id: order_by
}

"order by min() on columns of table \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
input infrastructure_network_vehicle_submode_on_infrastructure_link_min_order_by {
  "The infrastructure link that can be safely traversed by the vehicle submode."
  infrastructure_link_id: order_by
}

"on_conflict condition type for table \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
input infrastructure_network_vehicle_submode_on_infrastructure_link_on_conflict {
  constraint: infrastructure_network_vehicle_submode_on_infrastructure_link_constraint!
  update_columns: [infrastructure_network_vehicle_submode_on_infrastructure_link_update_column!]! = []
  where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
}

"Ordering options when selecting data from \"infrastructure_network.vehicle_submode_on_infrastructure_link\"."
input infrastructure_network_vehicle_submode_on_infrastructure_link_order_by {
  infrastructure_link: infrastructure_network_infrastructure_link_order_by
  infrastructure_link_id: order_by
  vehicleSubmodeByVehicleSubmode: reusable_components_vehicle_submode_order_by
  vehicle_submode: order_by
}

"primary key columns input for table: infrastructure_network.vehicle_submode_on_infrastructure_link"
input infrastructure_network_vehicle_submode_on_infrastructure_link_pk_columns_input {
  "The infrastructure link that can be safely traversed by the vehicle submode."
  infrastructure_link_id: uuid!
  "The vehicle submode that can safely traverse the infrastructure link."
  vehicle_submode: reusable_components_vehicle_submode_enum!
}

"input type for updating data in table \"infrastructure_network.vehicle_submode_on_infrastructure_link\""
input infrastructure_network_vehicle_submode_on_infrastructure_link_set_input {
  "The infrastructure link that can be safely traversed by the vehicle submode."
  infrastructure_link_id: uuid
  "The vehicle submode that can safely traverse the infrastructure link."
  vehicle_submode: reusable_components_vehicle_submode_enum
}

"Streaming cursor of the table \"infrastructure_network_vehicle_submode_on_infrastructure_link\""
input infrastructure_network_vehicle_submode_on_infrastructure_link_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: infrastructure_network_vehicle_submode_on_infrastructure_link_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input infrastructure_network_vehicle_submode_on_infrastructure_link_stream_cursor_value_input {
  "The infrastructure link that can be safely traversed by the vehicle submode."
  infrastructure_link_id: uuid
  "The vehicle submode that can safely traverse the infrastructure link."
  vehicle_submode: reusable_components_vehicle_submode_enum
}

input infrastructure_network_vehicle_submode_on_infrastructure_link_updates {
  "sets the columns of the filtered rows to the given values"
  _set: infrastructure_network_vehicle_submode_on_infrastructure_link_set_input
  "filter the rows which have to be updated"
  where: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp!
}

"Boolean expression to compare columns of type \"interval\". All fields are combined with logical 'AND'."
input interval_comparison_exp {
  _eq: interval
  _gt: interval
  _gte: interval
  _in: [interval!]
  _is_null: Boolean
  _lt: interval
  _lte: interval
  _neq: interval
  _nin: [interval!]
}

input journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point_args {
  new_direction: String
  new_label: String
  new_located_on_infrastructure_link_id: uuid
  new_measured_location: geography
  new_priority: Int
  new_validity_end: date
  new_validity_start: date
  replace_scheduled_stop_point_id: uuid
}

input journey_pattern_journey_pattern_aggregate_bool_exp {
  count: journey_pattern_journey_pattern_aggregate_bool_exp_count
}

input journey_pattern_journey_pattern_aggregate_bool_exp_count {
  arguments: [journey_pattern_journey_pattern_select_column!]
  distinct: Boolean
  filter: journey_pattern_journey_pattern_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"journey_pattern.journey_pattern\""
input journey_pattern_journey_pattern_aggregate_order_by {
  count: order_by
  max: journey_pattern_journey_pattern_max_order_by
  min: journey_pattern_journey_pattern_min_order_by
}

"input type for inserting array relation for remote table \"journey_pattern.journey_pattern\""
input journey_pattern_journey_pattern_arr_rel_insert_input {
  data: [journey_pattern_journey_pattern_insert_input!]!
  "upsert condition"
  on_conflict: journey_pattern_journey_pattern_on_conflict
}

"Boolean expression to filter rows from the table \"journey_pattern.journey_pattern\". All fields are combined with a logical 'AND'."
input journey_pattern_journey_pattern_bool_exp {
  _and: [journey_pattern_journey_pattern_bool_exp!]
  _not: journey_pattern_journey_pattern_bool_exp
  _or: [journey_pattern_journey_pattern_bool_exp!]
  journey_pattern_id: uuid_comparison_exp
  journey_pattern_route: route_route_bool_exp
  on_route_id: uuid_comparison_exp
  scheduled_stop_point_in_journey_patterns: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  scheduled_stop_point_in_journey_patterns_aggregate: journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp
}

"input type for inserting data into table \"journey_pattern.journey_pattern\""
input journey_pattern_journey_pattern_insert_input {
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  journey_pattern_route: route_route_obj_rel_insert_input
  "The ID of the route the journey pattern is on."
  on_route_id: uuid
  scheduled_stop_point_in_journey_patterns: journey_pattern_scheduled_stop_point_in_journey_pattern_arr_rel_insert_input
}

"order by max() on columns of table \"journey_pattern.journey_pattern\""
input journey_pattern_journey_pattern_max_order_by {
  "The ID of the journey pattern."
  journey_pattern_id: order_by
  "The ID of the route the journey pattern is on."
  on_route_id: order_by
}

"order by min() on columns of table \"journey_pattern.journey_pattern\""
input journey_pattern_journey_pattern_min_order_by {
  "The ID of the journey pattern."
  journey_pattern_id: order_by
  "The ID of the route the journey pattern is on."
  on_route_id: order_by
}

"input type for inserting object relation for remote table \"journey_pattern.journey_pattern\""
input journey_pattern_journey_pattern_obj_rel_insert_input {
  data: journey_pattern_journey_pattern_insert_input!
  "upsert condition"
  on_conflict: journey_pattern_journey_pattern_on_conflict
}

"on_conflict condition type for table \"journey_pattern.journey_pattern\""
input journey_pattern_journey_pattern_on_conflict {
  constraint: journey_pattern_journey_pattern_constraint!
  update_columns: [journey_pattern_journey_pattern_update_column!]! = []
  where: journey_pattern_journey_pattern_bool_exp
}

"Ordering options when selecting data from \"journey_pattern.journey_pattern\"."
input journey_pattern_journey_pattern_order_by {
  journey_pattern_id: order_by
  journey_pattern_route: route_route_order_by
  on_route_id: order_by
  scheduled_stop_point_in_journey_patterns_aggregate: journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_order_by
}

"primary key columns input for table: journey_pattern.journey_pattern"
input journey_pattern_journey_pattern_pk_columns_input {
  "The ID of the journey pattern."
  journey_pattern_id: uuid!
}

"input type for updating data in table \"journey_pattern.journey_pattern\""
input journey_pattern_journey_pattern_set_input {
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  "The ID of the route the journey pattern is on."
  on_route_id: uuid
}

"Streaming cursor of the table \"journey_pattern_journey_pattern\""
input journey_pattern_journey_pattern_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: journey_pattern_journey_pattern_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input journey_pattern_journey_pattern_stream_cursor_value_input {
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  "The ID of the route the journey pattern is on."
  on_route_id: uuid
}

input journey_pattern_journey_pattern_updates {
  "sets the columns of the filtered rows to the given values"
  _set: journey_pattern_journey_pattern_set_input
  "filter the rows which have to be updated"
  where: journey_pattern_journey_pattern_bool_exp!
}

input journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp {
  bool_and: journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_bool_and
  bool_or: journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_bool_or
  count: journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_count
}

input journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_bool_and {
  arguments: journey_pattern_scheduled_stop_point_in_journey_pattern_select_column_journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  predicate: Boolean_comparison_exp!
}

input journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_bool_or {
  arguments: journey_pattern_scheduled_stop_point_in_journey_pattern_select_column_journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  predicate: Boolean_comparison_exp!
}

input journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_count {
  arguments: [journey_pattern_scheduled_stop_point_in_journey_pattern_select_column!]
  distinct: Boolean
  filter: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_order_by {
  avg: journey_pattern_scheduled_stop_point_in_journey_pattern_avg_order_by
  count: order_by
  max: journey_pattern_scheduled_stop_point_in_journey_pattern_max_order_by
  min: journey_pattern_scheduled_stop_point_in_journey_pattern_min_order_by
  stddev: journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_order_by
  stddev_pop: journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_pop_order_by
  stddev_samp: journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_samp_order_by
  sum: journey_pattern_scheduled_stop_point_in_journey_pattern_sum_order_by
  var_pop: journey_pattern_scheduled_stop_point_in_journey_pattern_var_pop_order_by
  var_samp: journey_pattern_scheduled_stop_point_in_journey_pattern_var_samp_order_by
  variance: journey_pattern_scheduled_stop_point_in_journey_pattern_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input journey_pattern_scheduled_stop_point_in_journey_pattern_append_input {
  via_point_name_i18n: jsonb
  via_point_short_name_i18n: jsonb
}

"input type for inserting array relation for remote table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_arr_rel_insert_input {
  data: [journey_pattern_scheduled_stop_point_in_journey_pattern_insert_input!]!
  "upsert condition"
  on_conflict: journey_pattern_scheduled_stop_point_in_journey_pattern_on_conflict
}

"order by avg() on columns of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_avg_order_by {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: order_by
}

"Boolean expression to filter rows from the table \"journey_pattern.scheduled_stop_point_in_journey_pattern\". All fields are combined with a logical 'AND'."
input journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp {
  _and: [journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp!]
  _not: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  _or: [journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp!]
  is_loading_time_allowed: Boolean_comparison_exp
  is_regulated_timing_point: Boolean_comparison_exp
  is_used_as_timing_point: Boolean_comparison_exp
  is_via_point: Boolean_comparison_exp
  journey_pattern: journey_pattern_journey_pattern_bool_exp
  journey_pattern_id: uuid_comparison_exp
  scheduled_stop_point_label: String_comparison_exp
  scheduled_stop_point_sequence: Int_comparison_exp
  scheduled_stop_points: service_pattern_scheduled_stop_point_bool_exp
  scheduled_stop_points_aggregate: service_pattern_scheduled_stop_point_aggregate_bool_exp
  via_point_name_i18n: jsonb_comparison_exp
  via_point_short_name_i18n: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input journey_pattern_scheduled_stop_point_in_journey_pattern_delete_at_path_input {
  via_point_name_i18n: [String!]
  via_point_short_name_i18n: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input journey_pattern_scheduled_stop_point_in_journey_pattern_delete_elem_input {
  via_point_name_i18n: Int
  via_point_short_name_i18n: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input journey_pattern_scheduled_stop_point_in_journey_pattern_delete_key_input {
  via_point_name_i18n: String
  via_point_short_name_i18n: String
}

"input type for incrementing numeric columns in table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_inc_input {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Int
}

"input type for inserting data into table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_insert_input {
  "Is adding loading time to this scheduled stop point in the journey pattern allowed?"
  is_loading_time_allowed: Boolean
  "Is this stop point passing time regulated so that it cannot be passed before scheduled time?"
  is_regulated_timing_point: Boolean
  "Is this scheduled stop point used as a timing point in the journey pattern?"
  is_used_as_timing_point: Boolean
  "Is this scheduled stop point a via point?"
  is_via_point: Boolean
  journey_pattern: journey_pattern_journey_pattern_obj_rel_insert_input
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  scheduled_stop_point_label: String
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Int
  scheduled_stop_points: service_pattern_scheduled_stop_point_arr_rel_insert_input
  via_point_name_i18n: jsonb
  via_point_short_name_i18n: jsonb
}

"order by max() on columns of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_max_order_by {
  "The ID of the journey pattern."
  journey_pattern_id: order_by
  scheduled_stop_point_label: order_by
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: order_by
}

"order by min() on columns of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_min_order_by {
  "The ID of the journey pattern."
  journey_pattern_id: order_by
  scheduled_stop_point_label: order_by
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: order_by
}

"on_conflict condition type for table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_on_conflict {
  constraint: journey_pattern_scheduled_stop_point_in_journey_pattern_constraint!
  update_columns: [journey_pattern_scheduled_stop_point_in_journey_pattern_update_column!]! = []
  where: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
}

"Ordering options when selecting data from \"journey_pattern.scheduled_stop_point_in_journey_pattern\"."
input journey_pattern_scheduled_stop_point_in_journey_pattern_order_by {
  is_loading_time_allowed: order_by
  is_regulated_timing_point: order_by
  is_used_as_timing_point: order_by
  is_via_point: order_by
  journey_pattern: journey_pattern_journey_pattern_order_by
  journey_pattern_id: order_by
  scheduled_stop_point_label: order_by
  scheduled_stop_point_sequence: order_by
  scheduled_stop_points_aggregate: service_pattern_scheduled_stop_point_aggregate_order_by
  via_point_name_i18n: order_by
  via_point_short_name_i18n: order_by
}

"primary key columns input for table: journey_pattern.scheduled_stop_point_in_journey_pattern"
input journey_pattern_scheduled_stop_point_in_journey_pattern_pk_columns_input {
  "The ID of the journey pattern."
  journey_pattern_id: uuid!
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input journey_pattern_scheduled_stop_point_in_journey_pattern_prepend_input {
  via_point_name_i18n: jsonb
  via_point_short_name_i18n: jsonb
}

"input type for updating data in table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_set_input {
  "Is adding loading time to this scheduled stop point in the journey pattern allowed?"
  is_loading_time_allowed: Boolean
  "Is this stop point passing time regulated so that it cannot be passed before scheduled time?"
  is_regulated_timing_point: Boolean
  "Is this scheduled stop point used as a timing point in the journey pattern?"
  is_used_as_timing_point: Boolean
  "Is this scheduled stop point a via point?"
  is_via_point: Boolean
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  scheduled_stop_point_label: String
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Int
  via_point_name_i18n: jsonb
  via_point_short_name_i18n: jsonb
}

"order by stddev() on columns of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_order_by {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: order_by
}

"order by stddev_pop() on columns of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_pop_order_by {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: order_by
}

"order by stddev_samp() on columns of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_samp_order_by {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: order_by
}

"Streaming cursor of the table \"journey_pattern_scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: journey_pattern_scheduled_stop_point_in_journey_pattern_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input journey_pattern_scheduled_stop_point_in_journey_pattern_stream_cursor_value_input {
  "Is adding loading time to this scheduled stop point in the journey pattern allowed?"
  is_loading_time_allowed: Boolean
  "Is this stop point passing time regulated so that it cannot be passed before scheduled time?"
  is_regulated_timing_point: Boolean
  "Is this scheduled stop point used as a timing point in the journey pattern?"
  is_used_as_timing_point: Boolean
  "Is this scheduled stop point a via point?"
  is_via_point: Boolean
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  scheduled_stop_point_label: String
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: Int
  via_point_name_i18n: jsonb
  via_point_short_name_i18n: jsonb
}

"order by sum() on columns of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_sum_order_by {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: order_by
}

input journey_pattern_scheduled_stop_point_in_journey_pattern_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: journey_pattern_scheduled_stop_point_in_journey_pattern_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: journey_pattern_scheduled_stop_point_in_journey_pattern_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: journey_pattern_scheduled_stop_point_in_journey_pattern_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: journey_pattern_scheduled_stop_point_in_journey_pattern_delete_key_input
  "increments the numeric columns with given value of the filtered values"
  _inc: journey_pattern_scheduled_stop_point_in_journey_pattern_inc_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: journey_pattern_scheduled_stop_point_in_journey_pattern_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: journey_pattern_scheduled_stop_point_in_journey_pattern_set_input
  "filter the rows which have to be updated"
  where: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp!
}

"order by var_pop() on columns of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_var_pop_order_by {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: order_by
}

"order by var_samp() on columns of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_var_samp_order_by {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: order_by
}

"order by variance() on columns of table \"journey_pattern.scheduled_stop_point_in_journey_pattern\""
input journey_pattern_scheduled_stop_point_in_journey_pattern_variance_order_by {
  "The order of the scheduled stop point within the journey pattern."
  scheduled_stop_point_sequence: order_by
}

input jsonb_cast_exp {
  String: String_comparison_exp
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp
  "is the column contained in the given json value"
  _contained_in: jsonb
  "does the column contain the given json value at the top level"
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  "does the string exist as a top-level key in the column"
  _has_key: String
  "do all of these strings exist as top-level keys in the column"
  _has_keys_all: [String!]
  "do any of these strings exist as top-level keys in the column"
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

input passing_times_timetabled_passing_time_aggregate_bool_exp {
  count: passing_times_timetabled_passing_time_aggregate_bool_exp_count
}

input passing_times_timetabled_passing_time_aggregate_bool_exp_count {
  arguments: [timetables_passing_times_timetabled_passing_time_select_column!]
  distinct: Boolean
  filter: timetables_passing_times_timetabled_passing_time_bool_exp
  predicate: Int_comparison_exp!
}

"Boolean expression to filter rows from the table \"reusable_components.vehicle_mode\". All fields are combined with a logical 'AND'."
input reusable_components_vehicle_mode_bool_exp {
  _and: [reusable_components_vehicle_mode_bool_exp!]
  _not: reusable_components_vehicle_mode_bool_exp
  _or: [reusable_components_vehicle_mode_bool_exp!]
  vehicle_mode: String_comparison_exp
  vehicle_submodes: reusable_components_vehicle_submode_bool_exp
  vehicle_submodes_aggregate: reusable_components_vehicle_submode_aggregate_bool_exp
}

"Boolean expression to compare columns of type \"reusable_components_vehicle_mode_enum\". All fields are combined with logical 'AND'."
input reusable_components_vehicle_mode_enum_comparison_exp {
  _eq: reusable_components_vehicle_mode_enum
  _in: [reusable_components_vehicle_mode_enum!]
  _is_null: Boolean
  _neq: reusable_components_vehicle_mode_enum
  _nin: [reusable_components_vehicle_mode_enum!]
}

"input type for inserting data into table \"reusable_components.vehicle_mode\""
input reusable_components_vehicle_mode_insert_input {
  "The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
  vehicle_mode: String
  vehicle_submodes: reusable_components_vehicle_submode_arr_rel_insert_input
}

"input type for inserting object relation for remote table \"reusable_components.vehicle_mode\""
input reusable_components_vehicle_mode_obj_rel_insert_input {
  data: reusable_components_vehicle_mode_insert_input!
  "upsert condition"
  on_conflict: reusable_components_vehicle_mode_on_conflict
}

"on_conflict condition type for table \"reusable_components.vehicle_mode\""
input reusable_components_vehicle_mode_on_conflict {
  constraint: reusable_components_vehicle_mode_constraint!
  update_columns: [reusable_components_vehicle_mode_update_column!]! = []
  where: reusable_components_vehicle_mode_bool_exp
}

"Ordering options when selecting data from \"reusable_components.vehicle_mode\"."
input reusable_components_vehicle_mode_order_by {
  vehicle_mode: order_by
  vehicle_submodes_aggregate: reusable_components_vehicle_submode_aggregate_order_by
}

"primary key columns input for table: reusable_components.vehicle_mode"
input reusable_components_vehicle_mode_pk_columns_input {
  "The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
  vehicle_mode: String!
}

"input type for updating data in table \"reusable_components.vehicle_mode\""
input reusable_components_vehicle_mode_set_input {
  "The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
  vehicle_mode: String
}

"Streaming cursor of the table \"reusable_components_vehicle_mode\""
input reusable_components_vehicle_mode_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: reusable_components_vehicle_mode_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input reusable_components_vehicle_mode_stream_cursor_value_input {
  "The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
  vehicle_mode: String
}

input reusable_components_vehicle_mode_updates {
  "sets the columns of the filtered rows to the given values"
  _set: reusable_components_vehicle_mode_set_input
  "filter the rows which have to be updated"
  where: reusable_components_vehicle_mode_bool_exp!
}

input reusable_components_vehicle_submode_aggregate_bool_exp {
  count: reusable_components_vehicle_submode_aggregate_bool_exp_count
}

input reusable_components_vehicle_submode_aggregate_bool_exp_count {
  arguments: [reusable_components_vehicle_submode_select_column!]
  distinct: Boolean
  filter: reusable_components_vehicle_submode_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"reusable_components.vehicle_submode\""
input reusable_components_vehicle_submode_aggregate_order_by {
  count: order_by
  max: reusable_components_vehicle_submode_max_order_by
  min: reusable_components_vehicle_submode_min_order_by
}

"input type for inserting array relation for remote table \"reusable_components.vehicle_submode\""
input reusable_components_vehicle_submode_arr_rel_insert_input {
  data: [reusable_components_vehicle_submode_insert_input!]!
  "upsert condition"
  on_conflict: reusable_components_vehicle_submode_on_conflict
}

"Boolean expression to filter rows from the table \"reusable_components.vehicle_submode\". All fields are combined with a logical 'AND'."
input reusable_components_vehicle_submode_bool_exp {
  _and: [reusable_components_vehicle_submode_bool_exp!]
  _not: reusable_components_vehicle_submode_bool_exp
  _or: [reusable_components_vehicle_submode_bool_exp!]
  belonging_to_vehicle_mode: reusable_components_vehicle_mode_enum_comparison_exp
  vehicle_mode: reusable_components_vehicle_mode_bool_exp
  vehicle_submode: String_comparison_exp
  vehicle_submode_on_infrastructure_links: infrastructure_network_vehicle_submode_on_infrastructure_link_bool_exp
  vehicle_submode_on_infrastructure_links_aggregate: infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate_bool_exp
}

"Boolean expression to compare columns of type \"reusable_components_vehicle_submode_enum\". All fields are combined with logical 'AND'."
input reusable_components_vehicle_submode_enum_comparison_exp {
  _eq: reusable_components_vehicle_submode_enum
  _in: [reusable_components_vehicle_submode_enum!]
  _is_null: Boolean
  _neq: reusable_components_vehicle_submode_enum
  _nin: [reusable_components_vehicle_submode_enum!]
}

"input type for inserting data into table \"reusable_components.vehicle_submode\""
input reusable_components_vehicle_submode_insert_input {
  "The vehicle mode the vehicle submode belongs to: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
  belonging_to_vehicle_mode: reusable_components_vehicle_mode_enum
  vehicle_mode: reusable_components_vehicle_mode_obj_rel_insert_input
  "The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse"
  vehicle_submode: String
  vehicle_submode_on_infrastructure_links: infrastructure_network_vehicle_submode_on_infrastructure_link_arr_rel_insert_input
}

"order by max() on columns of table \"reusable_components.vehicle_submode\""
input reusable_components_vehicle_submode_max_order_by {
  "The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse"
  vehicle_submode: order_by
}

"order by min() on columns of table \"reusable_components.vehicle_submode\""
input reusable_components_vehicle_submode_min_order_by {
  "The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse"
  vehicle_submode: order_by
}

"input type for inserting object relation for remote table \"reusable_components.vehicle_submode\""
input reusable_components_vehicle_submode_obj_rel_insert_input {
  data: reusable_components_vehicle_submode_insert_input!
  "upsert condition"
  on_conflict: reusable_components_vehicle_submode_on_conflict
}

"on_conflict condition type for table \"reusable_components.vehicle_submode\""
input reusable_components_vehicle_submode_on_conflict {
  constraint: reusable_components_vehicle_submode_constraint!
  update_columns: [reusable_components_vehicle_submode_update_column!]! = []
  where: reusable_components_vehicle_submode_bool_exp
}

"Ordering options when selecting data from \"reusable_components.vehicle_submode\"."
input reusable_components_vehicle_submode_order_by {
  belonging_to_vehicle_mode: order_by
  vehicle_mode: reusable_components_vehicle_mode_order_by
  vehicle_submode: order_by
  vehicle_submode_on_infrastructure_links_aggregate: infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate_order_by
}

"primary key columns input for table: reusable_components.vehicle_submode"
input reusable_components_vehicle_submode_pk_columns_input {
  "The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse"
  vehicle_submode: String!
}

"input type for updating data in table \"reusable_components.vehicle_submode\""
input reusable_components_vehicle_submode_set_input {
  "The vehicle mode the vehicle submode belongs to: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
  belonging_to_vehicle_mode: reusable_components_vehicle_mode_enum
  "The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse"
  vehicle_submode: String
}

"Streaming cursor of the table \"reusable_components_vehicle_submode\""
input reusable_components_vehicle_submode_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: reusable_components_vehicle_submode_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input reusable_components_vehicle_submode_stream_cursor_value_input {
  "The vehicle mode the vehicle submode belongs to: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283"
  belonging_to_vehicle_mode: reusable_components_vehicle_mode_enum
  "The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse"
  vehicle_submode: String
}

input reusable_components_vehicle_submode_updates {
  "sets the columns of the filtered rows to the given values"
  _set: reusable_components_vehicle_submode_set_input
  "filter the rows which have to be updated"
  where: reusable_components_vehicle_submode_bool_exp!
}

input route_direction_aggregate_bool_exp {
  count: route_direction_aggregate_bool_exp_count
}

input route_direction_aggregate_bool_exp_count {
  arguments: [route_direction_select_column!]
  distinct: Boolean
  filter: route_direction_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"route.direction\""
input route_direction_aggregate_order_by {
  count: order_by
  max: route_direction_max_order_by
  min: route_direction_min_order_by
}

"input type for inserting array relation for remote table \"route.direction\""
input route_direction_arr_rel_insert_input {
  data: [route_direction_insert_input!]!
  "upsert condition"
  on_conflict: route_direction_on_conflict
}

"Boolean expression to filter rows from the table \"route.direction\". All fields are combined with a logical 'AND'."
input route_direction_bool_exp {
  _and: [route_direction_bool_exp!]
  _not: route_direction_bool_exp
  _or: [route_direction_bool_exp!]
  direction: String_comparison_exp
  directionByTheOppositeOfDirection: route_direction_bool_exp
  directions: route_direction_bool_exp
  directions_aggregate: route_direction_aggregate_bool_exp
  the_opposite_of_direction: route_direction_enum_comparison_exp
}

"Boolean expression to compare columns of type \"route_direction_enum\". All fields are combined with logical 'AND'."
input route_direction_enum_comparison_exp {
  _eq: route_direction_enum
  _in: [route_direction_enum!]
  _is_null: Boolean
  _neq: route_direction_enum
  _nin: [route_direction_enum!]
}

"input type for inserting data into table \"route.direction\""
input route_direction_insert_input {
  "The name of the route direction."
  direction: String
  directionByTheOppositeOfDirection: route_direction_obj_rel_insert_input
  directions: route_direction_arr_rel_insert_input
  "The opposite direction."
  the_opposite_of_direction: route_direction_enum
}

"order by max() on columns of table \"route.direction\""
input route_direction_max_order_by {
  "The name of the route direction."
  direction: order_by
}

"order by min() on columns of table \"route.direction\""
input route_direction_min_order_by {
  "The name of the route direction."
  direction: order_by
}

"input type for inserting object relation for remote table \"route.direction\""
input route_direction_obj_rel_insert_input {
  data: route_direction_insert_input!
  "upsert condition"
  on_conflict: route_direction_on_conflict
}

"on_conflict condition type for table \"route.direction\""
input route_direction_on_conflict {
  constraint: route_direction_constraint!
  update_columns: [route_direction_update_column!]! = []
  where: route_direction_bool_exp
}

"Ordering options when selecting data from \"route.direction\"."
input route_direction_order_by {
  direction: order_by
  directionByTheOppositeOfDirection: route_direction_order_by
  directions_aggregate: route_direction_aggregate_order_by
  the_opposite_of_direction: order_by
}

"primary key columns input for table: route.direction"
input route_direction_pk_columns_input {
  "The name of the route direction."
  direction: String!
}

"input type for updating data in table \"route.direction\""
input route_direction_set_input {
  "The name of the route direction."
  direction: String
  "The opposite direction."
  the_opposite_of_direction: route_direction_enum
}

"Streaming cursor of the table \"route_direction\""
input route_direction_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: route_direction_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input route_direction_stream_cursor_value_input {
  "The name of the route direction."
  direction: String
  "The opposite direction."
  the_opposite_of_direction: route_direction_enum
}

input route_direction_updates {
  "sets the columns of the filtered rows to the given values"
  _set: route_direction_set_input
  "filter the rows which have to be updated"
  where: route_direction_bool_exp!
}

input route_infrastructure_link_along_route_aggregate_bool_exp {
  bool_and: route_infrastructure_link_along_route_aggregate_bool_exp_bool_and
  bool_or: route_infrastructure_link_along_route_aggregate_bool_exp_bool_or
  count: route_infrastructure_link_along_route_aggregate_bool_exp_count
}

input route_infrastructure_link_along_route_aggregate_bool_exp_bool_and {
  arguments: route_infrastructure_link_along_route_select_column_route_infrastructure_link_along_route_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: route_infrastructure_link_along_route_bool_exp
  predicate: Boolean_comparison_exp!
}

input route_infrastructure_link_along_route_aggregate_bool_exp_bool_or {
  arguments: route_infrastructure_link_along_route_select_column_route_infrastructure_link_along_route_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: route_infrastructure_link_along_route_bool_exp
  predicate: Boolean_comparison_exp!
}

input route_infrastructure_link_along_route_aggregate_bool_exp_count {
  arguments: [route_infrastructure_link_along_route_select_column!]
  distinct: Boolean
  filter: route_infrastructure_link_along_route_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_aggregate_order_by {
  avg: route_infrastructure_link_along_route_avg_order_by
  count: order_by
  max: route_infrastructure_link_along_route_max_order_by
  min: route_infrastructure_link_along_route_min_order_by
  stddev: route_infrastructure_link_along_route_stddev_order_by
  stddev_pop: route_infrastructure_link_along_route_stddev_pop_order_by
  stddev_samp: route_infrastructure_link_along_route_stddev_samp_order_by
  sum: route_infrastructure_link_along_route_sum_order_by
  var_pop: route_infrastructure_link_along_route_var_pop_order_by
  var_samp: route_infrastructure_link_along_route_var_samp_order_by
  variance: route_infrastructure_link_along_route_variance_order_by
}

"input type for inserting array relation for remote table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_arr_rel_insert_input {
  data: [route_infrastructure_link_along_route_insert_input!]!
  "upsert condition"
  on_conflict: route_infrastructure_link_along_route_on_conflict
}

"order by avg() on columns of table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_avg_order_by {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: order_by
}

"Boolean expression to filter rows from the table \"route.infrastructure_link_along_route\". All fields are combined with a logical 'AND'."
input route_infrastructure_link_along_route_bool_exp {
  _and: [route_infrastructure_link_along_route_bool_exp!]
  _not: route_infrastructure_link_along_route_bool_exp
  _or: [route_infrastructure_link_along_route_bool_exp!]
  infrastructure_link: infrastructure_network_infrastructure_link_bool_exp
  infrastructure_link_id: uuid_comparison_exp
  infrastructure_link_sequence: Int_comparison_exp
  is_traversal_forwards: Boolean_comparison_exp
  route_id: uuid_comparison_exp
}

"input type for incrementing numeric columns in table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_inc_input {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Int
}

"input type for inserting data into table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_insert_input {
  infrastructure_link: infrastructure_network_infrastructure_link_obj_rel_insert_input
  "The ID of the infrastructure link."
  infrastructure_link_id: uuid
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Int
  "Is the infrastructure link traversed in the direction of its linestring?"
  is_traversal_forwards: Boolean
  "The ID of the route."
  route_id: uuid
}

"order by max() on columns of table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_max_order_by {
  "The ID of the infrastructure link."
  infrastructure_link_id: order_by
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: order_by
  "The ID of the route."
  route_id: order_by
}

"order by min() on columns of table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_min_order_by {
  "The ID of the infrastructure link."
  infrastructure_link_id: order_by
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: order_by
  "The ID of the route."
  route_id: order_by
}

"on_conflict condition type for table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_on_conflict {
  constraint: route_infrastructure_link_along_route_constraint!
  update_columns: [route_infrastructure_link_along_route_update_column!]! = []
  where: route_infrastructure_link_along_route_bool_exp
}

"Ordering options when selecting data from \"route.infrastructure_link_along_route\"."
input route_infrastructure_link_along_route_order_by {
  infrastructure_link: infrastructure_network_infrastructure_link_order_by
  infrastructure_link_id: order_by
  infrastructure_link_sequence: order_by
  is_traversal_forwards: order_by
  route_id: order_by
}

"primary key columns input for table: route.infrastructure_link_along_route"
input route_infrastructure_link_along_route_pk_columns_input {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Int!
  "The ID of the route."
  route_id: uuid!
}

"input type for updating data in table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_set_input {
  "The ID of the infrastructure link."
  infrastructure_link_id: uuid
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Int
  "Is the infrastructure link traversed in the direction of its linestring?"
  is_traversal_forwards: Boolean
  "The ID of the route."
  route_id: uuid
}

"order by stddev() on columns of table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_stddev_order_by {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: order_by
}

"order by stddev_pop() on columns of table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_stddev_pop_order_by {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: order_by
}

"order by stddev_samp() on columns of table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_stddev_samp_order_by {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: order_by
}

"Streaming cursor of the table \"route_infrastructure_link_along_route\""
input route_infrastructure_link_along_route_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: route_infrastructure_link_along_route_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input route_infrastructure_link_along_route_stream_cursor_value_input {
  "The ID of the infrastructure link."
  infrastructure_link_id: uuid
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: Int
  "Is the infrastructure link traversed in the direction of its linestring?"
  is_traversal_forwards: Boolean
  "The ID of the route."
  route_id: uuid
}

"order by sum() on columns of table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_sum_order_by {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: order_by
}

input route_infrastructure_link_along_route_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: route_infrastructure_link_along_route_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: route_infrastructure_link_along_route_set_input
  "filter the rows which have to be updated"
  where: route_infrastructure_link_along_route_bool_exp!
}

"order by var_pop() on columns of table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_var_pop_order_by {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: order_by
}

"order by var_samp() on columns of table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_var_samp_order_by {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: order_by
}

"order by variance() on columns of table \"route.infrastructure_link_along_route\""
input route_infrastructure_link_along_route_variance_order_by {
  "The order of the infrastructure link within the journey pattern."
  infrastructure_link_sequence: order_by
}

input route_line_aggregate_bool_exp {
  count: route_line_aggregate_bool_exp_count
}

input route_line_aggregate_bool_exp_count {
  arguments: [route_line_select_column!]
  distinct: Boolean
  filter: route_line_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"route.line\""
input route_line_aggregate_order_by {
  avg: route_line_avg_order_by
  count: order_by
  max: route_line_max_order_by
  min: route_line_min_order_by
  stddev: route_line_stddev_order_by
  stddev_pop: route_line_stddev_pop_order_by
  stddev_samp: route_line_stddev_samp_order_by
  sum: route_line_sum_order_by
  var_pop: route_line_var_pop_order_by
  var_samp: route_line_var_samp_order_by
  variance: route_line_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input route_line_append_input {
  "The name of the line. Placeholder for multilingual strings."
  name_i18n: jsonb
  "The shorted name of the line. Placeholder for multilingual strings."
  short_name_i18n: jsonb
}

"input type for inserting array relation for remote table \"route.line\""
input route_line_arr_rel_insert_input {
  data: [route_line_insert_input!]!
  "upsert condition"
  on_conflict: route_line_on_conflict
}

"order by avg() on columns of table \"route.line\""
input route_line_avg_order_by {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: order_by
}

"Boolean expression to filter rows from the table \"route.line\". All fields are combined with a logical 'AND'."
input route_line_bool_exp {
  _and: [route_line_bool_exp!]
  _not: route_line_bool_exp
  _or: [route_line_bool_exp!]
  label: String_comparison_exp
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode: hsl_route_legacy_hsl_municipality_code_bool_exp
  legacy_hsl_municipality_code: String_comparison_exp
  line_id: uuid_comparison_exp
  line_routes: route_route_bool_exp
  line_routes_aggregate: route_route_aggregate_bool_exp
  name_i18n: jsonb_comparison_exp
  primary_vehicle_mode: reusable_components_vehicle_mode_enum_comparison_exp
  priority: Int_comparison_exp
  short_name_i18n: jsonb_comparison_exp
  transportTargetByTransportTarget: hsl_route_transport_target_bool_exp
  transport_target: hsl_route_transport_target_enum_comparison_exp
  typeOfLineByTypeOfLine: route_type_of_line_bool_exp
  type_of_line: route_type_of_line_enum_comparison_exp
  validity_end: date_comparison_exp
  validity_start: date_comparison_exp
  vehicle_mode: reusable_components_vehicle_mode_bool_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input route_line_delete_at_path_input {
  "The name of the line. Placeholder for multilingual strings."
  name_i18n: [String!]
  "The shorted name of the line. Placeholder for multilingual strings."
  short_name_i18n: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input route_line_delete_elem_input {
  "The name of the line. Placeholder for multilingual strings."
  name_i18n: Int
  "The shorted name of the line. Placeholder for multilingual strings."
  short_name_i18n: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input route_line_delete_key_input {
  "The name of the line. Placeholder for multilingual strings."
  name_i18n: String
  "The shorted name of the line. Placeholder for multilingual strings."
  short_name_i18n: String
}

"input type for incrementing numeric columns in table \"route.line\""
input route_line_inc_input {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Int
}

"input type for inserting data into table \"route.line\""
input route_line_insert_input {
  "The label of the line definition. The label is unique for a certain priority and validity period."
  label: String
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode: hsl_route_legacy_hsl_municipality_code_obj_rel_insert_input
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: String
  "The ID of the line."
  line_id: uuid
  line_routes: route_route_arr_rel_insert_input
  "The name of the line. Placeholder for multilingual strings."
  name_i18n: jsonb
  "The mode of the vehicles used as primary on the line."
  primary_vehicle_mode: reusable_components_vehicle_mode_enum
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "The shorted name of the line. Placeholder for multilingual strings."
  short_name_i18n: jsonb
  transportTargetByTransportTarget: hsl_route_transport_target_obj_rel_insert_input
  transport_target: hsl_route_transport_target_enum
  typeOfLineByTypeOfLine: route_type_of_line_obj_rel_insert_input
  "The type of the line."
  type_of_line: route_type_of_line_enum
  "The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid."
  validity_end: date
  "The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid."
  validity_start: date
  vehicle_mode: reusable_components_vehicle_mode_obj_rel_insert_input
}

"order by max() on columns of table \"route.line\""
input route_line_max_order_by {
  "The label of the line definition. The label is unique for a certain priority and validity period."
  label: order_by
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: order_by
  "The ID of the line."
  line_id: order_by
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: order_by
  "The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid."
  validity_end: order_by
  "The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid."
  validity_start: order_by
}

"order by min() on columns of table \"route.line\""
input route_line_min_order_by {
  "The label of the line definition. The label is unique for a certain priority and validity period."
  label: order_by
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: order_by
  "The ID of the line."
  line_id: order_by
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: order_by
  "The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid."
  validity_end: order_by
  "The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid."
  validity_start: order_by
}

"input type for inserting object relation for remote table \"route.line\""
input route_line_obj_rel_insert_input {
  data: route_line_insert_input!
  "upsert condition"
  on_conflict: route_line_on_conflict
}

"on_conflict condition type for table \"route.line\""
input route_line_on_conflict {
  constraint: route_line_constraint!
  update_columns: [route_line_update_column!]! = []
  where: route_line_bool_exp
}

"Ordering options when selecting data from \"route.line\"."
input route_line_order_by {
  label: order_by
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode: hsl_route_legacy_hsl_municipality_code_order_by
  legacy_hsl_municipality_code: order_by
  line_id: order_by
  line_routes_aggregate: route_route_aggregate_order_by
  name_i18n: order_by
  primary_vehicle_mode: order_by
  priority: order_by
  short_name_i18n: order_by
  transportTargetByTransportTarget: hsl_route_transport_target_order_by
  transport_target: order_by
  typeOfLineByTypeOfLine: route_type_of_line_order_by
  type_of_line: order_by
  validity_end: order_by
  validity_start: order_by
  vehicle_mode: reusable_components_vehicle_mode_order_by
}

"primary key columns input for table: route.line"
input route_line_pk_columns_input {
  "The ID of the line."
  line_id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input route_line_prepend_input {
  "The name of the line. Placeholder for multilingual strings."
  name_i18n: jsonb
  "The shorted name of the line. Placeholder for multilingual strings."
  short_name_i18n: jsonb
}

"input type for updating data in table \"route.line\""
input route_line_set_input {
  "The label of the line definition. The label is unique for a certain priority and validity period."
  label: String
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: String
  "The ID of the line."
  line_id: uuid
  "The name of the line. Placeholder for multilingual strings."
  name_i18n: jsonb
  "The mode of the vehicles used as primary on the line."
  primary_vehicle_mode: reusable_components_vehicle_mode_enum
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "The shorted name of the line. Placeholder for multilingual strings."
  short_name_i18n: jsonb
  transport_target: hsl_route_transport_target_enum
  "The type of the line."
  type_of_line: route_type_of_line_enum
  "The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid."
  validity_end: date
  "The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid."
  validity_start: date
}

"order by stddev() on columns of table \"route.line\""
input route_line_stddev_order_by {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: order_by
}

"order by stddev_pop() on columns of table \"route.line\""
input route_line_stddev_pop_order_by {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: order_by
}

"order by stddev_samp() on columns of table \"route.line\""
input route_line_stddev_samp_order_by {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: order_by
}

"Streaming cursor of the table \"route_line\""
input route_line_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: route_line_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input route_line_stream_cursor_value_input {
  "The label of the line definition. The label is unique for a certain priority and validity period."
  label: String
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: String
  "The ID of the line."
  line_id: uuid
  "The name of the line. Placeholder for multilingual strings."
  name_i18n: jsonb
  "The mode of the vehicles used as primary on the line."
  primary_vehicle_mode: reusable_components_vehicle_mode_enum
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "The shorted name of the line. Placeholder for multilingual strings."
  short_name_i18n: jsonb
  transport_target: hsl_route_transport_target_enum
  "The type of the line."
  type_of_line: route_type_of_line_enum
  "The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid."
  validity_end: date
  "The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid."
  validity_start: date
}

"order by sum() on columns of table \"route.line\""
input route_line_sum_order_by {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: order_by
}

input route_line_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: route_line_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: route_line_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: route_line_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: route_line_delete_key_input
  "increments the numeric columns with given value of the filtered values"
  _inc: route_line_inc_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: route_line_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: route_line_set_input
  "filter the rows which have to be updated"
  where: route_line_bool_exp!
}

"order by var_pop() on columns of table \"route.line\""
input route_line_var_pop_order_by {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: order_by
}

"order by var_samp() on columns of table \"route.line\""
input route_line_var_samp_order_by {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: order_by
}

"order by variance() on columns of table \"route.line\""
input route_line_variance_order_by {
  "The priority of the line definition. The definition may be overridden by higher priority definitions."
  priority: order_by
}

input route_route_aggregate_bool_exp {
  count: route_route_aggregate_bool_exp_count
}

input route_route_aggregate_bool_exp_count {
  arguments: [route_route_select_column!]
  distinct: Boolean
  filter: route_route_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"route.route\""
input route_route_aggregate_order_by {
  avg: route_route_avg_order_by
  count: order_by
  max: route_route_max_order_by
  min: route_route_min_order_by
  stddev: route_route_stddev_order_by
  stddev_pop: route_route_stddev_pop_order_by
  stddev_samp: route_route_stddev_samp_order_by
  sum: route_route_sum_order_by
  var_pop: route_route_var_pop_order_by
  var_samp: route_route_var_samp_order_by
  variance: route_route_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input route_route_append_input {
  "The description of the route in the form of starting location - destination. Placeholder for multilingual strings."
  description_i18n: jsonb
  destination_name_i18n: jsonb
  destination_short_name_i18n: jsonb
  name_i18n: jsonb
  origin_name_i18n: jsonb
  origin_short_name_i18n: jsonb
}

"input type for inserting array relation for remote table \"route.route\""
input route_route_arr_rel_insert_input {
  data: [route_route_insert_input!]!
  "upsert condition"
  on_conflict: route_route_on_conflict
}

"order by avg() on columns of table \"route.route\""
input route_route_avg_order_by {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: order_by
  "The variant for route definition."
  variant: order_by
}

"Boolean expression to filter rows from the table \"route.route\". All fields are combined with a logical 'AND'."
input route_route_bool_exp {
  _and: [route_route_bool_exp!]
  _not: route_route_bool_exp
  _or: [route_route_bool_exp!]
  description_i18n: jsonb_comparison_exp
  destination_name_i18n: jsonb_comparison_exp
  destination_short_name_i18n: jsonb_comparison_exp
  direction: route_direction_enum_comparison_exp
  infrastructure_links_along_route: route_infrastructure_link_along_route_bool_exp
  infrastructure_links_along_route_aggregate: route_infrastructure_link_along_route_aggregate_bool_exp
  label: String_comparison_exp
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode: hsl_route_legacy_hsl_municipality_code_bool_exp
  legacy_hsl_municipality_code: String_comparison_exp
  name_i18n: jsonb_comparison_exp
  on_line_id: uuid_comparison_exp
  origin_name_i18n: jsonb_comparison_exp
  origin_short_name_i18n: jsonb_comparison_exp
  priority: Int_comparison_exp
  route_id: uuid_comparison_exp
  route_journey_patterns: journey_pattern_journey_pattern_bool_exp
  route_journey_patterns_aggregate: journey_pattern_journey_pattern_aggregate_bool_exp
  route_line: route_line_bool_exp
  route_shape: geography_comparison_exp
  unique_label: String_comparison_exp
  validity_end: date_comparison_exp
  validity_start: date_comparison_exp
  variant: smallint_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input route_route_delete_at_path_input {
  "The description of the route in the form of starting location - destination. Placeholder for multilingual strings."
  description_i18n: [String!]
  destination_name_i18n: [String!]
  destination_short_name_i18n: [String!]
  name_i18n: [String!]
  origin_name_i18n: [String!]
  origin_short_name_i18n: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input route_route_delete_elem_input {
  "The description of the route in the form of starting location - destination. Placeholder for multilingual strings."
  description_i18n: Int
  destination_name_i18n: Int
  destination_short_name_i18n: Int
  name_i18n: Int
  origin_name_i18n: Int
  origin_short_name_i18n: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input route_route_delete_key_input {
  "The description of the route in the form of starting location - destination. Placeholder for multilingual strings."
  description_i18n: String
  destination_name_i18n: String
  destination_short_name_i18n: String
  name_i18n: String
  origin_name_i18n: String
  origin_short_name_i18n: String
}

"input type for incrementing numeric columns in table \"route.route\""
input route_route_inc_input {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "The variant for route definition."
  variant: smallint
}

"input type for inserting data into table \"route.route\""
input route_route_insert_input {
  "The description of the route in the form of starting location - destination. Placeholder for multilingual strings."
  description_i18n: jsonb
  destination_name_i18n: jsonb
  destination_short_name_i18n: jsonb
  "The direction of the route definition."
  direction: route_direction_enum
  infrastructure_links_along_route: route_infrastructure_link_along_route_arr_rel_insert_input
  "The label of the route definition."
  label: String
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode: hsl_route_legacy_hsl_municipality_code_obj_rel_insert_input
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: String
  name_i18n: jsonb
  "The line to which this route belongs."
  on_line_id: uuid
  origin_name_i18n: jsonb
  origin_short_name_i18n: jsonb
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "The ID of the route."
  route_id: uuid
  route_journey_patterns: journey_pattern_journey_pattern_arr_rel_insert_input
  route_line: route_line_obj_rel_insert_input
  "The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period."
  validity_end: date
  "The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period."
  validity_start: date
  "The variant for route definition."
  variant: smallint
}

"order by max() on columns of table \"route.route\""
input route_route_max_order_by {
  "The label of the route definition."
  label: order_by
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: order_by
  "The line to which this route belongs."
  on_line_id: order_by
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: order_by
  "The ID of the route."
  route_id: order_by
  "Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period"
  unique_label: order_by
  "The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period."
  validity_end: order_by
  "The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period."
  validity_start: order_by
  "The variant for route definition."
  variant: order_by
}

"order by min() on columns of table \"route.route\""
input route_route_min_order_by {
  "The label of the route definition."
  label: order_by
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: order_by
  "The line to which this route belongs."
  on_line_id: order_by
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: order_by
  "The ID of the route."
  route_id: order_by
  "Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period"
  unique_label: order_by
  "The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period."
  validity_end: order_by
  "The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period."
  validity_start: order_by
  "The variant for route definition."
  variant: order_by
}

"input type for inserting object relation for remote table \"route.route\""
input route_route_obj_rel_insert_input {
  data: route_route_insert_input!
  "upsert condition"
  on_conflict: route_route_on_conflict
}

"on_conflict condition type for table \"route.route\""
input route_route_on_conflict {
  constraint: route_route_constraint!
  update_columns: [route_route_update_column!]! = []
  where: route_route_bool_exp
}

"Ordering options when selecting data from \"route.route\"."
input route_route_order_by {
  description_i18n: order_by
  destination_name_i18n: order_by
  destination_short_name_i18n: order_by
  direction: order_by
  infrastructure_links_along_route_aggregate: route_infrastructure_link_along_route_aggregate_order_by
  label: order_by
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode: hsl_route_legacy_hsl_municipality_code_order_by
  legacy_hsl_municipality_code: order_by
  name_i18n: order_by
  on_line_id: order_by
  origin_name_i18n: order_by
  origin_short_name_i18n: order_by
  priority: order_by
  route_id: order_by
  route_journey_patterns_aggregate: journey_pattern_journey_pattern_aggregate_order_by
  route_line: route_line_order_by
  route_shape: order_by
  unique_label: order_by
  validity_end: order_by
  validity_start: order_by
  variant: order_by
}

"primary key columns input for table: route.route"
input route_route_pk_columns_input {
  "The ID of the route."
  route_id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input route_route_prepend_input {
  "The description of the route in the form of starting location - destination. Placeholder for multilingual strings."
  description_i18n: jsonb
  destination_name_i18n: jsonb
  destination_short_name_i18n: jsonb
  name_i18n: jsonb
  origin_name_i18n: jsonb
  origin_short_name_i18n: jsonb
}

"input type for updating data in table \"route.route\""
input route_route_set_input {
  "The description of the route in the form of starting location - destination. Placeholder for multilingual strings."
  description_i18n: jsonb
  destination_name_i18n: jsonb
  destination_short_name_i18n: jsonb
  "The direction of the route definition."
  direction: route_direction_enum
  "The label of the route definition."
  label: String
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: String
  name_i18n: jsonb
  "The line to which this route belongs."
  on_line_id: uuid
  origin_name_i18n: jsonb
  origin_short_name_i18n: jsonb
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "The ID of the route."
  route_id: uuid
  "The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period."
  validity_end: date
  "The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period."
  validity_start: date
  "The variant for route definition."
  variant: smallint
}

"order by stddev() on columns of table \"route.route\""
input route_route_stddev_order_by {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: order_by
  "The variant for route definition."
  variant: order_by
}

"order by stddev_pop() on columns of table \"route.route\""
input route_route_stddev_pop_order_by {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: order_by
  "The variant for route definition."
  variant: order_by
}

"order by stddev_samp() on columns of table \"route.route\""
input route_route_stddev_samp_order_by {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: order_by
  "The variant for route definition."
  variant: order_by
}

"Streaming cursor of the table \"route_route\""
input route_route_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: route_route_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input route_route_stream_cursor_value_input {
  "The description of the route in the form of starting location - destination. Placeholder for multilingual strings."
  description_i18n: jsonb
  destination_name_i18n: jsonb
  destination_short_name_i18n: jsonb
  "The direction of the route definition."
  direction: route_direction_enum
  "The label of the route definition."
  label: String
  "Defines the legacy municipality that is mainly used for data exports."
  legacy_hsl_municipality_code: String
  name_i18n: jsonb
  "The line to which this route belongs."
  on_line_id: uuid
  origin_name_i18n: jsonb
  origin_short_name_i18n: jsonb
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "The ID of the route."
  route_id: uuid
  "Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period"
  unique_label: String
  "The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period."
  validity_end: date
  "The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period."
  validity_start: date
  "The variant for route definition."
  variant: smallint
}

"order by sum() on columns of table \"route.route\""
input route_route_sum_order_by {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: order_by
  "The variant for route definition."
  variant: order_by
}

input route_route_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: route_route_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: route_route_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: route_route_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: route_route_delete_key_input
  "increments the numeric columns with given value of the filtered values"
  _inc: route_route_inc_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: route_route_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: route_route_set_input
  "filter the rows which have to be updated"
  where: route_route_bool_exp!
}

"order by var_pop() on columns of table \"route.route\""
input route_route_var_pop_order_by {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: order_by
  "The variant for route definition."
  variant: order_by
}

"order by var_samp() on columns of table \"route.route\""
input route_route_var_samp_order_by {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: order_by
  "The variant for route definition."
  variant: order_by
}

"order by variance() on columns of table \"route.route\""
input route_route_variance_order_by {
  "The priority of the route definition. The definition may be overridden by higher priority definitions."
  priority: order_by
  "The variant for route definition."
  variant: order_by
}

"Boolean expression to filter rows from the table \"route.type_of_line\". All fields are combined with a logical 'AND'."
input route_type_of_line_bool_exp {
  _and: [route_type_of_line_bool_exp!]
  _not: route_type_of_line_bool_exp
  _or: [route_type_of_line_bool_exp!]
  belonging_to_vehicle_mode: reusable_components_vehicle_mode_enum_comparison_exp
  lines: route_line_bool_exp
  lines_aggregate: route_line_aggregate_bool_exp
  type_of_line: String_comparison_exp
  vehicle_mode: reusable_components_vehicle_mode_bool_exp
}

"Boolean expression to compare columns of type \"route_type_of_line_enum\". All fields are combined with logical 'AND'."
input route_type_of_line_enum_comparison_exp {
  _eq: route_type_of_line_enum
  _in: [route_type_of_line_enum!]
  _is_null: Boolean
  _neq: route_type_of_line_enum
  _nin: [route_type_of_line_enum!]
}

"input type for inserting data into table \"route.type_of_line\""
input route_type_of_line_insert_input {
  belonging_to_vehicle_mode: reusable_components_vehicle_mode_enum
  lines: route_line_arr_rel_insert_input
  "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
  vehicle_mode: reusable_components_vehicle_mode_obj_rel_insert_input
}

"input type for inserting object relation for remote table \"route.type_of_line\""
input route_type_of_line_obj_rel_insert_input {
  data: route_type_of_line_insert_input!
  "upsert condition"
  on_conflict: route_type_of_line_on_conflict
}

"on_conflict condition type for table \"route.type_of_line\""
input route_type_of_line_on_conflict {
  constraint: route_type_of_line_constraint!
  update_columns: [route_type_of_line_update_column!]! = []
  where: route_type_of_line_bool_exp
}

"Ordering options when selecting data from \"route.type_of_line\"."
input route_type_of_line_order_by {
  belonging_to_vehicle_mode: order_by
  lines_aggregate: route_line_aggregate_order_by
  type_of_line: order_by
  vehicle_mode: reusable_components_vehicle_mode_order_by
}

"primary key columns input for table: route.type_of_line"
input route_type_of_line_pk_columns_input {
  "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String!
}

"input type for updating data in table \"route.type_of_line\""
input route_type_of_line_set_input {
  belonging_to_vehicle_mode: reusable_components_vehicle_mode_enum
  "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
}

"Streaming cursor of the table \"route_type_of_line\""
input route_type_of_line_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: route_type_of_line_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input route_type_of_line_stream_cursor_value_input {
  belonging_to_vehicle_mode: reusable_components_vehicle_mode_enum
  "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
}

input route_type_of_line_updates {
  "sets the columns of the filtered rows to the given values"
  _set: route_type_of_line_set_input
  "filter the rows which have to be updated"
  where: route_type_of_line_bool_exp!
}

input service_calendar_day_type_active_on_day_of_week_aggregate_bool_exp {
  count: service_calendar_day_type_active_on_day_of_week_aggregate_bool_exp_count
}

input service_calendar_day_type_active_on_day_of_week_aggregate_bool_exp_count {
  arguments: [timetables_service_calendar_day_type_active_on_day_of_week_select_column!]
  distinct: Boolean
  filter: timetables_service_calendar_day_type_active_on_day_of_week_bool_exp
  predicate: Int_comparison_exp!
}

input service_calendar_substitute_operating_day_by_line_type_aggregate_bool_exp {
  count: service_calendar_substitute_operating_day_by_line_type_aggregate_bool_exp_count
}

input service_calendar_substitute_operating_day_by_line_type_aggregate_bool_exp_count {
  arguments: [timetables_service_calendar_substitute_operating_day_by_line_type_select_column!]
  distinct: Boolean
  filter: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp
  predicate: Int_comparison_exp!
}

"Boolean expression to filter rows from the table \"service_pattern.distance_between_stops_calculation\". All fields are combined with a logical 'AND'."
input service_pattern_distance_between_stops_calculation_bool_exp {
  _and: [service_pattern_distance_between_stops_calculation_bool_exp!]
  _not: service_pattern_distance_between_stops_calculation_bool_exp
  _or: [service_pattern_distance_between_stops_calculation_bool_exp!]
  distance_in_metres: float8_comparison_exp
  end_stop_label: String_comparison_exp
  journey_pattern_id: uuid_comparison_exp
  observation_date: date_comparison_exp
  route_id: uuid_comparison_exp
  route_priority: Int_comparison_exp
  start_stop_label: String_comparison_exp
  stop_interval_sequence: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"service_pattern.distance_between_stops_calculation\""
input service_pattern_distance_between_stops_calculation_inc_input {
  "The length of the stop interval in metres."
  distance_in_metres: float8
  "The priority of the route related to the journey pattern."
  route_priority: Int
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Int
}

"input type for inserting data into table \"service_pattern.distance_between_stops_calculation\""
input service_pattern_distance_between_stops_calculation_insert_input {
  "The length of the stop interval in metres."
  distance_in_metres: float8
  "The label of the end stop of the stop interval."
  end_stop_label: String
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  "The observation date for the state of the route related to the journey pattern."
  observation_date: date
  "The ID of the route related to the journey pattern."
  route_id: uuid
  "The priority of the route related to the journey pattern."
  route_priority: Int
  "The label of the start stop of the stop interval."
  start_stop_label: String
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Int
}

"on_conflict condition type for table \"service_pattern.distance_between_stops_calculation\""
input service_pattern_distance_between_stops_calculation_on_conflict {
  constraint: service_pattern_distance_between_stops_calculation_constraint!
  update_columns: [service_pattern_distance_between_stops_calculation_update_column!]! = []
  where: service_pattern_distance_between_stops_calculation_bool_exp
}

"Ordering options when selecting data from \"service_pattern.distance_between_stops_calculation\"."
input service_pattern_distance_between_stops_calculation_order_by {
  distance_in_metres: order_by
  end_stop_label: order_by
  journey_pattern_id: order_by
  observation_date: order_by
  route_id: order_by
  route_priority: order_by
  start_stop_label: order_by
  stop_interval_sequence: order_by
}

"primary key columns input for table: service_pattern.distance_between_stops_calculation"
input service_pattern_distance_between_stops_calculation_pk_columns_input {
  "The ID of the journey pattern."
  journey_pattern_id: uuid!
  "The observation date for the state of the route related to the journey pattern."
  observation_date: date!
  "The priority of the route related to the journey pattern."
  route_priority: Int!
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Int!
}

"input type for updating data in table \"service_pattern.distance_between_stops_calculation\""
input service_pattern_distance_between_stops_calculation_set_input {
  "The length of the stop interval in metres."
  distance_in_metres: float8
  "The label of the end stop of the stop interval."
  end_stop_label: String
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  "The observation date for the state of the route related to the journey pattern."
  observation_date: date
  "The ID of the route related to the journey pattern."
  route_id: uuid
  "The priority of the route related to the journey pattern."
  route_priority: Int
  "The label of the start stop of the stop interval."
  start_stop_label: String
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Int
}

"Streaming cursor of the table \"service_pattern_distance_between_stops_calculation\""
input service_pattern_distance_between_stops_calculation_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: service_pattern_distance_between_stops_calculation_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input service_pattern_distance_between_stops_calculation_stream_cursor_value_input {
  "The length of the stop interval in metres."
  distance_in_metres: float8
  "The label of the end stop of the stop interval."
  end_stop_label: String
  "The ID of the journey pattern."
  journey_pattern_id: uuid
  "The observation date for the state of the route related to the journey pattern."
  observation_date: date
  "The ID of the route related to the journey pattern."
  route_id: uuid
  "The priority of the route related to the journey pattern."
  route_priority: Int
  "The label of the start stop of the stop interval."
  start_stop_label: String
  "The sequence number of the stop interval within the journey pattern."
  stop_interval_sequence: Int
}

input service_pattern_distance_between_stops_calculation_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: service_pattern_distance_between_stops_calculation_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: service_pattern_distance_between_stops_calculation_set_input
  "filter the rows which have to be updated"
  where: service_pattern_distance_between_stops_calculation_bool_exp!
}

input service_pattern_get_distances_between_stop_points_by_routes_args {
  observation_date: date
  route_ids: _uuid
}

input service_pattern_get_distances_between_stop_points_in_journey_patterns_args {
  include_draft_stops: Boolean
  journey_pattern_ids: _uuid
  observation_date: date
}

input service_pattern_scheduled_stop_point_aggregate_bool_exp {
  count: service_pattern_scheduled_stop_point_aggregate_bool_exp_count
}

input service_pattern_scheduled_stop_point_aggregate_bool_exp_count {
  arguments: [service_pattern_scheduled_stop_point_select_column!]
  distinct: Boolean
  filter: service_pattern_scheduled_stop_point_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_aggregate_order_by {
  avg: service_pattern_scheduled_stop_point_avg_order_by
  count: order_by
  max: service_pattern_scheduled_stop_point_max_order_by
  min: service_pattern_scheduled_stop_point_min_order_by
  stddev: service_pattern_scheduled_stop_point_stddev_order_by
  stddev_pop: service_pattern_scheduled_stop_point_stddev_pop_order_by
  stddev_samp: service_pattern_scheduled_stop_point_stddev_samp_order_by
  sum: service_pattern_scheduled_stop_point_sum_order_by
  var_pop: service_pattern_scheduled_stop_point_var_pop_order_by
  var_samp: service_pattern_scheduled_stop_point_var_samp_order_by
  variance: service_pattern_scheduled_stop_point_variance_order_by
}

"input type for inserting array relation for remote table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_arr_rel_insert_input {
  data: [service_pattern_scheduled_stop_point_insert_input!]!
  "upsert condition"
  on_conflict: service_pattern_scheduled_stop_point_on_conflict
}

"order by avg() on columns of table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_avg_order_by {
  priority: order_by
}

"Boolean expression to filter rows from the table \"service_pattern.scheduled_stop_point\". All fields are combined with a logical 'AND'."
input service_pattern_scheduled_stop_point_bool_exp {
  _and: [service_pattern_scheduled_stop_point_bool_exp!]
  _not: service_pattern_scheduled_stop_point_bool_exp
  _or: [service_pattern_scheduled_stop_point_bool_exp!]
  closest_point_on_infrastructure_link: geography_comparison_exp
  direction: infrastructure_network_direction_enum_comparison_exp
  label: String_comparison_exp
  located_on_infrastructure_link: infrastructure_network_infrastructure_link_bool_exp
  located_on_infrastructure_link_id: uuid_comparison_exp
  measured_location: geography_comparison_exp
  other_label_instances: service_pattern_scheduled_stop_point_bool_exp
  other_label_instances_aggregate: service_pattern_scheduled_stop_point_aggregate_bool_exp
  priority: Int_comparison_exp
  relative_distance_from_infrastructure_link_start: float8_comparison_exp
  scheduled_stop_point_id: uuid_comparison_exp
  scheduled_stop_point_in_journey_patterns: journey_pattern_scheduled_stop_point_in_journey_pattern_bool_exp
  scheduled_stop_point_in_journey_patterns_aggregate: journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp
  timing_place: timing_pattern_timing_place_bool_exp
  timing_place_id: uuid_comparison_exp
  validity_end: date_comparison_exp
  validity_start: date_comparison_exp
  vehicle_mode_on_scheduled_stop_point: service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp
  vehicle_mode_on_scheduled_stop_point_aggregate: service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate_bool_exp
}

input service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate_bool_exp {
  count: service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate_bool_exp_count
}

input service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate_bool_exp_count {
  arguments: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_select_column!]
  distinct: Boolean
  filter: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp
  predicate: Int_comparison_exp!
}

"input type for incrementing numeric columns in table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_inc_input {
  priority: Int
}

"input type for inserting data into table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_insert_input {
  "The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string."
  direction: infrastructure_network_direction_enum
  "The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code."
  label: String
  located_on_infrastructure_link: infrastructure_network_infrastructure_link_obj_rel_insert_input
  "The infrastructure link on which the stop is located."
  located_on_infrastructure_link_id: uuid
  "The measured location describes the physical location of the stop. For some stops this describes the location of the pole-mounted flag. A PostGIS PointZ geography in EPSG:4326."
  measured_location: geography
  other_label_instances: service_pattern_scheduled_stop_point_arr_rel_insert_input
  priority: Int
  "The ID of the scheduled stop point."
  scheduled_stop_point_id: uuid
  scheduled_stop_point_in_journey_patterns: journey_pattern_scheduled_stop_point_in_journey_pattern_arr_rel_insert_input
  timing_place: timing_pattern_timing_place_obj_rel_insert_input
  "Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing."
  timing_place_id: uuid
  "end of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_end: date
  "start of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_start: date
  vehicle_mode_on_scheduled_stop_point: service_pattern_vehicle_mode_on_scheduled_stop_point_arr_rel_insert_input
}

"order by max() on columns of table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_max_order_by {
  "The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code."
  label: order_by
  "The infrastructure link on which the stop is located."
  located_on_infrastructure_link_id: order_by
  priority: order_by
  "The ID of the scheduled stop point."
  scheduled_stop_point_id: order_by
  "Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing."
  timing_place_id: order_by
  "end of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_end: order_by
  "start of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_start: order_by
}

"order by min() on columns of table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_min_order_by {
  "The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code."
  label: order_by
  "The infrastructure link on which the stop is located."
  located_on_infrastructure_link_id: order_by
  priority: order_by
  "The ID of the scheduled stop point."
  scheduled_stop_point_id: order_by
  "Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing."
  timing_place_id: order_by
  "end of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_end: order_by
  "start of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_start: order_by
}

"on_conflict condition type for table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_on_conflict {
  constraint: service_pattern_scheduled_stop_point_constraint!
  update_columns: [service_pattern_scheduled_stop_point_update_column!]! = []
  where: service_pattern_scheduled_stop_point_bool_exp
}

"Ordering options when selecting data from \"service_pattern.scheduled_stop_point\"."
input service_pattern_scheduled_stop_point_order_by {
  closest_point_on_infrastructure_link: order_by
  direction: order_by
  label: order_by
  located_on_infrastructure_link: infrastructure_network_infrastructure_link_order_by
  located_on_infrastructure_link_id: order_by
  measured_location: order_by
  other_label_instances_aggregate: service_pattern_scheduled_stop_point_aggregate_order_by
  priority: order_by
  relative_distance_from_infrastructure_link_start: order_by
  scheduled_stop_point_id: order_by
  scheduled_stop_point_in_journey_patterns_aggregate: journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_order_by
  timing_place: timing_pattern_timing_place_order_by
  timing_place_id: order_by
  validity_end: order_by
  validity_start: order_by
  vehicle_mode_on_scheduled_stop_point_aggregate: service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate_order_by
}

"primary key columns input for table: service_pattern.scheduled_stop_point"
input service_pattern_scheduled_stop_point_pk_columns_input {
  "The ID of the scheduled stop point."
  scheduled_stop_point_id: uuid!
}

"input type for updating data in table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_set_input {
  "The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string."
  direction: infrastructure_network_direction_enum
  "The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code."
  label: String
  "The infrastructure link on which the stop is located."
  located_on_infrastructure_link_id: uuid
  "The measured location describes the physical location of the stop. For some stops this describes the location of the pole-mounted flag. A PostGIS PointZ geography in EPSG:4326."
  measured_location: geography
  priority: Int
  "The ID of the scheduled stop point."
  scheduled_stop_point_id: uuid
  "Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing."
  timing_place_id: uuid
  "end of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_end: date
  "start of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_start: date
}

"order by stddev() on columns of table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_stddev_order_by {
  priority: order_by
}

"order by stddev_pop() on columns of table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_stddev_pop_order_by {
  priority: order_by
}

"order by stddev_samp() on columns of table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_stddev_samp_order_by {
  priority: order_by
}

"Streaming cursor of the table \"service_pattern_scheduled_stop_point\""
input service_pattern_scheduled_stop_point_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: service_pattern_scheduled_stop_point_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input service_pattern_scheduled_stop_point_stream_cursor_value_input {
  "The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string."
  direction: infrastructure_network_direction_enum
  "The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code."
  label: String
  "The infrastructure link on which the stop is located."
  located_on_infrastructure_link_id: uuid
  "The measured location describes the physical location of the stop. For some stops this describes the location of the pole-mounted flag. A PostGIS PointZ geography in EPSG:4326."
  measured_location: geography
  priority: Int
  "The ID of the scheduled stop point."
  scheduled_stop_point_id: uuid
  "Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing."
  timing_place_id: uuid
  "end of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_end: date
  "start of the operating date span in the scheduled stop point's local time (inclusive)."
  validity_start: date
}

"order by sum() on columns of table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_sum_order_by {
  priority: order_by
}

input service_pattern_scheduled_stop_point_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: service_pattern_scheduled_stop_point_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: service_pattern_scheduled_stop_point_set_input
  "filter the rows which have to be updated"
  where: service_pattern_scheduled_stop_point_bool_exp!
}

"order by var_pop() on columns of table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_var_pop_order_by {
  priority: order_by
}

"order by var_samp() on columns of table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_var_samp_order_by {
  priority: order_by
}

"order by variance() on columns of table \"service_pattern.scheduled_stop_point\""
input service_pattern_scheduled_stop_point_variance_order_by {
  priority: order_by
}

input service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate_bool_exp {
  count: service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate_bool_exp_count
}

input service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate_bool_exp_count {
  arguments: [service_pattern_vehicle_mode_on_scheduled_stop_point_select_column!]
  distinct: Boolean
  filter: service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
input service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate_order_by {
  count: order_by
  max: service_pattern_vehicle_mode_on_scheduled_stop_point_max_order_by
  min: service_pattern_vehicle_mode_on_scheduled_stop_point_min_order_by
}

"input type for inserting array relation for remote table \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
input service_pattern_vehicle_mode_on_scheduled_stop_point_arr_rel_insert_input {
  data: [service_pattern_vehicle_mode_on_scheduled_stop_point_insert_input!]!
  "upsert condition"
  on_conflict: service_pattern_vehicle_mode_on_scheduled_stop_point_on_conflict
}

"Boolean expression to filter rows from the table \"service_pattern.vehicle_mode_on_scheduled_stop_point\". All fields are combined with a logical 'AND'."
input service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp {
  _and: [service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp!]
  _not: service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp
  _or: [service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp!]
  scheduled_stop_point_id: uuid_comparison_exp
  vehicle_mode: reusable_components_vehicle_mode_enum_comparison_exp
}

"input type for inserting data into table \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
input service_pattern_vehicle_mode_on_scheduled_stop_point_insert_input {
  "The scheduled stop point that is serviced by the vehicle mode."
  scheduled_stop_point_id: uuid
  "The vehicle mode servicing the scheduled stop point."
  vehicle_mode: reusable_components_vehicle_mode_enum
}

"order by max() on columns of table \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
input service_pattern_vehicle_mode_on_scheduled_stop_point_max_order_by {
  "The scheduled stop point that is serviced by the vehicle mode."
  scheduled_stop_point_id: order_by
}

"order by min() on columns of table \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
input service_pattern_vehicle_mode_on_scheduled_stop_point_min_order_by {
  "The scheduled stop point that is serviced by the vehicle mode."
  scheduled_stop_point_id: order_by
}

"on_conflict condition type for table \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
input service_pattern_vehicle_mode_on_scheduled_stop_point_on_conflict {
  constraint: service_pattern_vehicle_mode_on_scheduled_stop_point_constraint!
  update_columns: [service_pattern_vehicle_mode_on_scheduled_stop_point_update_column!]! = []
  where: service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp
}

"Ordering options when selecting data from \"service_pattern.vehicle_mode_on_scheduled_stop_point\"."
input service_pattern_vehicle_mode_on_scheduled_stop_point_order_by {
  scheduled_stop_point_id: order_by
  vehicle_mode: order_by
}

"primary key columns input for table: service_pattern.vehicle_mode_on_scheduled_stop_point"
input service_pattern_vehicle_mode_on_scheduled_stop_point_pk_columns_input {
  "The scheduled stop point that is serviced by the vehicle mode."
  scheduled_stop_point_id: uuid!
  "The vehicle mode servicing the scheduled stop point."
  vehicle_mode: reusable_components_vehicle_mode_enum!
}

"input type for updating data in table \"service_pattern.vehicle_mode_on_scheduled_stop_point\""
input service_pattern_vehicle_mode_on_scheduled_stop_point_set_input {
  "The scheduled stop point that is serviced by the vehicle mode."
  scheduled_stop_point_id: uuid
  "The vehicle mode servicing the scheduled stop point."
  vehicle_mode: reusable_components_vehicle_mode_enum
}

"Streaming cursor of the table \"service_pattern_vehicle_mode_on_scheduled_stop_point\""
input service_pattern_vehicle_mode_on_scheduled_stop_point_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: service_pattern_vehicle_mode_on_scheduled_stop_point_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input service_pattern_vehicle_mode_on_scheduled_stop_point_stream_cursor_value_input {
  "The scheduled stop point that is serviced by the vehicle mode."
  scheduled_stop_point_id: uuid
  "The vehicle mode servicing the scheduled stop point."
  vehicle_mode: reusable_components_vehicle_mode_enum
}

input service_pattern_vehicle_mode_on_scheduled_stop_point_updates {
  "sets the columns of the filtered rows to the given values"
  _set: service_pattern_vehicle_mode_on_scheduled_stop_point_set_input
  "filter the rows which have to be updated"
  where: service_pattern_vehicle_mode_on_scheduled_stop_point_bool_exp!
}

"Boolean expression to compare columns of type \"smallint\". All fields are combined with logical 'AND'."
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

input st_d_within_geography_input {
  distance: Float!
  from: geography!
  use_spheroid: Boolean = true
}

input st_d_within_input {
  distance: Float!
  from: geometry!
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"Boolean expression to filter rows from the table \"journey_pattern.journey_pattern_ref\". All fields are combined with a logical 'AND'."
input timetables_journey_pattern_journey_pattern_ref_bool_exp {
  _and: [timetables_journey_pattern_journey_pattern_ref_bool_exp!]
  _not: timetables_journey_pattern_journey_pattern_ref_bool_exp
  _or: [timetables_journey_pattern_journey_pattern_ref_bool_exp!]
  journey_pattern_id: uuid_comparison_exp
  journey_pattern_ref_id: uuid_comparison_exp
  observation_timestamp: timestamptz_comparison_exp
  route_direction: route_direction_enum_comparison_exp
  route_label: String_comparison_exp
  route_validity_end: date_comparison_exp
  route_validity_start: date_comparison_exp
  scheduled_stop_point_in_journey_pattern_refs: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp
  scheduled_stop_point_in_journey_pattern_refs_aggregate: service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate_bool_exp
  snapshot_timestamp: timestamptz_comparison_exp
  type_of_line: String_comparison_exp
  vehicle_journeys: timetables_vehicle_journey_vehicle_journey_bool_exp
  vehicle_journeys_aggregate: vehicle_journey_vehicle_journey_aggregate_bool_exp
}

"input type for inserting data into table \"journey_pattern.journey_pattern_ref\""
input timetables_journey_pattern_journey_pattern_ref_insert_input {
  "The ID of the referenced JOURNEY PATTERN"
  journey_pattern_id: uuid
  journey_pattern_ref_id: uuid
  "The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning."
  observation_timestamp: timestamptz
  "The direction of the route associated with the referenced journey pattern"
  route_direction: timetables_route_direction_enum
  "The label of the route associated with the referenced journey pattern"
  route_label: String
  "The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity)."
  route_validity_end: date
  "The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity)."
  route_validity_start: date
  scheduled_stop_point_in_journey_pattern_refs: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_arr_rel_insert_input
  "The timestamp when the snapshot was taken"
  snapshot_timestamp: timestamptz
  "The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
  vehicle_journeys: timetables_vehicle_journey_vehicle_journey_arr_rel_insert_input
}

"input type for inserting object relation for remote table \"journey_pattern.journey_pattern_ref\""
input timetables_journey_pattern_journey_pattern_ref_obj_rel_insert_input {
  data: timetables_journey_pattern_journey_pattern_ref_insert_input!
  "upsert condition"
  on_conflict: timetables_journey_pattern_journey_pattern_ref_on_conflict
}

"on_conflict condition type for table \"journey_pattern.journey_pattern_ref\""
input timetables_journey_pattern_journey_pattern_ref_on_conflict {
  constraint: timetables_journey_pattern_journey_pattern_ref_constraint!
  update_columns: [timetables_journey_pattern_journey_pattern_ref_update_column!]! = []
  where: timetables_journey_pattern_journey_pattern_ref_bool_exp
}

"Ordering options when selecting data from \"journey_pattern.journey_pattern_ref\"."
input timetables_journey_pattern_journey_pattern_ref_order_by {
  journey_pattern_id: order_by
  journey_pattern_ref_id: order_by
  observation_timestamp: order_by
  route_direction: order_by
  route_label: order_by
  route_validity_end: order_by
  route_validity_start: order_by
  scheduled_stop_point_in_journey_pattern_refs_aggregate: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate_order_by
  snapshot_timestamp: order_by
  type_of_line: order_by
  vehicle_journeys_aggregate: timetables_vehicle_journey_vehicle_journey_aggregate_order_by
}

"primary key columns input for table: journey_pattern.journey_pattern_ref"
input timetables_journey_pattern_journey_pattern_ref_pk_columns_input {
  journey_pattern_ref_id: uuid!
}

"input type for updating data in table \"journey_pattern.journey_pattern_ref\""
input timetables_journey_pattern_journey_pattern_ref_set_input {
  "The ID of the referenced JOURNEY PATTERN"
  journey_pattern_id: uuid
  journey_pattern_ref_id: uuid
  "The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning."
  observation_timestamp: timestamptz
  "The direction of the route associated with the referenced journey pattern"
  route_direction: timetables_route_direction_enum
  "The label of the route associated with the referenced journey pattern"
  route_label: String
  "The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity)."
  route_validity_end: date
  "The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity)."
  route_validity_start: date
  "The timestamp when the snapshot was taken"
  snapshot_timestamp: timestamptz
  "The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
}

"Streaming cursor of the table \"journey_pattern_journey_pattern_ref\""
input timetables_journey_pattern_journey_pattern_ref_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_journey_pattern_journey_pattern_ref_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_journey_pattern_journey_pattern_ref_stream_cursor_value_input {
  "The ID of the referenced JOURNEY PATTERN"
  journey_pattern_id: uuid
  journey_pattern_ref_id: uuid
  "The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning."
  observation_timestamp: timestamptz
  "The direction of the route associated with the referenced journey pattern"
  route_direction: timetables_route_direction_enum
  "The label of the route associated with the referenced journey pattern"
  route_label: String
  "The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity)."
  route_validity_end: date
  "The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity)."
  route_validity_start: date
  "The timestamp when the snapshot was taken"
  snapshot_timestamp: timestamptz
  "The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
}

input timetables_journey_pattern_journey_pattern_ref_updates {
  "sets the columns of the filtered rows to the given values"
  _set: timetables_journey_pattern_journey_pattern_ref_set_input
  "filter the rows which have to be updated"
  where: timetables_journey_pattern_journey_pattern_ref_bool_exp!
}

"order by aggregate values of table \"passing_times.timetabled_passing_time\""
input timetables_passing_times_timetabled_passing_time_aggregate_order_by {
  count: order_by
  max: timetables_passing_times_timetabled_passing_time_max_order_by
  min: timetables_passing_times_timetabled_passing_time_min_order_by
}

"input type for inserting array relation for remote table \"passing_times.timetabled_passing_time\""
input timetables_passing_times_timetabled_passing_time_arr_rel_insert_input {
  data: [timetables_passing_times_timetabled_passing_time_insert_input!]!
  "upsert condition"
  on_conflict: timetables_passing_times_timetabled_passing_time_on_conflict
}

"Boolean expression to filter rows from the table \"passing_times.timetabled_passing_time\". All fields are combined with a logical 'AND'."
input timetables_passing_times_timetabled_passing_time_bool_exp {
  _and: [timetables_passing_times_timetabled_passing_time_bool_exp!]
  _not: timetables_passing_times_timetabled_passing_time_bool_exp
  _or: [timetables_passing_times_timetabled_passing_time_bool_exp!]
  arrival_time: interval_comparison_exp
  departure_time: interval_comparison_exp
  passing_time: interval_comparison_exp
  scheduled_stop_point_in_journey_pattern_ref: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp
  scheduled_stop_point_in_journey_pattern_ref_id: uuid_comparison_exp
  timetabled_passing_time_id: uuid_comparison_exp
  vehicle_journey: timetables_vehicle_journey_vehicle_journey_bool_exp
  vehicle_journey_id: uuid_comparison_exp
}

"input type for inserting data into table \"passing_times.timetabled_passing_time\""
input timetables_passing_times_timetabled_passing_time_insert_input {
  "The time when the vehicle arrives to the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the departure time is defined for the passing time. E.g. in case this is the first SCHEDULED STOP POINT of the journey."
  arrival_time: interval
  "The time when the vehicle departs from the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the arrival time is defined for the passing time. E.g. in case this is the last SCHEDULED STOP POINT of the journey."
  departure_time: interval
  scheduled_stop_point_in_journey_pattern_ref: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_obj_rel_insert_input
  "The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes"
  scheduled_stop_point_in_journey_pattern_ref_id: uuid
  timetabled_passing_time_id: uuid
  vehicle_journey: timetables_vehicle_journey_vehicle_journey_obj_rel_insert_input
  "The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs"
  vehicle_journey_id: uuid
}

"order by max() on columns of table \"passing_times.timetabled_passing_time\""
input timetables_passing_times_timetabled_passing_time_max_order_by {
  "The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes"
  scheduled_stop_point_in_journey_pattern_ref_id: order_by
  timetabled_passing_time_id: order_by
  "The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs"
  vehicle_journey_id: order_by
}

"order by min() on columns of table \"passing_times.timetabled_passing_time\""
input timetables_passing_times_timetabled_passing_time_min_order_by {
  "The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes"
  scheduled_stop_point_in_journey_pattern_ref_id: order_by
  timetabled_passing_time_id: order_by
  "The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs"
  vehicle_journey_id: order_by
}

"on_conflict condition type for table \"passing_times.timetabled_passing_time\""
input timetables_passing_times_timetabled_passing_time_on_conflict {
  constraint: timetables_passing_times_timetabled_passing_time_constraint!
  update_columns: [timetables_passing_times_timetabled_passing_time_update_column!]! = []
  where: timetables_passing_times_timetabled_passing_time_bool_exp
}

"Ordering options when selecting data from \"passing_times.timetabled_passing_time\"."
input timetables_passing_times_timetabled_passing_time_order_by {
  arrival_time: order_by
  departure_time: order_by
  passing_time: order_by
  scheduled_stop_point_in_journey_pattern_ref: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_order_by
  scheduled_stop_point_in_journey_pattern_ref_id: order_by
  timetabled_passing_time_id: order_by
  vehicle_journey: timetables_vehicle_journey_vehicle_journey_order_by
  vehicle_journey_id: order_by
}

"primary key columns input for table: passing_times.timetabled_passing_time"
input timetables_passing_times_timetabled_passing_time_pk_columns_input {
  timetabled_passing_time_id: uuid!
}

"input type for updating data in table \"passing_times.timetabled_passing_time\""
input timetables_passing_times_timetabled_passing_time_set_input {
  "The time when the vehicle arrives to the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the departure time is defined for the passing time. E.g. in case this is the first SCHEDULED STOP POINT of the journey."
  arrival_time: interval
  "The time when the vehicle departs from the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the arrival time is defined for the passing time. E.g. in case this is the last SCHEDULED STOP POINT of the journey."
  departure_time: interval
  "The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes"
  scheduled_stop_point_in_journey_pattern_ref_id: uuid
  timetabled_passing_time_id: uuid
  "The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs"
  vehicle_journey_id: uuid
}

"Streaming cursor of the table \"passing_times_timetabled_passing_time\""
input timetables_passing_times_timetabled_passing_time_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_passing_times_timetabled_passing_time_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_passing_times_timetabled_passing_time_stream_cursor_value_input {
  "The time when the vehicle arrives to the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the departure time is defined for the passing time. E.g. in case this is the first SCHEDULED STOP POINT of the journey."
  arrival_time: interval
  "The time when the vehicle departs from the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the arrival time is defined for the passing time. E.g. in case this is the last SCHEDULED STOP POINT of the journey."
  departure_time: interval
  "The time when the vehicle can be considered as passing a SCHEDULED STOP POINT. Computed field to ease development; it can never be NULL."
  passing_time: interval
  "The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes"
  scheduled_stop_point_in_journey_pattern_ref_id: uuid
  timetabled_passing_time_id: uuid
  "The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs"
  vehicle_journey_id: uuid
}

input timetables_passing_times_timetabled_passing_time_updates {
  "sets the columns of the filtered rows to the given values"
  _set: timetables_passing_times_timetabled_passing_time_set_input
  "filter the rows which have to be updated"
  where: timetables_passing_times_timetabled_passing_time_bool_exp!
}

"Boolean expression to filter rows from the table \"return_value.timetable_version\". All fields are combined with a logical 'AND'."
input timetables_return_value_timetable_version_bool_exp {
  _and: [timetables_return_value_timetable_version_bool_exp!]
  _not: timetables_return_value_timetable_version_bool_exp
  _or: [timetables_return_value_timetable_version_bool_exp!]
  day_type: timetables_service_calendar_day_type_bool_exp
  day_type_id: uuid_comparison_exp
  in_effect: Boolean_comparison_exp
  priority: Int_comparison_exp
  substitute_operating_day_by_line_type: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp
  substitute_operating_day_by_line_type_id: uuid_comparison_exp
  validity_end: date_comparison_exp
  validity_start: date_comparison_exp
  vehicle_schedule_frame: timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp
  vehicle_schedule_frame_id: uuid_comparison_exp
}

"input type for incrementing numeric columns in table \"return_value.timetable_version\""
input timetables_return_value_timetable_version_inc_input {
  priority: Int
}

"input type for inserting data into table \"return_value.timetable_version\""
input timetables_return_value_timetable_version_insert_input {
  day_type: timetables_service_calendar_day_type_obj_rel_insert_input
  day_type_id: uuid
  in_effect: Boolean
  priority: Int
  substitute_operating_day_by_line_type: timetables_service_calendar_substitute_operating_day_by_line_type_obj_rel_insert_input
  substitute_operating_day_by_line_type_id: uuid
  validity_end: date
  validity_start: date
  vehicle_schedule_frame: timetables_vehicle_schedule_vehicle_schedule_frame_obj_rel_insert_input
  vehicle_schedule_frame_id: uuid
}

"Ordering options when selecting data from \"return_value.timetable_version\"."
input timetables_return_value_timetable_version_order_by {
  day_type: timetables_service_calendar_day_type_order_by
  day_type_id: order_by
  in_effect: order_by
  priority: order_by
  substitute_operating_day_by_line_type: timetables_service_calendar_substitute_operating_day_by_line_type_order_by
  substitute_operating_day_by_line_type_id: order_by
  validity_end: order_by
  validity_start: order_by
  vehicle_schedule_frame: timetables_vehicle_schedule_vehicle_schedule_frame_order_by
  vehicle_schedule_frame_id: order_by
}

"input type for updating data in table \"return_value.timetable_version\""
input timetables_return_value_timetable_version_set_input {
  day_type_id: uuid
  in_effect: Boolean
  priority: Int
  substitute_operating_day_by_line_type_id: uuid
  validity_end: date
  validity_start: date
  vehicle_schedule_frame_id: uuid
}

"Streaming cursor of the table \"return_value_timetable_version\""
input timetables_return_value_timetable_version_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_return_value_timetable_version_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_return_value_timetable_version_stream_cursor_value_input {
  day_type_id: uuid
  in_effect: Boolean
  priority: Int
  substitute_operating_day_by_line_type_id: uuid
  validity_end: date
  validity_start: date
  vehicle_schedule_frame_id: uuid
}

input timetables_return_value_timetable_version_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: timetables_return_value_timetable_version_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: timetables_return_value_timetable_version_set_input
  "filter the rows which have to be updated"
  where: timetables_return_value_timetable_version_bool_exp!
}

"Boolean expression to filter rows from the table \"return_value.vehicle_schedule\". All fields are combined with a logical 'AND'."
input timetables_return_value_vehicle_schedule_bool_exp {
  _and: [timetables_return_value_vehicle_schedule_bool_exp!]
  _not: timetables_return_value_vehicle_schedule_bool_exp
  _or: [timetables_return_value_vehicle_schedule_bool_exp!]
  created_at: timestamptz_comparison_exp
  day_type: timetables_service_calendar_day_type_bool_exp
  day_type_id: uuid_comparison_exp
  priority: Int_comparison_exp
  substitute_operating_day_by_line_type_id: uuid_comparison_exp
  validity_end: date_comparison_exp
  validity_start: date_comparison_exp
  vehicle_journey: timetables_vehicle_journey_vehicle_journey_bool_exp
  vehicle_journey_id: uuid_comparison_exp
  vehicle_schedule_frame_id: uuid_comparison_exp
}

"input type for incrementing numeric columns in table \"return_value.vehicle_schedule\""
input timetables_return_value_vehicle_schedule_inc_input {
  priority: Int
}

"input type for inserting data into table \"return_value.vehicle_schedule\""
input timetables_return_value_vehicle_schedule_insert_input {
  created_at: timestamptz
  day_type: timetables_service_calendar_day_type_obj_rel_insert_input
  day_type_id: uuid
  priority: Int
  substitute_operating_day_by_line_type_id: uuid
  validity_end: date
  validity_start: date
  vehicle_journey: timetables_vehicle_journey_vehicle_journey_obj_rel_insert_input
  vehicle_journey_id: uuid
  vehicle_schedule_frame_id: uuid
}

"Ordering options when selecting data from \"return_value.vehicle_schedule\"."
input timetables_return_value_vehicle_schedule_order_by {
  created_at: order_by
  day_type: timetables_service_calendar_day_type_order_by
  day_type_id: order_by
  priority: order_by
  substitute_operating_day_by_line_type_id: order_by
  validity_end: order_by
  validity_start: order_by
  vehicle_journey: timetables_vehicle_journey_vehicle_journey_order_by
  vehicle_journey_id: order_by
  vehicle_schedule_frame_id: order_by
}

"input type for updating data in table \"return_value.vehicle_schedule\""
input timetables_return_value_vehicle_schedule_set_input {
  created_at: timestamptz
  day_type_id: uuid
  priority: Int
  substitute_operating_day_by_line_type_id: uuid
  validity_end: date
  validity_start: date
  vehicle_journey_id: uuid
  vehicle_schedule_frame_id: uuid
}

"Streaming cursor of the table \"return_value_vehicle_schedule\""
input timetables_return_value_vehicle_schedule_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_return_value_vehicle_schedule_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_return_value_vehicle_schedule_stream_cursor_value_input {
  created_at: timestamptz
  day_type_id: uuid
  priority: Int
  substitute_operating_day_by_line_type_id: uuid
  validity_end: date
  validity_start: date
  vehicle_journey_id: uuid
  vehicle_schedule_frame_id: uuid
}

input timetables_return_value_vehicle_schedule_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: timetables_return_value_vehicle_schedule_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: timetables_return_value_vehicle_schedule_set_input
  "filter the rows which have to be updated"
  where: timetables_return_value_vehicle_schedule_bool_exp!
}

"Boolean expression to filter rows from the table \"route.direction\". All fields are combined with a logical 'AND'."
input timetables_route_direction_bool_exp {
  _and: [timetables_route_direction_bool_exp!]
  _not: timetables_route_direction_bool_exp
  _or: [timetables_route_direction_bool_exp!]
  direction: String_comparison_exp
  the_opposite_of_direction: route_direction_enum_comparison_exp
}

"input type for inserting data into table \"route.direction\""
input timetables_route_direction_insert_input {
  "The name of the route direction"
  direction: String
  "The opposite direction"
  the_opposite_of_direction: timetables_route_direction_enum
}

"on_conflict condition type for table \"route.direction\""
input timetables_route_direction_on_conflict {
  constraint: timetables_route_direction_constraint!
  update_columns: [timetables_route_direction_update_column!]! = []
  where: timetables_route_direction_bool_exp
}

"Ordering options when selecting data from \"route.direction\"."
input timetables_route_direction_order_by {
  direction: order_by
  the_opposite_of_direction: order_by
}

"primary key columns input for table: route.direction"
input timetables_route_direction_pk_columns_input {
  "The name of the route direction"
  direction: String!
}

"input type for updating data in table \"route.direction\""
input timetables_route_direction_set_input {
  "The name of the route direction"
  direction: String
  "The opposite direction"
  the_opposite_of_direction: timetables_route_direction_enum
}

"Streaming cursor of the table \"route_direction\""
input timetables_route_direction_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_route_direction_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_route_direction_stream_cursor_value_input {
  "The name of the route direction"
  direction: String
  "The opposite direction"
  the_opposite_of_direction: timetables_route_direction_enum
}

input timetables_route_direction_updates {
  "sets the columns of the filtered rows to the given values"
  _set: timetables_route_direction_set_input
  "filter the rows which have to be updated"
  where: timetables_route_direction_bool_exp!
}

"Boolean expression to filter rows from the table \"route.type_of_line\". All fields are combined with a logical 'AND'."
input timetables_route_type_of_line_bool_exp {
  _and: [timetables_route_type_of_line_bool_exp!]
  _not: timetables_route_type_of_line_bool_exp
  _or: [timetables_route_type_of_line_bool_exp!]
  type_of_line: String_comparison_exp
}

"input type for inserting data into table \"route.type_of_line\""
input timetables_route_type_of_line_insert_input {
  "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
}

"on_conflict condition type for table \"route.type_of_line\""
input timetables_route_type_of_line_on_conflict {
  constraint: timetables_route_type_of_line_constraint!
  update_columns: [timetables_route_type_of_line_update_column!]! = []
  where: timetables_route_type_of_line_bool_exp
}

"Ordering options when selecting data from \"route.type_of_line\"."
input timetables_route_type_of_line_order_by {
  type_of_line: order_by
}

"primary key columns input for table: route.type_of_line"
input timetables_route_type_of_line_pk_columns_input {
  "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String!
}

"input type for updating data in table \"route.type_of_line\""
input timetables_route_type_of_line_set_input {
  "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
}

"Streaming cursor of the table \"route_type_of_line\""
input timetables_route_type_of_line_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_route_type_of_line_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_route_type_of_line_stream_cursor_value_input {
  "GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types"
  type_of_line: String
}

input timetables_route_type_of_line_updates {
  "sets the columns of the filtered rows to the given values"
  _set: timetables_route_type_of_line_set_input
  "filter the rows which have to be updated"
  where: timetables_route_type_of_line_bool_exp!
}

"order by aggregate values of table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_aggregate_order_by {
  avg: timetables_service_calendar_day_type_active_on_day_of_week_avg_order_by
  count: order_by
  max: timetables_service_calendar_day_type_active_on_day_of_week_max_order_by
  min: timetables_service_calendar_day_type_active_on_day_of_week_min_order_by
  stddev: timetables_service_calendar_day_type_active_on_day_of_week_stddev_order_by
  stddev_pop: timetables_service_calendar_day_type_active_on_day_of_week_stddev_pop_order_by
  stddev_samp: timetables_service_calendar_day_type_active_on_day_of_week_stddev_samp_order_by
  sum: timetables_service_calendar_day_type_active_on_day_of_week_sum_order_by
  var_pop: timetables_service_calendar_day_type_active_on_day_of_week_var_pop_order_by
  var_samp: timetables_service_calendar_day_type_active_on_day_of_week_var_samp_order_by
  variance: timetables_service_calendar_day_type_active_on_day_of_week_variance_order_by
}

"input type for inserting array relation for remote table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_arr_rel_insert_input {
  data: [timetables_service_calendar_day_type_active_on_day_of_week_insert_input!]!
  "upsert condition"
  on_conflict: timetables_service_calendar_day_type_active_on_day_of_week_on_conflict
}

"order by avg() on columns of table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_avg_order_by {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: order_by
}

"Boolean expression to filter rows from the table \"service_calendar.day_type_active_on_day_of_week\". All fields are combined with a logical 'AND'."
input timetables_service_calendar_day_type_active_on_day_of_week_bool_exp {
  _and: [timetables_service_calendar_day_type_active_on_day_of_week_bool_exp!]
  _not: timetables_service_calendar_day_type_active_on_day_of_week_bool_exp
  _or: [timetables_service_calendar_day_type_active_on_day_of_week_bool_exp!]
  day_of_week: Int_comparison_exp
  day_type: timetables_service_calendar_day_type_bool_exp
  day_type_id: uuid_comparison_exp
}

"input type for incrementing numeric columns in table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_inc_input {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Int
}

"input type for inserting data into table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_insert_input {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Int
  day_type: timetables_service_calendar_day_type_obj_rel_insert_input
  "The DAY TYPE for which we define the activeness"
  day_type_id: uuid
}

"order by max() on columns of table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_max_order_by {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: order_by
  "The DAY TYPE for which we define the activeness"
  day_type_id: order_by
}

"order by min() on columns of table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_min_order_by {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: order_by
  "The DAY TYPE for which we define the activeness"
  day_type_id: order_by
}

"on_conflict condition type for table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_on_conflict {
  constraint: timetables_service_calendar_day_type_active_on_day_of_week_constraint!
  update_columns: [timetables_service_calendar_day_type_active_on_day_of_week_update_column!]! = []
  where: timetables_service_calendar_day_type_active_on_day_of_week_bool_exp
}

"Ordering options when selecting data from \"service_calendar.day_type_active_on_day_of_week\"."
input timetables_service_calendar_day_type_active_on_day_of_week_order_by {
  day_of_week: order_by
  day_type: timetables_service_calendar_day_type_order_by
  day_type_id: order_by
}

"primary key columns input for table: service_calendar.day_type_active_on_day_of_week"
input timetables_service_calendar_day_type_active_on_day_of_week_pk_columns_input {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Int!
  "The DAY TYPE for which we define the activeness"
  day_type_id: uuid!
}

"input type for updating data in table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_set_input {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Int
  "The DAY TYPE for which we define the activeness"
  day_type_id: uuid
}

"order by stddev() on columns of table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_stddev_order_by {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: order_by
}

"order by stddev_pop() on columns of table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_stddev_pop_order_by {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: order_by
}

"order by stddev_samp() on columns of table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_stddev_samp_order_by {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: order_by
}

"Streaming cursor of the table \"service_calendar_day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_service_calendar_day_type_active_on_day_of_week_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_service_calendar_day_type_active_on_day_of_week_stream_cursor_value_input {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: Int
  "The DAY TYPE for which we define the activeness"
  day_type_id: uuid
}

"order by sum() on columns of table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_sum_order_by {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: order_by
}

input timetables_service_calendar_day_type_active_on_day_of_week_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: timetables_service_calendar_day_type_active_on_day_of_week_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: timetables_service_calendar_day_type_active_on_day_of_week_set_input
  "filter the rows which have to be updated"
  where: timetables_service_calendar_day_type_active_on_day_of_week_bool_exp!
}

"order by var_pop() on columns of table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_var_pop_order_by {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: order_by
}

"order by var_samp() on columns of table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_var_samp_order_by {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: order_by
}

"order by variance() on columns of table \"service_calendar.day_type_active_on_day_of_week\""
input timetables_service_calendar_day_type_active_on_day_of_week_variance_order_by {
  "ISO week day definition (1 = Monday, 7 = Sunday)"
  day_of_week: order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input timetables_service_calendar_day_type_append_input {
  "Human-readable name for the DAY TYPE"
  name_i18n: jsonb
}

"Boolean expression to filter rows from the table \"service_calendar.day_type\". All fields are combined with a logical 'AND'."
input timetables_service_calendar_day_type_bool_exp {
  _and: [timetables_service_calendar_day_type_bool_exp!]
  _not: timetables_service_calendar_day_type_bool_exp
  _or: [timetables_service_calendar_day_type_bool_exp!]
  active_on_days_of_week: timetables_service_calendar_day_type_active_on_day_of_week_bool_exp
  active_on_days_of_week_aggregate: service_calendar_day_type_active_on_day_of_week_aggregate_bool_exp
  day_type_id: uuid_comparison_exp
  label: String_comparison_exp
  name_i18n: jsonb_comparison_exp
  vehicle_services: timetables_vehicle_service_vehicle_service_bool_exp
  vehicle_services_aggregate: vehicle_service_vehicle_service_aggregate_bool_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input timetables_service_calendar_day_type_delete_at_path_input {
  "Human-readable name for the DAY TYPE"
  name_i18n: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input timetables_service_calendar_day_type_delete_elem_input {
  "Human-readable name for the DAY TYPE"
  name_i18n: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input timetables_service_calendar_day_type_delete_key_input {
  "Human-readable name for the DAY TYPE"
  name_i18n: String
}

"input type for inserting data into table \"service_calendar.day_type\""
input timetables_service_calendar_day_type_insert_input {
  active_on_days_of_week: timetables_service_calendar_day_type_active_on_day_of_week_arr_rel_insert_input
  day_type_id: uuid
  "The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. \"Monday-Thursday\") and special (\"Easter Sunday\") day types"
  label: String
  "Human-readable name for the DAY TYPE"
  name_i18n: jsonb
  vehicle_services: timetables_vehicle_service_vehicle_service_arr_rel_insert_input
}

"input type for inserting object relation for remote table \"service_calendar.day_type\""
input timetables_service_calendar_day_type_obj_rel_insert_input {
  data: timetables_service_calendar_day_type_insert_input!
  "upsert condition"
  on_conflict: timetables_service_calendar_day_type_on_conflict
}

"on_conflict condition type for table \"service_calendar.day_type\""
input timetables_service_calendar_day_type_on_conflict {
  constraint: timetables_service_calendar_day_type_constraint!
  update_columns: [timetables_service_calendar_day_type_update_column!]! = []
  where: timetables_service_calendar_day_type_bool_exp
}

"Ordering options when selecting data from \"service_calendar.day_type\"."
input timetables_service_calendar_day_type_order_by {
  active_on_days_of_week_aggregate: timetables_service_calendar_day_type_active_on_day_of_week_aggregate_order_by
  day_type_id: order_by
  label: order_by
  name_i18n: order_by
  vehicle_services_aggregate: timetables_vehicle_service_vehicle_service_aggregate_order_by
}

"primary key columns input for table: service_calendar.day_type"
input timetables_service_calendar_day_type_pk_columns_input {
  day_type_id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input timetables_service_calendar_day_type_prepend_input {
  "Human-readable name for the DAY TYPE"
  name_i18n: jsonb
}

"input type for updating data in table \"service_calendar.day_type\""
input timetables_service_calendar_day_type_set_input {
  day_type_id: uuid
  "The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. \"Monday-Thursday\") and special (\"Easter Sunday\") day types"
  label: String
  "Human-readable name for the DAY TYPE"
  name_i18n: jsonb
}

"Streaming cursor of the table \"service_calendar_day_type\""
input timetables_service_calendar_day_type_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_service_calendar_day_type_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_service_calendar_day_type_stream_cursor_value_input {
  day_type_id: uuid
  "The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. \"Monday-Thursday\") and special (\"Easter Sunday\") day types"
  label: String
  "Human-readable name for the DAY TYPE"
  name_i18n: jsonb
}

input timetables_service_calendar_day_type_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: timetables_service_calendar_day_type_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: timetables_service_calendar_day_type_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: timetables_service_calendar_day_type_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: timetables_service_calendar_day_type_delete_key_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: timetables_service_calendar_day_type_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: timetables_service_calendar_day_type_set_input
  "filter the rows which have to be updated"
  where: timetables_service_calendar_day_type_bool_exp!
}

input timetables_service_calendar_get_active_day_types_for_date_args {
  observation_date: date
}

"order by aggregate values of table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_aggregate_order_by {
  avg: timetables_service_calendar_substitute_operating_day_by_line_type_avg_order_by
  count: order_by
  max: timetables_service_calendar_substitute_operating_day_by_line_type_max_order_by
  min: timetables_service_calendar_substitute_operating_day_by_line_type_min_order_by
  stddev: timetables_service_calendar_substitute_operating_day_by_line_type_stddev_order_by
  stddev_pop: timetables_service_calendar_substitute_operating_day_by_line_type_stddev_pop_order_by
  stddev_samp: timetables_service_calendar_substitute_operating_day_by_line_type_stddev_samp_order_by
  sum: timetables_service_calendar_substitute_operating_day_by_line_type_sum_order_by
  var_pop: timetables_service_calendar_substitute_operating_day_by_line_type_var_pop_order_by
  var_samp: timetables_service_calendar_substitute_operating_day_by_line_type_var_samp_order_by
  variance: timetables_service_calendar_substitute_operating_day_by_line_type_variance_order_by
}

"input type for inserting array relation for remote table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_arr_rel_insert_input {
  data: [timetables_service_calendar_substitute_operating_day_by_line_type_insert_input!]!
  "upsert condition"
  on_conflict: timetables_service_calendar_substitute_operating_day_by_line_type_on_conflict
}

"order by avg() on columns of table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_avg_order_by {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: order_by
}

"Boolean expression to filter rows from the table \"service_calendar.substitute_operating_day_by_line_type\". All fields are combined with a logical 'AND'."
input timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp {
  _and: [timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp!]
  _not: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp
  _or: [timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp!]
  begin_datetime: timestamptz_comparison_exp
  begin_time: interval_comparison_exp
  created_at: timestamptz_comparison_exp
  end_datetime: timestamptz_comparison_exp
  end_time: interval_comparison_exp
  substitute_day_of_week: Int_comparison_exp
  substitute_operating_day_by_line_type_id: uuid_comparison_exp
  substitute_operating_period_id: uuid_comparison_exp
  superseded_date: date_comparison_exp
  timezone: String_comparison_exp
  type_of_line: String_comparison_exp
}

"input type for incrementing numeric columns in table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_inc_input {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Int
}

"input type for inserting data into table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_insert_input {
  "The time from which the substituting public transit comes into effect. If NULL, the substitution is in effect from the start of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys prior to this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys before this time are operated as usual."
  begin_time: interval
  created_at: timestamptz
  "The time (exclusive) until which the substituting public transit is valid. If NULL, the substitution is in effect until the end of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys starting from this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys starting from this time are operated as usual."
  end_time: interval
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Int
  substitute_operating_day_by_line_type_id: uuid
  "The id of the substitute operating period"
  substitute_operating_period_id: uuid
  "The date of operating day being superseded."
  superseded_date: date
  timezone: String
  "The type of line this substitute operating day is bound to."
  type_of_line: String
}

"order by max() on columns of table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_max_order_by {
  "Calculated timestamp for the instant from which the substituting public transit comes into effect."
  begin_datetime: order_by
  created_at: order_by
  "Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect."
  end_datetime: order_by
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: order_by
  substitute_operating_day_by_line_type_id: order_by
  "The id of the substitute operating period"
  substitute_operating_period_id: order_by
  "The date of operating day being superseded."
  superseded_date: order_by
  timezone: order_by
  "The type of line this substitute operating day is bound to."
  type_of_line: order_by
}

"order by min() on columns of table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_min_order_by {
  "Calculated timestamp for the instant from which the substituting public transit comes into effect."
  begin_datetime: order_by
  created_at: order_by
  "Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect."
  end_datetime: order_by
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: order_by
  substitute_operating_day_by_line_type_id: order_by
  "The id of the substitute operating period"
  substitute_operating_period_id: order_by
  "The date of operating day being superseded."
  superseded_date: order_by
  timezone: order_by
  "The type of line this substitute operating day is bound to."
  type_of_line: order_by
}

"input type for inserting object relation for remote table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_obj_rel_insert_input {
  data: timetables_service_calendar_substitute_operating_day_by_line_type_insert_input!
  "upsert condition"
  on_conflict: timetables_service_calendar_substitute_operating_day_by_line_type_on_conflict
}

"on_conflict condition type for table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_on_conflict {
  constraint: timetables_service_calendar_substitute_operating_day_by_line_type_constraint!
  update_columns: [timetables_service_calendar_substitute_operating_day_by_line_type_update_column!]! = []
  where: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp
}

"Ordering options when selecting data from \"service_calendar.substitute_operating_day_by_line_type\"."
input timetables_service_calendar_substitute_operating_day_by_line_type_order_by {
  begin_datetime: order_by
  begin_time: order_by
  created_at: order_by
  end_datetime: order_by
  end_time: order_by
  substitute_day_of_week: order_by
  substitute_operating_day_by_line_type_id: order_by
  substitute_operating_period_id: order_by
  superseded_date: order_by
  timezone: order_by
  type_of_line: order_by
}

"primary key columns input for table: service_calendar.substitute_operating_day_by_line_type"
input timetables_service_calendar_substitute_operating_day_by_line_type_pk_columns_input {
  substitute_operating_day_by_line_type_id: uuid!
}

"input type for updating data in table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_set_input {
  "The time from which the substituting public transit comes into effect. If NULL, the substitution is in effect from the start of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys prior to this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys before this time are operated as usual."
  begin_time: interval
  created_at: timestamptz
  "The time (exclusive) until which the substituting public transit is valid. If NULL, the substitution is in effect until the end of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys starting from this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys starting from this time are operated as usual."
  end_time: interval
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Int
  substitute_operating_day_by_line_type_id: uuid
  "The id of the substitute operating period"
  substitute_operating_period_id: uuid
  "The date of operating day being superseded."
  superseded_date: date
  timezone: String
  "The type of line this substitute operating day is bound to."
  type_of_line: String
}

"order by stddev() on columns of table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_stddev_order_by {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: order_by
}

"order by stddev_pop() on columns of table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_stddev_pop_order_by {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: order_by
}

"order by stddev_samp() on columns of table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_stddev_samp_order_by {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: order_by
}

"Streaming cursor of the table \"service_calendar_substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_service_calendar_substitute_operating_day_by_line_type_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_service_calendar_substitute_operating_day_by_line_type_stream_cursor_value_input {
  "Calculated timestamp for the instant from which the substituting public transit comes into effect."
  begin_datetime: timestamptz
  "The time from which the substituting public transit comes into effect. If NULL, the substitution is in effect from the start of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys prior to this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys before this time are operated as usual."
  begin_time: interval
  created_at: timestamptz
  "Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect."
  end_datetime: timestamptz
  "The time (exclusive) until which the substituting public transit is valid. If NULL, the substitution is in effect until the end of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys starting from this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys starting from this time are operated as usual."
  end_time: interval
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: Int
  substitute_operating_day_by_line_type_id: uuid
  "The id of the substitute operating period"
  substitute_operating_period_id: uuid
  "The date of operating day being superseded."
  superseded_date: date
  timezone: String
  "The type of line this substitute operating day is bound to."
  type_of_line: String
}

"order by sum() on columns of table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_sum_order_by {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: order_by
}

input timetables_service_calendar_substitute_operating_day_by_line_type_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: timetables_service_calendar_substitute_operating_day_by_line_type_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: timetables_service_calendar_substitute_operating_day_by_line_type_set_input
  "filter the rows which have to be updated"
  where: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp!
}

"order by var_pop() on columns of table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_var_pop_order_by {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: order_by
}

"order by var_samp() on columns of table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_var_samp_order_by {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: order_by
}

"order by variance() on columns of table \"service_calendar.substitute_operating_day_by_line_type\""
input timetables_service_calendar_substitute_operating_day_by_line_type_variance_order_by {
  "The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period."
  substitute_day_of_week: order_by
}

"Boolean expression to filter rows from the table \"service_calendar.substitute_operating_period\". All fields are combined with a logical 'AND'."
input timetables_service_calendar_substitute_operating_period_bool_exp {
  _and: [timetables_service_calendar_substitute_operating_period_bool_exp!]
  _not: timetables_service_calendar_substitute_operating_period_bool_exp
  _or: [timetables_service_calendar_substitute_operating_period_bool_exp!]
  is_preset: Boolean_comparison_exp
  period_name: String_comparison_exp
  substitute_operating_day_by_line_types: timetables_service_calendar_substitute_operating_day_by_line_type_bool_exp
  substitute_operating_day_by_line_types_aggregate: service_calendar_substitute_operating_day_by_line_type_aggregate_bool_exp
  substitute_operating_period_id: uuid_comparison_exp
}

"input type for inserting data into table \"service_calendar.substitute_operating_period\""
input timetables_service_calendar_substitute_operating_period_insert_input {
  "Flag indicating whether operating period is preset or not. Preset operating periods have restrictions on the UI"
  is_preset: Boolean
  "Substitute operating period's name"
  period_name: String
  substitute_operating_day_by_line_types: timetables_service_calendar_substitute_operating_day_by_line_type_arr_rel_insert_input
  substitute_operating_period_id: uuid
}

"on_conflict condition type for table \"service_calendar.substitute_operating_period\""
input timetables_service_calendar_substitute_operating_period_on_conflict {
  constraint: timetables_service_calendar_substitute_operating_period_constraint!
  update_columns: [timetables_service_calendar_substitute_operating_period_update_column!]! = []
  where: timetables_service_calendar_substitute_operating_period_bool_exp
}

"Ordering options when selecting data from \"service_calendar.substitute_operating_period\"."
input timetables_service_calendar_substitute_operating_period_order_by {
  is_preset: order_by
  period_name: order_by
  substitute_operating_day_by_line_types_aggregate: timetables_service_calendar_substitute_operating_day_by_line_type_aggregate_order_by
  substitute_operating_period_id: order_by
}

"primary key columns input for table: service_calendar.substitute_operating_period"
input timetables_service_calendar_substitute_operating_period_pk_columns_input {
  substitute_operating_period_id: uuid!
}

"input type for updating data in table \"service_calendar.substitute_operating_period\""
input timetables_service_calendar_substitute_operating_period_set_input {
  "Flag indicating whether operating period is preset or not. Preset operating periods have restrictions on the UI"
  is_preset: Boolean
  "Substitute operating period's name"
  period_name: String
  substitute_operating_period_id: uuid
}

"Streaming cursor of the table \"service_calendar_substitute_operating_period\""
input timetables_service_calendar_substitute_operating_period_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_service_calendar_substitute_operating_period_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_service_calendar_substitute_operating_period_stream_cursor_value_input {
  "Flag indicating whether operating period is preset or not. Preset operating periods have restrictions on the UI"
  is_preset: Boolean
  "Substitute operating period's name"
  period_name: String
  substitute_operating_period_id: uuid
}

input timetables_service_calendar_substitute_operating_period_updates {
  "sets the columns of the filtered rows to the given values"
  _set: timetables_service_calendar_substitute_operating_period_set_input
  "filter the rows which have to be updated"
  where: timetables_service_calendar_substitute_operating_period_bool_exp!
}

"order by aggregate values of table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate_order_by {
  avg: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_avg_order_by
  count: order_by
  max: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_max_order_by
  min: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_min_order_by
  stddev: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_order_by
  stddev_pop: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_pop_order_by
  stddev_samp: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_samp_order_by
  sum: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_sum_order_by
  var_pop: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_var_pop_order_by
  var_samp: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_var_samp_order_by
  variance: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_variance_order_by
}

"input type for inserting array relation for remote table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_arr_rel_insert_input {
  data: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_insert_input!]!
  "upsert condition"
  on_conflict: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_on_conflict
}

"order by avg() on columns of table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_avg_order_by {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: order_by
}

"Boolean expression to filter rows from the table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\". All fields are combined with a logical 'AND'."
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp {
  _and: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp!]
  _not: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp
  _or: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp!]
  journey_pattern_ref: timetables_journey_pattern_journey_pattern_ref_bool_exp
  journey_pattern_ref_id: uuid_comparison_exp
  scheduled_stop_point_in_journey_pattern_ref_id: uuid_comparison_exp
  scheduled_stop_point_label: String_comparison_exp
  scheduled_stop_point_sequence: Int_comparison_exp
  timetabled_passing_times: timetables_passing_times_timetabled_passing_time_bool_exp
  timetabled_passing_times_aggregate: passing_times_timetabled_passing_time_aggregate_bool_exp
  timing_place_label: String_comparison_exp
}

"input type for incrementing numeric columns in table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_inc_input {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Int
}

"input type for inserting data into table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_insert_input {
  journey_pattern_ref: timetables_journey_pattern_journey_pattern_ref_obj_rel_insert_input
  "JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs"
  journey_pattern_ref_id: uuid
  scheduled_stop_point_in_journey_pattern_ref_id: uuid
  "The label of the SCHEDULED STOP POINT"
  scheduled_stop_point_label: String
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Int
  timetabled_passing_times: timetables_passing_times_timetabled_passing_time_arr_rel_insert_input
  "The label of the timing place associated with the referenced scheduled stop point in journey pattern"
  timing_place_label: String
}

"order by max() on columns of table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_max_order_by {
  "JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs"
  journey_pattern_ref_id: order_by
  scheduled_stop_point_in_journey_pattern_ref_id: order_by
  "The label of the SCHEDULED STOP POINT"
  scheduled_stop_point_label: order_by
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: order_by
  "The label of the timing place associated with the referenced scheduled stop point in journey pattern"
  timing_place_label: order_by
}

"order by min() on columns of table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_min_order_by {
  "JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs"
  journey_pattern_ref_id: order_by
  scheduled_stop_point_in_journey_pattern_ref_id: order_by
  "The label of the SCHEDULED STOP POINT"
  scheduled_stop_point_label: order_by
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: order_by
  "The label of the timing place associated with the referenced scheduled stop point in journey pattern"
  timing_place_label: order_by
}

"input type for inserting object relation for remote table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_obj_rel_insert_input {
  data: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_insert_input!
  "upsert condition"
  on_conflict: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_on_conflict
}

"on_conflict condition type for table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_on_conflict {
  constraint: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_constraint!
  update_columns: [timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_update_column!]! = []
  where: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp
}

"Ordering options when selecting data from \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\"."
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_order_by {
  journey_pattern_ref: timetables_journey_pattern_journey_pattern_ref_order_by
  journey_pattern_ref_id: order_by
  scheduled_stop_point_in_journey_pattern_ref_id: order_by
  scheduled_stop_point_label: order_by
  scheduled_stop_point_sequence: order_by
  timetabled_passing_times_aggregate: timetables_passing_times_timetabled_passing_time_aggregate_order_by
  timing_place_label: order_by
}

"primary key columns input for table: service_pattern.scheduled_stop_point_in_journey_pattern_ref"
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_pk_columns_input {
  scheduled_stop_point_in_journey_pattern_ref_id: uuid!
}

"input type for updating data in table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_set_input {
  "JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs"
  journey_pattern_ref_id: uuid
  scheduled_stop_point_in_journey_pattern_ref_id: uuid
  "The label of the SCHEDULED STOP POINT"
  scheduled_stop_point_label: String
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Int
  "The label of the timing place associated with the referenced scheduled stop point in journey pattern"
  timing_place_label: String
}

"order by stddev() on columns of table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_order_by {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: order_by
}

"order by stddev_pop() on columns of table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_pop_order_by {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: order_by
}

"order by stddev_samp() on columns of table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_samp_order_by {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: order_by
}

"Streaming cursor of the table \"service_pattern_scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stream_cursor_value_input {
  "JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs"
  journey_pattern_ref_id: uuid
  scheduled_stop_point_in_journey_pattern_ref_id: uuid
  "The label of the SCHEDULED STOP POINT"
  scheduled_stop_point_label: String
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: Int
  "The label of the timing place associated with the referenced scheduled stop point in journey pattern"
  timing_place_label: String
}

"order by sum() on columns of table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_sum_order_by {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: order_by
}

input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_set_input
  "filter the rows which have to be updated"
  where: timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_bool_exp!
}

"order by var_pop() on columns of table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_var_pop_order_by {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: order_by
}

"order by var_samp() on columns of table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_var_samp_order_by {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: order_by
}

"order by variance() on columns of table \"service_pattern.scheduled_stop_point_in_journey_pattern_ref\""
input timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_variance_order_by {
  "The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN."
  scheduled_stop_point_sequence: order_by
}

input timetables_vehicle_journey_get_vehicle_schedules_on_date_args {
  journey_pattern_uuid: uuid
  observation_date: date
}

"order by aggregate values of table \"vehicle_journey.vehicle_journey\""
input timetables_vehicle_journey_vehicle_journey_aggregate_order_by {
  count: order_by
  max: timetables_vehicle_journey_vehicle_journey_max_order_by
  min: timetables_vehicle_journey_vehicle_journey_min_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input timetables_vehicle_journey_vehicle_journey_append_input {
  "Name that user can give to the vehicle journey."
  journey_name_i18n: jsonb
}

"input type for inserting array relation for remote table \"vehicle_journey.vehicle_journey\""
input timetables_vehicle_journey_vehicle_journey_arr_rel_insert_input {
  data: [timetables_vehicle_journey_vehicle_journey_insert_input!]!
  "upsert condition"
  on_conflict: timetables_vehicle_journey_vehicle_journey_on_conflict
}

"Boolean expression to filter rows from the table \"vehicle_journey.vehicle_journey\". All fields are combined with a logical 'AND'."
input timetables_vehicle_journey_vehicle_journey_bool_exp {
  _and: [timetables_vehicle_journey_vehicle_journey_bool_exp!]
  _not: timetables_vehicle_journey_vehicle_journey_bool_exp
  _or: [timetables_vehicle_journey_vehicle_journey_bool_exp!]
  block: timetables_vehicle_service_block_bool_exp
  block_id: uuid_comparison_exp
  contract_number: String_comparison_exp
  displayed_name: String_comparison_exp
  end_time: String_comparison_exp
  is_backup_journey: Boolean_comparison_exp
  is_extra_journey: Boolean_comparison_exp
  is_vehicle_type_mandatory: Boolean_comparison_exp
  journey_name_i18n: jsonb_comparison_exp
  journey_pattern_ref: timetables_journey_pattern_journey_pattern_ref_bool_exp
  journey_pattern_ref_id: uuid_comparison_exp
  journey_type: String_comparison_exp
  layover_time: interval_comparison_exp
  start_time: String_comparison_exp
  timetabled_passing_times: timetables_passing_times_timetabled_passing_time_bool_exp
  timetabled_passing_times_aggregate: passing_times_timetabled_passing_time_aggregate_bool_exp
  turnaround_time: interval_comparison_exp
  vehicle_journey_id: uuid_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input timetables_vehicle_journey_vehicle_journey_delete_at_path_input {
  "Name that user can give to the vehicle journey."
  journey_name_i18n: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input timetables_vehicle_journey_vehicle_journey_delete_elem_input {
  "Name that user can give to the vehicle journey."
  journey_name_i18n: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input timetables_vehicle_journey_vehicle_journey_delete_key_input {
  "Name that user can give to the vehicle journey."
  journey_name_i18n: String
}

"input type for inserting data into table \"vehicle_journey.vehicle_journey\""
input timetables_vehicle_journey_vehicle_journey_insert_input {
  block: timetables_vehicle_service_block_obj_rel_insert_input
  "The BLOCK to which this VEHICLE JOURNEY belongs"
  block_id: uuid
  "The contract number for this vehicle journey."
  contract_number: String
  "Displayed name of the journey."
  displayed_name: String
  "Is the journey a backup journey."
  is_backup_journey: Boolean
  "Is the journey an extra journey."
  is_extra_journey: Boolean
  "It is required to use the same vehicle type as required in vehicle service."
  is_vehicle_type_mandatory: Boolean
  "Name that user can give to the vehicle journey."
  journey_name_i18n: jsonb
  journey_pattern_ref: timetables_journey_pattern_journey_pattern_ref_obj_rel_insert_input
  "The JOURNEY PATTERN on which the VEHICLE JOURNEY travels"
  journey_pattern_ref_id: uuid
  "STANDARD | DRY_RUN | SERVICE_JOURNEY"
  journey_type: String
  "LAYOVER TIMEs describe a certain time allowance that may be given at the end of each VEHICLE JOURNEY, before starting the next one, to compensate delays or for other purposes (e.g. rest time for the driver). This layover time can be regarded as a buffer time, which may or may not be actually consumed in real time operation."
  layover_time: interval
  timetabled_passing_times: timetables_passing_times_timetabled_passing_time_arr_rel_insert_input
  "Turnaround time is the time taken by a vehicle to proceed from the end of a ROUTE to the start of another."
  turnaround_time: interval
  vehicle_journey_id: uuid
}

"order by max() on columns of table \"vehicle_journey.vehicle_journey\""
input timetables_vehicle_journey_vehicle_journey_max_order_by {
  "The BLOCK to which this VEHICLE JOURNEY belongs"
  block_id: order_by
  "The contract number for this vehicle journey."
  contract_number: order_by
  "Displayed name of the journey."
  displayed_name: order_by
  "The JOURNEY PATTERN on which the VEHICLE JOURNEY travels"
  journey_pattern_ref_id: order_by
  "STANDARD | DRY_RUN | SERVICE_JOURNEY"
  journey_type: order_by
  vehicle_journey_id: order_by
}

"order by min() on columns of table \"vehicle_journey.vehicle_journey\""
input timetables_vehicle_journey_vehicle_journey_min_order_by {
  "The BLOCK to which this VEHICLE JOURNEY belongs"
  block_id: order_by
  "The contract number for this vehicle journey."
  contract_number: order_by
  "Displayed name of the journey."
  displayed_name: order_by
  "The JOURNEY PATTERN on which the VEHICLE JOURNEY travels"
  journey_pattern_ref_id: order_by
  "STANDARD | DRY_RUN | SERVICE_JOURNEY"
  journey_type: order_by
  vehicle_journey_id: order_by
}

"input type for inserting object relation for remote table \"vehicle_journey.vehicle_journey\""
input timetables_vehicle_journey_vehicle_journey_obj_rel_insert_input {
  data: timetables_vehicle_journey_vehicle_journey_insert_input!
  "upsert condition"
  on_conflict: timetables_vehicle_journey_vehicle_journey_on_conflict
}

"on_conflict condition type for table \"vehicle_journey.vehicle_journey\""
input timetables_vehicle_journey_vehicle_journey_on_conflict {
  constraint: timetables_vehicle_journey_vehicle_journey_constraint!
  update_columns: [timetables_vehicle_journey_vehicle_journey_update_column!]! = []
  where: timetables_vehicle_journey_vehicle_journey_bool_exp
}

"Ordering options when selecting data from \"vehicle_journey.vehicle_journey\"."
input timetables_vehicle_journey_vehicle_journey_order_by {
  block: timetables_vehicle_service_block_order_by
  block_id: order_by
  contract_number: order_by
  displayed_name: order_by
  end_time: order_by
  is_backup_journey: order_by
  is_extra_journey: order_by
  is_vehicle_type_mandatory: order_by
  journey_name_i18n: order_by
  journey_pattern_ref: timetables_journey_pattern_journey_pattern_ref_order_by
  journey_pattern_ref_id: order_by
  journey_type: order_by
  layover_time: order_by
  start_time: order_by
  timetabled_passing_times_aggregate: timetables_passing_times_timetabled_passing_time_aggregate_order_by
  turnaround_time: order_by
  vehicle_journey_id: order_by
}

"primary key columns input for table: vehicle_journey.vehicle_journey"
input timetables_vehicle_journey_vehicle_journey_pk_columns_input {
  vehicle_journey_id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input timetables_vehicle_journey_vehicle_journey_prepend_input {
  "Name that user can give to the vehicle journey."
  journey_name_i18n: jsonb
}

"input type for updating data in table \"vehicle_journey.vehicle_journey\""
input timetables_vehicle_journey_vehicle_journey_set_input {
  "The BLOCK to which this VEHICLE JOURNEY belongs"
  block_id: uuid
  "The contract number for this vehicle journey."
  contract_number: String
  "Displayed name of the journey."
  displayed_name: String
  "Is the journey a backup journey."
  is_backup_journey: Boolean
  "Is the journey an extra journey."
  is_extra_journey: Boolean
  "It is required to use the same vehicle type as required in vehicle service."
  is_vehicle_type_mandatory: Boolean
  "Name that user can give to the vehicle journey."
  journey_name_i18n: jsonb
  "The JOURNEY PATTERN on which the VEHICLE JOURNEY travels"
  journey_pattern_ref_id: uuid
  "STANDARD | DRY_RUN | SERVICE_JOURNEY"
  journey_type: String
  "LAYOVER TIMEs describe a certain time allowance that may be given at the end of each VEHICLE JOURNEY, before starting the next one, to compensate delays or for other purposes (e.g. rest time for the driver). This layover time can be regarded as a buffer time, which may or may not be actually consumed in real time operation."
  layover_time: interval
  "Turnaround time is the time taken by a vehicle to proceed from the end of a ROUTE to the start of another."
  turnaround_time: interval
  vehicle_journey_id: uuid
}

"Streaming cursor of the table \"vehicle_journey_vehicle_journey\""
input timetables_vehicle_journey_vehicle_journey_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_vehicle_journey_vehicle_journey_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_vehicle_journey_vehicle_journey_stream_cursor_value_input {
  "The BLOCK to which this VEHICLE JOURNEY belongs"
  block_id: uuid
  "The contract number for this vehicle journey."
  contract_number: String
  "Displayed name of the journey."
  displayed_name: String
  "Is the journey a backup journey."
  is_backup_journey: Boolean
  "Is the journey an extra journey."
  is_extra_journey: Boolean
  "It is required to use the same vehicle type as required in vehicle service."
  is_vehicle_type_mandatory: Boolean
  "Name that user can give to the vehicle journey."
  journey_name_i18n: jsonb
  "The JOURNEY PATTERN on which the VEHICLE JOURNEY travels"
  journey_pattern_ref_id: uuid
  "STANDARD | DRY_RUN | SERVICE_JOURNEY"
  journey_type: String
  "LAYOVER TIMEs describe a certain time allowance that may be given at the end of each VEHICLE JOURNEY, before starting the next one, to compensate delays or for other purposes (e.g. rest time for the driver). This layover time can be regarded as a buffer time, which may or may not be actually consumed in real time operation."
  layover_time: interval
  "Turnaround time is the time taken by a vehicle to proceed from the end of a ROUTE to the start of another."
  turnaround_time: interval
  vehicle_journey_id: uuid
}

input timetables_vehicle_journey_vehicle_journey_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: timetables_vehicle_journey_vehicle_journey_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: timetables_vehicle_journey_vehicle_journey_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: timetables_vehicle_journey_vehicle_journey_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: timetables_vehicle_journey_vehicle_journey_delete_key_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: timetables_vehicle_journey_vehicle_journey_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: timetables_vehicle_journey_vehicle_journey_set_input
  "filter the rows which have to be updated"
  where: timetables_vehicle_journey_vehicle_journey_bool_exp!
}

"append existing jsonb value of filtered columns with new jsonb value"
input timetables_vehicle_schedule_vehicle_schedule_frame_append_input {
  "Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus."
  booking_description_i18n: jsonb
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  name_i18n: jsonb
}

"Boolean expression to filter rows from the table \"vehicle_schedule.vehicle_schedule_frame\". All fields are combined with a logical 'AND'."
input timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp {
  _and: [timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp!]
  _not: timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp
  _or: [timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp!]
  booking_description_i18n: jsonb_comparison_exp
  booking_label: String_comparison_exp
  created_at: timestamptz_comparison_exp
  label: String_comparison_exp
  name_i18n: jsonb_comparison_exp
  priority: Int_comparison_exp
  validity_end: date_comparison_exp
  validity_range: daterange_comparison_exp
  validity_start: date_comparison_exp
  vehicle_schedule_frame_id: uuid_comparison_exp
  vehicle_services: timetables_vehicle_service_vehicle_service_bool_exp
  vehicle_services_aggregate: vehicle_service_vehicle_service_aggregate_bool_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input timetables_vehicle_schedule_vehicle_schedule_frame_delete_at_path_input {
  "Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus."
  booking_description_i18n: [String!]
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  name_i18n: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input timetables_vehicle_schedule_vehicle_schedule_frame_delete_elem_input {
  "Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus."
  booking_description_i18n: Int
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  name_i18n: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input timetables_vehicle_schedule_vehicle_schedule_frame_delete_key_input {
  "Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus."
  booking_description_i18n: String
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  name_i18n: String
}

"input type for incrementing numeric columns in table \"vehicle_schedule.vehicle_schedule_frame\""
input timetables_vehicle_schedule_vehicle_schedule_frame_inc_input {
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Int
}

"input type for inserting data into table \"vehicle_schedule.vehicle_schedule_frame\""
input timetables_vehicle_schedule_vehicle_schedule_frame_insert_input {
  "Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus."
  booking_description_i18n: jsonb
  "Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus."
  booking_label: String
  created_at: timestamptz
  "Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus."
  label: String
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  name_i18n: jsonb
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid."
  validity_end: date
  "OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid."
  validity_start: date
  vehicle_schedule_frame_id: uuid
  vehicle_services: timetables_vehicle_service_vehicle_service_arr_rel_insert_input
}

"input type for inserting object relation for remote table \"vehicle_schedule.vehicle_schedule_frame\""
input timetables_vehicle_schedule_vehicle_schedule_frame_obj_rel_insert_input {
  data: timetables_vehicle_schedule_vehicle_schedule_frame_insert_input!
  "upsert condition"
  on_conflict: timetables_vehicle_schedule_vehicle_schedule_frame_on_conflict
}

"on_conflict condition type for table \"vehicle_schedule.vehicle_schedule_frame\""
input timetables_vehicle_schedule_vehicle_schedule_frame_on_conflict {
  constraint: timetables_vehicle_schedule_vehicle_schedule_frame_constraint!
  update_columns: [timetables_vehicle_schedule_vehicle_schedule_frame_update_column!]! = []
  where: timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp
}

"Ordering options when selecting data from \"vehicle_schedule.vehicle_schedule_frame\"."
input timetables_vehicle_schedule_vehicle_schedule_frame_order_by {
  booking_description_i18n: order_by
  booking_label: order_by
  created_at: order_by
  label: order_by
  name_i18n: order_by
  priority: order_by
  validity_end: order_by
  validity_range: order_by
  validity_start: order_by
  vehicle_schedule_frame_id: order_by
  vehicle_services_aggregate: timetables_vehicle_service_vehicle_service_aggregate_order_by
}

"primary key columns input for table: vehicle_schedule.vehicle_schedule_frame"
input timetables_vehicle_schedule_vehicle_schedule_frame_pk_columns_input {
  vehicle_schedule_frame_id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input timetables_vehicle_schedule_vehicle_schedule_frame_prepend_input {
  "Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus."
  booking_description_i18n: jsonb
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  name_i18n: jsonb
}

"input type for updating data in table \"vehicle_schedule.vehicle_schedule_frame\""
input timetables_vehicle_schedule_vehicle_schedule_frame_set_input {
  "Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus."
  booking_description_i18n: jsonb
  "Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus."
  booking_label: String
  created_at: timestamptz
  "Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus."
  label: String
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  name_i18n: jsonb
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid."
  validity_end: date
  "OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid."
  validity_start: date
  vehicle_schedule_frame_id: uuid
}

"Streaming cursor of the table \"vehicle_schedule_vehicle_schedule_frame\""
input timetables_vehicle_schedule_vehicle_schedule_frame_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_vehicle_schedule_vehicle_schedule_frame_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_vehicle_schedule_vehicle_schedule_frame_stream_cursor_value_input {
  "Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus."
  booking_description_i18n: jsonb
  "Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus."
  booking_label: String
  created_at: timestamptz
  "Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus."
  label: String
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  name_i18n: jsonb
  "The priority of the timetable definition. The definition may be overridden by higher priority definitions."
  priority: Int
  "OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid."
  validity_end: date
  """
  
  A denormalized column for actual daterange when vehicle schedule frame is valid,
  that is, a closed date range [validity_start, validity_end].
  Added to make working with PostgreSQL functions easier:
  they typically expect ranges to be half closed.
  """
  validity_range: daterange
  "OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid."
  validity_start: date
  vehicle_schedule_frame_id: uuid
}

input timetables_vehicle_schedule_vehicle_schedule_frame_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: timetables_vehicle_schedule_vehicle_schedule_frame_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: timetables_vehicle_schedule_vehicle_schedule_frame_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: timetables_vehicle_schedule_vehicle_schedule_frame_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: timetables_vehicle_schedule_vehicle_schedule_frame_delete_key_input
  "increments the numeric columns with given value of the filtered values"
  _inc: timetables_vehicle_schedule_vehicle_schedule_frame_inc_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: timetables_vehicle_schedule_vehicle_schedule_frame_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: timetables_vehicle_schedule_vehicle_schedule_frame_set_input
  "filter the rows which have to be updated"
  where: timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp!
}

"order by aggregate values of table \"vehicle_service.block\""
input timetables_vehicle_service_block_aggregate_order_by {
  count: order_by
  max: timetables_vehicle_service_block_max_order_by
  min: timetables_vehicle_service_block_min_order_by
}

"input type for inserting array relation for remote table \"vehicle_service.block\""
input timetables_vehicle_service_block_arr_rel_insert_input {
  data: [timetables_vehicle_service_block_insert_input!]!
  "upsert condition"
  on_conflict: timetables_vehicle_service_block_on_conflict
}

"Boolean expression to filter rows from the table \"vehicle_service.block\". All fields are combined with a logical 'AND'."
input timetables_vehicle_service_block_bool_exp {
  _and: [timetables_vehicle_service_block_bool_exp!]
  _not: timetables_vehicle_service_block_bool_exp
  _or: [timetables_vehicle_service_block_bool_exp!]
  block_id: uuid_comparison_exp
  finishing_time: interval_comparison_exp
  preparing_time: interval_comparison_exp
  vehicle_journeys: timetables_vehicle_journey_vehicle_journey_bool_exp
  vehicle_journeys_aggregate: vehicle_journey_vehicle_journey_aggregate_bool_exp
  vehicle_service: timetables_vehicle_service_vehicle_service_bool_exp
  vehicle_service_id: uuid_comparison_exp
  vehicle_type: timetables_vehicle_type_vehicle_type_bool_exp
  vehicle_type_id: uuid_comparison_exp
}

"input type for inserting data into table \"vehicle_service.block\""
input timetables_vehicle_service_block_insert_input {
  block_id: uuid
  "Finishing time after end of vehicle service block."
  finishing_time: interval
  "Preparation time before start of vehicle service block."
  preparing_time: interval
  vehicle_journeys: timetables_vehicle_journey_vehicle_journey_arr_rel_insert_input
  vehicle_service: timetables_vehicle_service_vehicle_service_obj_rel_insert_input
  "The VEHICLE SERVICE to which this BLOCK belongs."
  vehicle_service_id: uuid
  vehicle_type: timetables_vehicle_type_vehicle_type_obj_rel_insert_input
  "Reference to vehicle_type.vehicle_type."
  vehicle_type_id: uuid
}

"order by max() on columns of table \"vehicle_service.block\""
input timetables_vehicle_service_block_max_order_by {
  block_id: order_by
  "The VEHICLE SERVICE to which this BLOCK belongs."
  vehicle_service_id: order_by
  "Reference to vehicle_type.vehicle_type."
  vehicle_type_id: order_by
}

"order by min() on columns of table \"vehicle_service.block\""
input timetables_vehicle_service_block_min_order_by {
  block_id: order_by
  "The VEHICLE SERVICE to which this BLOCK belongs."
  vehicle_service_id: order_by
  "Reference to vehicle_type.vehicle_type."
  vehicle_type_id: order_by
}

"input type for inserting object relation for remote table \"vehicle_service.block\""
input timetables_vehicle_service_block_obj_rel_insert_input {
  data: timetables_vehicle_service_block_insert_input!
  "upsert condition"
  on_conflict: timetables_vehicle_service_block_on_conflict
}

"on_conflict condition type for table \"vehicle_service.block\""
input timetables_vehicle_service_block_on_conflict {
  constraint: timetables_vehicle_service_block_constraint!
  update_columns: [timetables_vehicle_service_block_update_column!]! = []
  where: timetables_vehicle_service_block_bool_exp
}

"Ordering options when selecting data from \"vehicle_service.block\"."
input timetables_vehicle_service_block_order_by {
  block_id: order_by
  finishing_time: order_by
  preparing_time: order_by
  vehicle_journeys_aggregate: timetables_vehicle_journey_vehicle_journey_aggregate_order_by
  vehicle_service: timetables_vehicle_service_vehicle_service_order_by
  vehicle_service_id: order_by
  vehicle_type: timetables_vehicle_type_vehicle_type_order_by
  vehicle_type_id: order_by
}

"primary key columns input for table: vehicle_service.block"
input timetables_vehicle_service_block_pk_columns_input {
  block_id: uuid!
}

"input type for updating data in table \"vehicle_service.block\""
input timetables_vehicle_service_block_set_input {
  block_id: uuid
  "Finishing time after end of vehicle service block."
  finishing_time: interval
  "Preparation time before start of vehicle service block."
  preparing_time: interval
  "The VEHICLE SERVICE to which this BLOCK belongs."
  vehicle_service_id: uuid
  "Reference to vehicle_type.vehicle_type."
  vehicle_type_id: uuid
}

"Streaming cursor of the table \"vehicle_service_block\""
input timetables_vehicle_service_block_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_vehicle_service_block_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_vehicle_service_block_stream_cursor_value_input {
  block_id: uuid
  "Finishing time after end of vehicle service block."
  finishing_time: interval
  "Preparation time before start of vehicle service block."
  preparing_time: interval
  "The VEHICLE SERVICE to which this BLOCK belongs."
  vehicle_service_id: uuid
  "Reference to vehicle_type.vehicle_type."
  vehicle_type_id: uuid
}

input timetables_vehicle_service_block_updates {
  "sets the columns of the filtered rows to the given values"
  _set: timetables_vehicle_service_block_set_input
  "filter the rows which have to be updated"
  where: timetables_vehicle_service_block_bool_exp!
}

input timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids_args {
  end_date: date
  journey_pattern_ids: _uuid
  observation_date: date
  start_date: date
}

input timetables_vehicle_service_get_timetables_and_substitute_operating_days_args {
  end_date: date
  journey_pattern_ids: _uuid
  start_date: date
}

"order by aggregate values of table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate_order_by {
  avg: timetables_vehicle_service_journey_patterns_in_vehicle_service_avg_order_by
  count: order_by
  max: timetables_vehicle_service_journey_patterns_in_vehicle_service_max_order_by
  min: timetables_vehicle_service_journey_patterns_in_vehicle_service_min_order_by
  stddev: timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_order_by
  stddev_pop: timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_pop_order_by
  stddev_samp: timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_samp_order_by
  sum: timetables_vehicle_service_journey_patterns_in_vehicle_service_sum_order_by
  var_pop: timetables_vehicle_service_journey_patterns_in_vehicle_service_var_pop_order_by
  var_samp: timetables_vehicle_service_journey_patterns_in_vehicle_service_var_samp_order_by
  variance: timetables_vehicle_service_journey_patterns_in_vehicle_service_variance_order_by
}

"input type for inserting array relation for remote table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_arr_rel_insert_input {
  data: [timetables_vehicle_service_journey_patterns_in_vehicle_service_insert_input!]!
  "upsert condition"
  on_conflict: timetables_vehicle_service_journey_patterns_in_vehicle_service_on_conflict
}

"order by avg() on columns of table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_avg_order_by {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: order_by
}

"Boolean expression to filter rows from the table \"vehicle_service.journey_patterns_in_vehicle_service\". All fields are combined with a logical 'AND'."
input timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp {
  _and: [timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp!]
  _not: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp
  _or: [timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp!]
  journey_pattern_id: uuid_comparison_exp
  reference_count: Int_comparison_exp
  vehicle_service: timetables_vehicle_service_vehicle_service_bool_exp
  vehicle_service_id: uuid_comparison_exp
}

"input type for incrementing numeric columns in table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_inc_input {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Int
}

"input type for inserting data into table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_insert_input {
  """
  The journey_pattern_id from journey_pattern.journey_pattern_ref.
   No foreign key reference is set because the target column is not unique.
  """
  journey_pattern_id: uuid
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Int
  vehicle_service: timetables_vehicle_service_vehicle_service_obj_rel_insert_input
  vehicle_service_id: uuid
}

"order by max() on columns of table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_max_order_by {
  """
  The journey_pattern_id from journey_pattern.journey_pattern_ref.
   No foreign key reference is set because the target column is not unique.
  """
  journey_pattern_id: order_by
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: order_by
  vehicle_service_id: order_by
}

"order by min() on columns of table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_min_order_by {
  """
  The journey_pattern_id from journey_pattern.journey_pattern_ref.
   No foreign key reference is set because the target column is not unique.
  """
  journey_pattern_id: order_by
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: order_by
  vehicle_service_id: order_by
}

"on_conflict condition type for table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_on_conflict {
  constraint: timetables_vehicle_service_journey_patterns_in_vehicle_service_constraint!
  update_columns: [timetables_vehicle_service_journey_patterns_in_vehicle_service_update_column!]! = []
  where: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp
}

"Ordering options when selecting data from \"vehicle_service.journey_patterns_in_vehicle_service\"."
input timetables_vehicle_service_journey_patterns_in_vehicle_service_order_by {
  journey_pattern_id: order_by
  reference_count: order_by
  vehicle_service: timetables_vehicle_service_vehicle_service_order_by
  vehicle_service_id: order_by
}

"primary key columns input for table: vehicle_service.journey_patterns_in_vehicle_service"
input timetables_vehicle_service_journey_patterns_in_vehicle_service_pk_columns_input {
  """
  The journey_pattern_id from journey_pattern.journey_pattern_ref.
   No foreign key reference is set because the target column is not unique.
  """
  journey_pattern_id: uuid!
  vehicle_service_id: uuid!
}

"input type for updating data in table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_set_input {
  """
  The journey_pattern_id from journey_pattern.journey_pattern_ref.
   No foreign key reference is set because the target column is not unique.
  """
  journey_pattern_id: uuid
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Int
  vehicle_service_id: uuid
}

"order by stddev() on columns of table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_order_by {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: order_by
}

"order by stddev_pop() on columns of table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_pop_order_by {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: order_by
}

"order by stddev_samp() on columns of table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_samp_order_by {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: order_by
}

"Streaming cursor of the table \"vehicle_service_journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_vehicle_service_journey_patterns_in_vehicle_service_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_vehicle_service_journey_patterns_in_vehicle_service_stream_cursor_value_input {
  """
  The journey_pattern_id from journey_pattern.journey_pattern_ref.
   No foreign key reference is set because the target column is not unique.
  """
  journey_pattern_id: uuid
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: Int
  vehicle_service_id: uuid
}

"order by sum() on columns of table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_sum_order_by {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: order_by
}

input timetables_vehicle_service_journey_patterns_in_vehicle_service_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: timetables_vehicle_service_journey_patterns_in_vehicle_service_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: timetables_vehicle_service_journey_patterns_in_vehicle_service_set_input
  "filter the rows which have to be updated"
  where: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp!
}

"order by var_pop() on columns of table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_var_pop_order_by {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: order_by
}

"order by var_samp() on columns of table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_var_samp_order_by {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: order_by
}

"order by variance() on columns of table \"vehicle_service.journey_patterns_in_vehicle_service\""
input timetables_vehicle_service_journey_patterns_in_vehicle_service_variance_order_by {
  """
  The amount of unique references between the journey_pattern and vehicle_service.
    When this reaches 0 the row will be deleted.
  """
  reference_count: order_by
}

"order by aggregate values of table \"vehicle_service.vehicle_service\""
input timetables_vehicle_service_vehicle_service_aggregate_order_by {
  count: order_by
  max: timetables_vehicle_service_vehicle_service_max_order_by
  min: timetables_vehicle_service_vehicle_service_min_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input timetables_vehicle_service_vehicle_service_append_input {
  "Name for vehicle service."
  name_i18n: jsonb
}

"input type for inserting array relation for remote table \"vehicle_service.vehicle_service\""
input timetables_vehicle_service_vehicle_service_arr_rel_insert_input {
  data: [timetables_vehicle_service_vehicle_service_insert_input!]!
  "upsert condition"
  on_conflict: timetables_vehicle_service_vehicle_service_on_conflict
}

"Boolean expression to filter rows from the table \"vehicle_service.vehicle_service\". All fields are combined with a logical 'AND'."
input timetables_vehicle_service_vehicle_service_bool_exp {
  _and: [timetables_vehicle_service_vehicle_service_bool_exp!]
  _not: timetables_vehicle_service_vehicle_service_bool_exp
  _or: [timetables_vehicle_service_vehicle_service_bool_exp!]
  blocks: timetables_vehicle_service_block_bool_exp
  blocks_aggregate: vehicle_service_block_aggregate_bool_exp
  day_type: timetables_service_calendar_day_type_bool_exp
  day_type_id: uuid_comparison_exp
  journey_patterns_in_vehicle_service: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp
  journey_patterns_in_vehicle_service_aggregate: vehicle_service_journey_patterns_in_vehicle_service_aggregate_bool_exp
  name_i18n: jsonb_comparison_exp
  vehicle_schedule_frame: timetables_vehicle_schedule_vehicle_schedule_frame_bool_exp
  vehicle_schedule_frame_id: uuid_comparison_exp
  vehicle_service_id: uuid_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input timetables_vehicle_service_vehicle_service_delete_at_path_input {
  "Name for vehicle service."
  name_i18n: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input timetables_vehicle_service_vehicle_service_delete_elem_input {
  "Name for vehicle service."
  name_i18n: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input timetables_vehicle_service_vehicle_service_delete_key_input {
  "Name for vehicle service."
  name_i18n: String
}

"input type for inserting data into table \"vehicle_service.vehicle_service\""
input timetables_vehicle_service_vehicle_service_insert_input {
  blocks: timetables_vehicle_service_block_arr_rel_insert_input
  day_type: timetables_service_calendar_day_type_obj_rel_insert_input
  "The DAY TYPE for the VEHICLE SERVICE."
  day_type_id: uuid
  journey_patterns_in_vehicle_service: timetables_vehicle_service_journey_patterns_in_vehicle_service_arr_rel_insert_input
  "Name for vehicle service."
  name_i18n: jsonb
  vehicle_schedule_frame: timetables_vehicle_schedule_vehicle_schedule_frame_obj_rel_insert_input
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  vehicle_schedule_frame_id: uuid
  vehicle_service_id: uuid
}

"order by max() on columns of table \"vehicle_service.vehicle_service\""
input timetables_vehicle_service_vehicle_service_max_order_by {
  "The DAY TYPE for the VEHICLE SERVICE."
  day_type_id: order_by
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  vehicle_schedule_frame_id: order_by
  vehicle_service_id: order_by
}

"order by min() on columns of table \"vehicle_service.vehicle_service\""
input timetables_vehicle_service_vehicle_service_min_order_by {
  "The DAY TYPE for the VEHICLE SERVICE."
  day_type_id: order_by
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  vehicle_schedule_frame_id: order_by
  vehicle_service_id: order_by
}

"input type for inserting object relation for remote table \"vehicle_service.vehicle_service\""
input timetables_vehicle_service_vehicle_service_obj_rel_insert_input {
  data: timetables_vehicle_service_vehicle_service_insert_input!
  "upsert condition"
  on_conflict: timetables_vehicle_service_vehicle_service_on_conflict
}

"on_conflict condition type for table \"vehicle_service.vehicle_service\""
input timetables_vehicle_service_vehicle_service_on_conflict {
  constraint: timetables_vehicle_service_vehicle_service_constraint!
  update_columns: [timetables_vehicle_service_vehicle_service_update_column!]! = []
  where: timetables_vehicle_service_vehicle_service_bool_exp
}

"Ordering options when selecting data from \"vehicle_service.vehicle_service\"."
input timetables_vehicle_service_vehicle_service_order_by {
  blocks_aggregate: timetables_vehicle_service_block_aggregate_order_by
  day_type: timetables_service_calendar_day_type_order_by
  day_type_id: order_by
  journey_patterns_in_vehicle_service_aggregate: timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate_order_by
  name_i18n: order_by
  vehicle_schedule_frame: timetables_vehicle_schedule_vehicle_schedule_frame_order_by
  vehicle_schedule_frame_id: order_by
  vehicle_service_id: order_by
}

"primary key columns input for table: vehicle_service.vehicle_service"
input timetables_vehicle_service_vehicle_service_pk_columns_input {
  vehicle_service_id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input timetables_vehicle_service_vehicle_service_prepend_input {
  "Name for vehicle service."
  name_i18n: jsonb
}

"input type for updating data in table \"vehicle_service.vehicle_service\""
input timetables_vehicle_service_vehicle_service_set_input {
  "The DAY TYPE for the VEHICLE SERVICE."
  day_type_id: uuid
  "Name for vehicle service."
  name_i18n: jsonb
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  vehicle_schedule_frame_id: uuid
  vehicle_service_id: uuid
}

"Streaming cursor of the table \"vehicle_service_vehicle_service\""
input timetables_vehicle_service_vehicle_service_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_vehicle_service_vehicle_service_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_vehicle_service_vehicle_service_stream_cursor_value_input {
  "The DAY TYPE for the VEHICLE SERVICE."
  day_type_id: uuid
  "Name for vehicle service."
  name_i18n: jsonb
  "Human-readable name for the VEHICLE SCHEDULE FRAME"
  vehicle_schedule_frame_id: uuid
  vehicle_service_id: uuid
}

input timetables_vehicle_service_vehicle_service_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: timetables_vehicle_service_vehicle_service_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: timetables_vehicle_service_vehicle_service_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: timetables_vehicle_service_vehicle_service_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: timetables_vehicle_service_vehicle_service_delete_key_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: timetables_vehicle_service_vehicle_service_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: timetables_vehicle_service_vehicle_service_set_input
  "filter the rows which have to be updated"
  where: timetables_vehicle_service_vehicle_service_bool_exp!
}

"append existing jsonb value of filtered columns with new jsonb value"
input timetables_vehicle_type_vehicle_type_append_input {
  "Description of the vehicle type."
  description_i18n: jsonb
}

"Boolean expression to filter rows from the table \"vehicle_type.vehicle_type\". All fields are combined with a logical 'AND'."
input timetables_vehicle_type_vehicle_type_bool_exp {
  _and: [timetables_vehicle_type_vehicle_type_bool_exp!]
  _not: timetables_vehicle_type_vehicle_type_bool_exp
  _or: [timetables_vehicle_type_vehicle_type_bool_exp!]
  description_i18n: jsonb_comparison_exp
  hsl_id: smallint_comparison_exp
  label: String_comparison_exp
  vehicle_type_id: uuid_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input timetables_vehicle_type_vehicle_type_delete_at_path_input {
  "Description of the vehicle type."
  description_i18n: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input timetables_vehicle_type_vehicle_type_delete_elem_input {
  "Description of the vehicle type."
  description_i18n: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input timetables_vehicle_type_vehicle_type_delete_key_input {
  "Description of the vehicle type."
  description_i18n: String
}

"input type for incrementing numeric columns in table \"vehicle_type.vehicle_type\""
input timetables_vehicle_type_vehicle_type_inc_input {
  "ID used in Hastus to represent the vehicle type."
  hsl_id: smallint
}

"input type for inserting data into table \"vehicle_type.vehicle_type\""
input timetables_vehicle_type_vehicle_type_insert_input {
  "Description of the vehicle type."
  description_i18n: jsonb
  "ID used in Hastus to represent the vehicle type."
  hsl_id: smallint
  "Label of the vehicle type."
  label: String
  vehicle_type_id: uuid
}

"input type for inserting object relation for remote table \"vehicle_type.vehicle_type\""
input timetables_vehicle_type_vehicle_type_obj_rel_insert_input {
  data: timetables_vehicle_type_vehicle_type_insert_input!
  "upsert condition"
  on_conflict: timetables_vehicle_type_vehicle_type_on_conflict
}

"on_conflict condition type for table \"vehicle_type.vehicle_type\""
input timetables_vehicle_type_vehicle_type_on_conflict {
  constraint: timetables_vehicle_type_vehicle_type_constraint!
  update_columns: [timetables_vehicle_type_vehicle_type_update_column!]! = []
  where: timetables_vehicle_type_vehicle_type_bool_exp
}

"Ordering options when selecting data from \"vehicle_type.vehicle_type\"."
input timetables_vehicle_type_vehicle_type_order_by {
  description_i18n: order_by
  hsl_id: order_by
  label: order_by
  vehicle_type_id: order_by
}

"primary key columns input for table: vehicle_type.vehicle_type"
input timetables_vehicle_type_vehicle_type_pk_columns_input {
  vehicle_type_id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input timetables_vehicle_type_vehicle_type_prepend_input {
  "Description of the vehicle type."
  description_i18n: jsonb
}

"input type for updating data in table \"vehicle_type.vehicle_type\""
input timetables_vehicle_type_vehicle_type_set_input {
  "Description of the vehicle type."
  description_i18n: jsonb
  "ID used in Hastus to represent the vehicle type."
  hsl_id: smallint
  "Label of the vehicle type."
  label: String
  vehicle_type_id: uuid
}

"Streaming cursor of the table \"vehicle_type_vehicle_type\""
input timetables_vehicle_type_vehicle_type_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timetables_vehicle_type_vehicle_type_stream_cursor_value_input!
  "cursor ordering"
  ordering: timetables_cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timetables_vehicle_type_vehicle_type_stream_cursor_value_input {
  "Description of the vehicle type."
  description_i18n: jsonb
  "ID used in Hastus to represent the vehicle type."
  hsl_id: smallint
  "Label of the vehicle type."
  label: String
  vehicle_type_id: uuid
}

input timetables_vehicle_type_vehicle_type_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: timetables_vehicle_type_vehicle_type_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: timetables_vehicle_type_vehicle_type_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: timetables_vehicle_type_vehicle_type_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: timetables_vehicle_type_vehicle_type_delete_key_input
  "increments the numeric columns with given value of the filtered values"
  _inc: timetables_vehicle_type_vehicle_type_inc_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: timetables_vehicle_type_vehicle_type_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: timetables_vehicle_type_vehicle_type_set_input
  "filter the rows which have to be updated"
  where: timetables_vehicle_type_vehicle_type_bool_exp!
}

"append existing jsonb value of filtered columns with new jsonb value"
input timing_pattern_timing_place_append_input {
  description: jsonb
}

"Boolean expression to filter rows from the table \"timing_pattern.timing_place\". All fields are combined with a logical 'AND'."
input timing_pattern_timing_place_bool_exp {
  _and: [timing_pattern_timing_place_bool_exp!]
  _not: timing_pattern_timing_place_bool_exp
  _or: [timing_pattern_timing_place_bool_exp!]
  description: jsonb_comparison_exp
  label: String_comparison_exp
  scheduled_stop_points: service_pattern_scheduled_stop_point_bool_exp
  scheduled_stop_points_aggregate: service_pattern_scheduled_stop_point_aggregate_bool_exp
  timing_place_id: uuid_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input timing_pattern_timing_place_delete_at_path_input {
  description: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input timing_pattern_timing_place_delete_elem_input {
  description: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input timing_pattern_timing_place_delete_key_input {
  description: String
}

"input type for inserting data into table \"timing_pattern.timing_place\""
input timing_pattern_timing_place_insert_input {
  description: jsonb
  label: String
  scheduled_stop_points: service_pattern_scheduled_stop_point_arr_rel_insert_input
  timing_place_id: uuid
}

"input type for inserting object relation for remote table \"timing_pattern.timing_place\""
input timing_pattern_timing_place_obj_rel_insert_input {
  data: timing_pattern_timing_place_insert_input!
  "upsert condition"
  on_conflict: timing_pattern_timing_place_on_conflict
}

"on_conflict condition type for table \"timing_pattern.timing_place\""
input timing_pattern_timing_place_on_conflict {
  constraint: timing_pattern_timing_place_constraint!
  update_columns: [timing_pattern_timing_place_update_column!]! = []
  where: timing_pattern_timing_place_bool_exp
}

"Ordering options when selecting data from \"timing_pattern.timing_place\"."
input timing_pattern_timing_place_order_by {
  description: order_by
  label: order_by
  scheduled_stop_points_aggregate: service_pattern_scheduled_stop_point_aggregate_order_by
  timing_place_id: order_by
}

"primary key columns input for table: timing_pattern.timing_place"
input timing_pattern_timing_place_pk_columns_input {
  timing_place_id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input timing_pattern_timing_place_prepend_input {
  description: jsonb
}

"input type for updating data in table \"timing_pattern.timing_place\""
input timing_pattern_timing_place_set_input {
  description: jsonb
  label: String
  timing_place_id: uuid
}

"Streaming cursor of the table \"timing_pattern_timing_place\""
input timing_pattern_timing_place_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: timing_pattern_timing_place_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input timing_pattern_timing_place_stream_cursor_value_input {
  description: jsonb
  label: String
  timing_place_id: uuid
}

input timing_pattern_timing_place_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: timing_pattern_timing_place_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: timing_pattern_timing_place_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: timing_pattern_timing_place_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: timing_pattern_timing_place_delete_key_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: timing_pattern_timing_place_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: timing_pattern_timing_place_set_input
  "filter the rows which have to be updated"
  where: timing_pattern_timing_place_bool_exp!
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

input vehicle_journey_vehicle_journey_aggregate_bool_exp {
  bool_and: vehicle_journey_vehicle_journey_aggregate_bool_exp_bool_and
  bool_or: vehicle_journey_vehicle_journey_aggregate_bool_exp_bool_or
  count: vehicle_journey_vehicle_journey_aggregate_bool_exp_count
}

input vehicle_journey_vehicle_journey_aggregate_bool_exp_bool_and {
  arguments: timetables_vehicle_journey_vehicle_journey_select_column_vehicle_journey_vehicle_journey_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: timetables_vehicle_journey_vehicle_journey_bool_exp
  predicate: Boolean_comparison_exp!
}

input vehicle_journey_vehicle_journey_aggregate_bool_exp_bool_or {
  arguments: timetables_vehicle_journey_vehicle_journey_select_column_vehicle_journey_vehicle_journey_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: timetables_vehicle_journey_vehicle_journey_bool_exp
  predicate: Boolean_comparison_exp!
}

input vehicle_journey_vehicle_journey_aggregate_bool_exp_count {
  arguments: [timetables_vehicle_journey_vehicle_journey_select_column!]
  distinct: Boolean
  filter: timetables_vehicle_journey_vehicle_journey_bool_exp
  predicate: Int_comparison_exp!
}

input vehicle_service_block_aggregate_bool_exp {
  count: vehicle_service_block_aggregate_bool_exp_count
}

input vehicle_service_block_aggregate_bool_exp_count {
  arguments: [timetables_vehicle_service_block_select_column!]
  distinct: Boolean
  filter: timetables_vehicle_service_block_bool_exp
  predicate: Int_comparison_exp!
}

input vehicle_service_journey_patterns_in_vehicle_service_aggregate_bool_exp {
  count: vehicle_service_journey_patterns_in_vehicle_service_aggregate_bool_exp_count
}

input vehicle_service_journey_patterns_in_vehicle_service_aggregate_bool_exp_count {
  arguments: [timetables_vehicle_service_journey_patterns_in_vehicle_service_select_column!]
  distinct: Boolean
  filter: timetables_vehicle_service_journey_patterns_in_vehicle_service_bool_exp
  predicate: Int_comparison_exp!
}

input vehicle_service_vehicle_service_aggregate_bool_exp {
  count: vehicle_service_vehicle_service_aggregate_bool_exp_count
}

input vehicle_service_vehicle_service_aggregate_bool_exp_count {
  arguments: [timetables_vehicle_service_vehicle_service_select_column!]
  distinct: Boolean
  filter: timetables_vehicle_service_vehicle_service_bool_exp
  predicate: Int_comparison_exp!
}
